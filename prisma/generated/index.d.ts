
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model auditoria
 * 
 */
export type auditoria = $Result.DefaultSelection<Prisma.$auditoriaPayload>
/**
 * Model categorias
 * 
 */
export type categorias = $Result.DefaultSelection<Prisma.$categoriasPayload>
/**
 * Model usuariosEstudiantes
 * 
 */
export type usuariosEstudiantes = $Result.DefaultSelection<Prisma.$usuariosEstudiantesPayload>
/**
 * Model estudiantes
 * 
 */
export type estudiantes = $Result.DefaultSelection<Prisma.$estudiantesPayload>
/**
 * Model usuariosAdministradores
 * 
 */
export type usuariosAdministradores = $Result.DefaultSelection<Prisma.$usuariosAdministradoresPayload>
/**
 * Model docente
 * 
 */
export type docente = $Result.DefaultSelection<Prisma.$docentePayload>
/**
 * Model cursos
 * 
 */
export type cursos = $Result.DefaultSelection<Prisma.$cursosPayload>
/**
 * Model categoriasCursos
 * 
 */
export type categoriasCursos = $Result.DefaultSelection<Prisma.$categoriasCursosPayload>
/**
 * Model reviewsCursos
 * 
 */
export type reviewsCursos = $Result.DefaultSelection<Prisma.$reviewsCursosPayload>
/**
 * Model edicionesCursos
 * 
 */
export type edicionesCursos = $Result.DefaultSelection<Prisma.$edicionesCursosPayload>
/**
 * Model beneficiosCursos
 * 
 */
export type beneficiosCursos = $Result.DefaultSelection<Prisma.$beneficiosCursosPayload>
/**
 * Model objetivosCursos
 * 
 */
export type objetivosCursos = $Result.DefaultSelection<Prisma.$objetivosCursosPayload>
/**
 * Model requisitosCursos
 * 
 */
export type requisitosCursos = $Result.DefaultSelection<Prisma.$requisitosCursosPayload>
/**
 * Model clases
 * 
 */
export type clases = $Result.DefaultSelection<Prisma.$clasesPayload>
/**
 * Model materiales
 * 
 */
export type materiales = $Result.DefaultSelection<Prisma.$materialesPayload>
/**
 * Model examenes
 * 
 */
export type examenes = $Result.DefaultSelection<Prisma.$examenesPayload>
/**
 * Model calificaciones
 * 
 */
export type calificaciones = $Result.DefaultSelection<Prisma.$calificacionesPayload>
/**
 * Model inscripciones
 * 
 */
export type inscripciones = $Result.DefaultSelection<Prisma.$inscripcionesPayload>
/**
 * Model certificados
 * 
 */
export type certificados = $Result.DefaultSelection<Prisma.$certificadosPayload>
/**
 * Model preciosCursos
 * 
 */
export type preciosCursos = $Result.DefaultSelection<Prisma.$preciosCursosPayload>
/**
 * Model compras
 * 
 */
export type compras = $Result.DefaultSelection<Prisma.$comprasPayload>
/**
 * Model grabaciones
 * 
 */
export type grabaciones = $Result.DefaultSelection<Prisma.$grabacionesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TipoCuenta: {
  ADMINISTRADOR: 'ADMINISTRADOR',
  MODERADOR: 'MODERADOR',
  DOCENTE: 'DOCENTE'
};

export type TipoCuenta = (typeof TipoCuenta)[keyof typeof TipoCuenta]


export const TipoGenero: {
  HOMBRE: 'HOMBRE',
  MUJER: 'MUJER'
};

export type TipoGenero = (typeof TipoGenero)[keyof typeof TipoGenero]


export const EdicionEstado: {
  ESPERA: 'ESPERA',
  ACTIVA: 'ACTIVA',
  FINALIZADA: 'FINALIZADA'
};

export type EdicionEstado = (typeof EdicionEstado)[keyof typeof EdicionEstado]


export const EstadoPago: {
  PENDIENTE: 'PENDIENTE',
  COMPLETADO: 'COMPLETADO',
  RECHAZADO: 'RECHAZADO',
  REEMBOLSADO: 'REEMBOLSADO'
};

export type EstadoPago = (typeof EstadoPago)[keyof typeof EstadoPago]


export const AccionAuditoria: {
  CREAR: 'CREAR',
  ACTUALIZAR: 'ACTUALIZAR',
  ESTADO: 'ESTADO',
  ELIMINAR: 'ELIMINAR'
};

export type AccionAuditoria = (typeof AccionAuditoria)[keyof typeof AccionAuditoria]

}

export type TipoCuenta = $Enums.TipoCuenta

export const TipoCuenta: typeof $Enums.TipoCuenta

export type TipoGenero = $Enums.TipoGenero

export const TipoGenero: typeof $Enums.TipoGenero

export type EdicionEstado = $Enums.EdicionEstado

export const EdicionEstado: typeof $Enums.EdicionEstado

export type EstadoPago = $Enums.EstadoPago

export const EstadoPago: typeof $Enums.EstadoPago

export type AccionAuditoria = $Enums.AccionAuditoria

export const AccionAuditoria: typeof $Enums.AccionAuditoria

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Auditorias
 * const auditorias = await prisma.auditoria.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Auditorias
   * const auditorias = await prisma.auditoria.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.auditoria`: Exposes CRUD operations for the **auditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditorias
    * const auditorias = await prisma.auditoria.findMany()
    * ```
    */
  get auditoria(): Prisma.auditoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categorias`: Exposes CRUD operations for the **categorias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categorias.findMany()
    * ```
    */
  get categorias(): Prisma.categoriasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuariosEstudiantes`: Exposes CRUD operations for the **usuariosEstudiantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuariosEstudiantes
    * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findMany()
    * ```
    */
  get usuariosEstudiantes(): Prisma.usuariosEstudiantesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estudiantes`: Exposes CRUD operations for the **estudiantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estudiantes
    * const estudiantes = await prisma.estudiantes.findMany()
    * ```
    */
  get estudiantes(): Prisma.estudiantesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuariosAdministradores`: Exposes CRUD operations for the **usuariosAdministradores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuariosAdministradores
    * const usuariosAdministradores = await prisma.usuariosAdministradores.findMany()
    * ```
    */
  get usuariosAdministradores(): Prisma.usuariosAdministradoresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.docente`: Exposes CRUD operations for the **docente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Docentes
    * const docentes = await prisma.docente.findMany()
    * ```
    */
  get docente(): Prisma.docenteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cursos`: Exposes CRUD operations for the **cursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cursos
    * const cursos = await prisma.cursos.findMany()
    * ```
    */
  get cursos(): Prisma.cursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoriasCursos`: Exposes CRUD operations for the **categoriasCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoriasCursos
    * const categoriasCursos = await prisma.categoriasCursos.findMany()
    * ```
    */
  get categoriasCursos(): Prisma.categoriasCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewsCursos`: Exposes CRUD operations for the **reviewsCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewsCursos
    * const reviewsCursos = await prisma.reviewsCursos.findMany()
    * ```
    */
  get reviewsCursos(): Prisma.reviewsCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.edicionesCursos`: Exposes CRUD operations for the **edicionesCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EdicionesCursos
    * const edicionesCursos = await prisma.edicionesCursos.findMany()
    * ```
    */
  get edicionesCursos(): Prisma.edicionesCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.beneficiosCursos`: Exposes CRUD operations for the **beneficiosCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BeneficiosCursos
    * const beneficiosCursos = await prisma.beneficiosCursos.findMany()
    * ```
    */
  get beneficiosCursos(): Prisma.beneficiosCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.objetivosCursos`: Exposes CRUD operations for the **objetivosCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjetivosCursos
    * const objetivosCursos = await prisma.objetivosCursos.findMany()
    * ```
    */
  get objetivosCursos(): Prisma.objetivosCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requisitosCursos`: Exposes CRUD operations for the **requisitosCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequisitosCursos
    * const requisitosCursos = await prisma.requisitosCursos.findMany()
    * ```
    */
  get requisitosCursos(): Prisma.requisitosCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clases`: Exposes CRUD operations for the **clases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clases
    * const clases = await prisma.clases.findMany()
    * ```
    */
  get clases(): Prisma.clasesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materiales`: Exposes CRUD operations for the **materiales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materiales
    * const materiales = await prisma.materiales.findMany()
    * ```
    */
  get materiales(): Prisma.materialesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examenes`: Exposes CRUD operations for the **examenes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Examenes
    * const examenes = await prisma.examenes.findMany()
    * ```
    */
  get examenes(): Prisma.examenesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calificaciones`: Exposes CRUD operations for the **calificaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calificaciones
    * const calificaciones = await prisma.calificaciones.findMany()
    * ```
    */
  get calificaciones(): Prisma.calificacionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inscripciones`: Exposes CRUD operations for the **inscripciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inscripciones
    * const inscripciones = await prisma.inscripciones.findMany()
    * ```
    */
  get inscripciones(): Prisma.inscripcionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificados`: Exposes CRUD operations for the **certificados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificados
    * const certificados = await prisma.certificados.findMany()
    * ```
    */
  get certificados(): Prisma.certificadosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preciosCursos`: Exposes CRUD operations for the **preciosCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreciosCursos
    * const preciosCursos = await prisma.preciosCursos.findMany()
    * ```
    */
  get preciosCursos(): Prisma.preciosCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.compras`: Exposes CRUD operations for the **compras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Compras
    * const compras = await prisma.compras.findMany()
    * ```
    */
  get compras(): Prisma.comprasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grabaciones`: Exposes CRUD operations for the **grabaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grabaciones
    * const grabaciones = await prisma.grabaciones.findMany()
    * ```
    */
  get grabaciones(): Prisma.grabacionesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    auditoria: 'auditoria',
    categorias: 'categorias',
    usuariosEstudiantes: 'usuariosEstudiantes',
    estudiantes: 'estudiantes',
    usuariosAdministradores: 'usuariosAdministradores',
    docente: 'docente',
    cursos: 'cursos',
    categoriasCursos: 'categoriasCursos',
    reviewsCursos: 'reviewsCursos',
    edicionesCursos: 'edicionesCursos',
    beneficiosCursos: 'beneficiosCursos',
    objetivosCursos: 'objetivosCursos',
    requisitosCursos: 'requisitosCursos',
    clases: 'clases',
    materiales: 'materiales',
    examenes: 'examenes',
    calificaciones: 'calificaciones',
    inscripciones: 'inscripciones',
    certificados: 'certificados',
    preciosCursos: 'preciosCursos',
    compras: 'compras',
    grabaciones: 'grabaciones'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "auditoria" | "categorias" | "usuariosEstudiantes" | "estudiantes" | "usuariosAdministradores" | "docente" | "cursos" | "categoriasCursos" | "reviewsCursos" | "edicionesCursos" | "beneficiosCursos" | "objetivosCursos" | "requisitosCursos" | "clases" | "materiales" | "examenes" | "calificaciones" | "inscripciones" | "certificados" | "preciosCursos" | "compras" | "grabaciones"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      auditoria: {
        payload: Prisma.$auditoriaPayload<ExtArgs>
        fields: Prisma.auditoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          findFirst: {
            args: Prisma.auditoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          findMany: {
            args: Prisma.auditoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>[]
          }
          create: {
            args: Prisma.auditoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          createMany: {
            args: Prisma.auditoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auditoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>[]
          }
          delete: {
            args: Prisma.auditoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          update: {
            args: Prisma.auditoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          deleteMany: {
            args: Prisma.auditoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auditoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>[]
          }
          upsert: {
            args: Prisma.auditoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          aggregate: {
            args: Prisma.AuditoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditoria>
          }
          groupBy: {
            args: Prisma.auditoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.auditoriaCountArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaCountAggregateOutputType> | number
          }
        }
      }
      categorias: {
        payload: Prisma.$categoriasPayload<ExtArgs>
        fields: Prisma.categoriasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          findFirst: {
            args: Prisma.categoriasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          findMany: {
            args: Prisma.categoriasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>[]
          }
          create: {
            args: Prisma.categoriasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          createMany: {
            args: Prisma.categoriasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>[]
          }
          delete: {
            args: Prisma.categoriasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          update: {
            args: Prisma.categoriasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          deleteMany: {
            args: Prisma.categoriasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>[]
          }
          upsert: {
            args: Prisma.categoriasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          aggregate: {
            args: Prisma.CategoriasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategorias>
          }
          groupBy: {
            args: Prisma.categoriasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriasGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriasCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriasCountAggregateOutputType> | number
          }
        }
      }
      usuariosEstudiantes: {
        payload: Prisma.$usuariosEstudiantesPayload<ExtArgs>
        fields: Prisma.usuariosEstudiantesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuariosEstudiantesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuariosEstudiantesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          findFirst: {
            args: Prisma.usuariosEstudiantesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuariosEstudiantesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          findMany: {
            args: Prisma.usuariosEstudiantesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>[]
          }
          create: {
            args: Prisma.usuariosEstudiantesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          createMany: {
            args: Prisma.usuariosEstudiantesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuariosEstudiantesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>[]
          }
          delete: {
            args: Prisma.usuariosEstudiantesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          update: {
            args: Prisma.usuariosEstudiantesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          deleteMany: {
            args: Prisma.usuariosEstudiantesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuariosEstudiantesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usuariosEstudiantesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>[]
          }
          upsert: {
            args: Prisma.usuariosEstudiantesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          aggregate: {
            args: Prisma.UsuariosEstudiantesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuariosEstudiantes>
          }
          groupBy: {
            args: Prisma.usuariosEstudiantesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosEstudiantesGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuariosEstudiantesCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosEstudiantesCountAggregateOutputType> | number
          }
        }
      }
      estudiantes: {
        payload: Prisma.$estudiantesPayload<ExtArgs>
        fields: Prisma.estudiantesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estudiantesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estudiantesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          findFirst: {
            args: Prisma.estudiantesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estudiantesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          findMany: {
            args: Prisma.estudiantesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>[]
          }
          create: {
            args: Prisma.estudiantesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          createMany: {
            args: Prisma.estudiantesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.estudiantesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>[]
          }
          delete: {
            args: Prisma.estudiantesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          update: {
            args: Prisma.estudiantesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          deleteMany: {
            args: Prisma.estudiantesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estudiantesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.estudiantesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>[]
          }
          upsert: {
            args: Prisma.estudiantesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          aggregate: {
            args: Prisma.EstudiantesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudiantes>
          }
          groupBy: {
            args: Prisma.estudiantesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudiantesGroupByOutputType>[]
          }
          count: {
            args: Prisma.estudiantesCountArgs<ExtArgs>
            result: $Utils.Optional<EstudiantesCountAggregateOutputType> | number
          }
        }
      }
      usuariosAdministradores: {
        payload: Prisma.$usuariosAdministradoresPayload<ExtArgs>
        fields: Prisma.usuariosAdministradoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuariosAdministradoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuariosAdministradoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          findFirst: {
            args: Prisma.usuariosAdministradoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuariosAdministradoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          findMany: {
            args: Prisma.usuariosAdministradoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>[]
          }
          create: {
            args: Prisma.usuariosAdministradoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          createMany: {
            args: Prisma.usuariosAdministradoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuariosAdministradoresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>[]
          }
          delete: {
            args: Prisma.usuariosAdministradoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          update: {
            args: Prisma.usuariosAdministradoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          deleteMany: {
            args: Prisma.usuariosAdministradoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuariosAdministradoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usuariosAdministradoresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>[]
          }
          upsert: {
            args: Prisma.usuariosAdministradoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAdministradoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuariosAdministradores>
          }
          groupBy: {
            args: Prisma.usuariosAdministradoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosAdministradoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuariosAdministradoresCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosAdministradoresCountAggregateOutputType> | number
          }
        }
      }
      docente: {
        payload: Prisma.$docentePayload<ExtArgs>
        fields: Prisma.docenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.docenteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.docenteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          findFirst: {
            args: Prisma.docenteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.docenteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          findMany: {
            args: Prisma.docenteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>[]
          }
          create: {
            args: Prisma.docenteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          createMany: {
            args: Prisma.docenteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.docenteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>[]
          }
          delete: {
            args: Prisma.docenteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          update: {
            args: Prisma.docenteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          deleteMany: {
            args: Prisma.docenteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.docenteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.docenteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>[]
          }
          upsert: {
            args: Prisma.docenteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          aggregate: {
            args: Prisma.DocenteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocente>
          }
          groupBy: {
            args: Prisma.docenteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.docenteCountArgs<ExtArgs>
            result: $Utils.Optional<DocenteCountAggregateOutputType> | number
          }
        }
      }
      cursos: {
        payload: Prisma.$cursosPayload<ExtArgs>
        fields: Prisma.cursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          findFirst: {
            args: Prisma.cursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          findMany: {
            args: Prisma.cursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>[]
          }
          create: {
            args: Prisma.cursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          createMany: {
            args: Prisma.cursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>[]
          }
          delete: {
            args: Prisma.cursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          update: {
            args: Prisma.cursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          deleteMany: {
            args: Prisma.cursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>[]
          }
          upsert: {
            args: Prisma.cursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          aggregate: {
            args: Prisma.CursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCursos>
          }
          groupBy: {
            args: Prisma.cursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.cursosCountArgs<ExtArgs>
            result: $Utils.Optional<CursosCountAggregateOutputType> | number
          }
        }
      }
      categoriasCursos: {
        payload: Prisma.$categoriasCursosPayload<ExtArgs>
        fields: Prisma.categoriasCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriasCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriasCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          findFirst: {
            args: Prisma.categoriasCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriasCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          findMany: {
            args: Prisma.categoriasCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>[]
          }
          create: {
            args: Prisma.categoriasCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          createMany: {
            args: Prisma.categoriasCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriasCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>[]
          }
          delete: {
            args: Prisma.categoriasCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          update: {
            args: Prisma.categoriasCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          deleteMany: {
            args: Prisma.categoriasCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriasCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriasCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>[]
          }
          upsert: {
            args: Prisma.categoriasCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          aggregate: {
            args: Prisma.CategoriasCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoriasCursos>
          }
          groupBy: {
            args: Prisma.categoriasCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriasCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriasCursosCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriasCursosCountAggregateOutputType> | number
          }
        }
      }
      reviewsCursos: {
        payload: Prisma.$reviewsCursosPayload<ExtArgs>
        fields: Prisma.reviewsCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewsCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewsCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          findFirst: {
            args: Prisma.reviewsCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewsCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          findMany: {
            args: Prisma.reviewsCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>[]
          }
          create: {
            args: Prisma.reviewsCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          createMany: {
            args: Prisma.reviewsCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewsCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>[]
          }
          delete: {
            args: Prisma.reviewsCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          update: {
            args: Prisma.reviewsCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          deleteMany: {
            args: Prisma.reviewsCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewsCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewsCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>[]
          }
          upsert: {
            args: Prisma.reviewsCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          aggregate: {
            args: Prisma.ReviewsCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewsCursos>
          }
          groupBy: {
            args: Prisma.reviewsCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewsCursosCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCursosCountAggregateOutputType> | number
          }
        }
      }
      edicionesCursos: {
        payload: Prisma.$edicionesCursosPayload<ExtArgs>
        fields: Prisma.edicionesCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.edicionesCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.edicionesCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          findFirst: {
            args: Prisma.edicionesCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.edicionesCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          findMany: {
            args: Prisma.edicionesCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>[]
          }
          create: {
            args: Prisma.edicionesCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          createMany: {
            args: Prisma.edicionesCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.edicionesCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>[]
          }
          delete: {
            args: Prisma.edicionesCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          update: {
            args: Prisma.edicionesCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          deleteMany: {
            args: Prisma.edicionesCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.edicionesCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.edicionesCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>[]
          }
          upsert: {
            args: Prisma.edicionesCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          aggregate: {
            args: Prisma.EdicionesCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEdicionesCursos>
          }
          groupBy: {
            args: Prisma.edicionesCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<EdicionesCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.edicionesCursosCountArgs<ExtArgs>
            result: $Utils.Optional<EdicionesCursosCountAggregateOutputType> | number
          }
        }
      }
      beneficiosCursos: {
        payload: Prisma.$beneficiosCursosPayload<ExtArgs>
        fields: Prisma.beneficiosCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.beneficiosCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.beneficiosCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          findFirst: {
            args: Prisma.beneficiosCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.beneficiosCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          findMany: {
            args: Prisma.beneficiosCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>[]
          }
          create: {
            args: Prisma.beneficiosCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          createMany: {
            args: Prisma.beneficiosCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.beneficiosCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>[]
          }
          delete: {
            args: Prisma.beneficiosCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          update: {
            args: Prisma.beneficiosCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          deleteMany: {
            args: Prisma.beneficiosCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.beneficiosCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.beneficiosCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>[]
          }
          upsert: {
            args: Prisma.beneficiosCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          aggregate: {
            args: Prisma.BeneficiosCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeneficiosCursos>
          }
          groupBy: {
            args: Prisma.beneficiosCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<BeneficiosCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.beneficiosCursosCountArgs<ExtArgs>
            result: $Utils.Optional<BeneficiosCursosCountAggregateOutputType> | number
          }
        }
      }
      objetivosCursos: {
        payload: Prisma.$objetivosCursosPayload<ExtArgs>
        fields: Prisma.objetivosCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.objetivosCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.objetivosCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          findFirst: {
            args: Prisma.objetivosCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.objetivosCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          findMany: {
            args: Prisma.objetivosCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>[]
          }
          create: {
            args: Prisma.objetivosCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          createMany: {
            args: Prisma.objetivosCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.objetivosCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>[]
          }
          delete: {
            args: Prisma.objetivosCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          update: {
            args: Prisma.objetivosCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          deleteMany: {
            args: Prisma.objetivosCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.objetivosCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.objetivosCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>[]
          }
          upsert: {
            args: Prisma.objetivosCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          aggregate: {
            args: Prisma.ObjetivosCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObjetivosCursos>
          }
          groupBy: {
            args: Prisma.objetivosCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObjetivosCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.objetivosCursosCountArgs<ExtArgs>
            result: $Utils.Optional<ObjetivosCursosCountAggregateOutputType> | number
          }
        }
      }
      requisitosCursos: {
        payload: Prisma.$requisitosCursosPayload<ExtArgs>
        fields: Prisma.requisitosCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.requisitosCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.requisitosCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          findFirst: {
            args: Prisma.requisitosCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.requisitosCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          findMany: {
            args: Prisma.requisitosCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>[]
          }
          create: {
            args: Prisma.requisitosCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          createMany: {
            args: Prisma.requisitosCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.requisitosCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>[]
          }
          delete: {
            args: Prisma.requisitosCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          update: {
            args: Prisma.requisitosCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          deleteMany: {
            args: Prisma.requisitosCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.requisitosCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.requisitosCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>[]
          }
          upsert: {
            args: Prisma.requisitosCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          aggregate: {
            args: Prisma.RequisitosCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequisitosCursos>
          }
          groupBy: {
            args: Prisma.requisitosCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequisitosCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.requisitosCursosCountArgs<ExtArgs>
            result: $Utils.Optional<RequisitosCursosCountAggregateOutputType> | number
          }
        }
      }
      clases: {
        payload: Prisma.$clasesPayload<ExtArgs>
        fields: Prisma.clasesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clasesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clasesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          findFirst: {
            args: Prisma.clasesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clasesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          findMany: {
            args: Prisma.clasesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>[]
          }
          create: {
            args: Prisma.clasesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          createMany: {
            args: Prisma.clasesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clasesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>[]
          }
          delete: {
            args: Prisma.clasesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          update: {
            args: Prisma.clasesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          deleteMany: {
            args: Prisma.clasesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clasesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clasesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>[]
          }
          upsert: {
            args: Prisma.clasesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          aggregate: {
            args: Prisma.ClasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClases>
          }
          groupBy: {
            args: Prisma.clasesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.clasesCountArgs<ExtArgs>
            result: $Utils.Optional<ClasesCountAggregateOutputType> | number
          }
        }
      }
      materiales: {
        payload: Prisma.$materialesPayload<ExtArgs>
        fields: Prisma.materialesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.materialesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.materialesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          findFirst: {
            args: Prisma.materialesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.materialesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          findMany: {
            args: Prisma.materialesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>[]
          }
          create: {
            args: Prisma.materialesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          createMany: {
            args: Prisma.materialesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.materialesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>[]
          }
          delete: {
            args: Prisma.materialesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          update: {
            args: Prisma.materialesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          deleteMany: {
            args: Prisma.materialesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.materialesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.materialesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>[]
          }
          upsert: {
            args: Prisma.materialesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          aggregate: {
            args: Prisma.MaterialesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMateriales>
          }
          groupBy: {
            args: Prisma.materialesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialesGroupByOutputType>[]
          }
          count: {
            args: Prisma.materialesCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialesCountAggregateOutputType> | number
          }
        }
      }
      examenes: {
        payload: Prisma.$examenesPayload<ExtArgs>
        fields: Prisma.examenesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.examenesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.examenesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          findFirst: {
            args: Prisma.examenesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.examenesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          findMany: {
            args: Prisma.examenesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>[]
          }
          create: {
            args: Prisma.examenesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          createMany: {
            args: Prisma.examenesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.examenesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>[]
          }
          delete: {
            args: Prisma.examenesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          update: {
            args: Prisma.examenesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          deleteMany: {
            args: Prisma.examenesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.examenesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.examenesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>[]
          }
          upsert: {
            args: Prisma.examenesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          aggregate: {
            args: Prisma.ExamenesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamenes>
          }
          groupBy: {
            args: Prisma.examenesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamenesGroupByOutputType>[]
          }
          count: {
            args: Prisma.examenesCountArgs<ExtArgs>
            result: $Utils.Optional<ExamenesCountAggregateOutputType> | number
          }
        }
      }
      calificaciones: {
        payload: Prisma.$calificacionesPayload<ExtArgs>
        fields: Prisma.calificacionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.calificacionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.calificacionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          findFirst: {
            args: Prisma.calificacionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.calificacionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          findMany: {
            args: Prisma.calificacionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>[]
          }
          create: {
            args: Prisma.calificacionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          createMany: {
            args: Prisma.calificacionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.calificacionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>[]
          }
          delete: {
            args: Prisma.calificacionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          update: {
            args: Prisma.calificacionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          deleteMany: {
            args: Prisma.calificacionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.calificacionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.calificacionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>[]
          }
          upsert: {
            args: Prisma.calificacionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          aggregate: {
            args: Prisma.CalificacionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalificaciones>
          }
          groupBy: {
            args: Prisma.calificacionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalificacionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.calificacionesCountArgs<ExtArgs>
            result: $Utils.Optional<CalificacionesCountAggregateOutputType> | number
          }
        }
      }
      inscripciones: {
        payload: Prisma.$inscripcionesPayload<ExtArgs>
        fields: Prisma.inscripcionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inscripcionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inscripcionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          findFirst: {
            args: Prisma.inscripcionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inscripcionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          findMany: {
            args: Prisma.inscripcionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>[]
          }
          create: {
            args: Prisma.inscripcionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          createMany: {
            args: Prisma.inscripcionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inscripcionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>[]
          }
          delete: {
            args: Prisma.inscripcionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          update: {
            args: Prisma.inscripcionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          deleteMany: {
            args: Prisma.inscripcionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inscripcionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.inscripcionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>[]
          }
          upsert: {
            args: Prisma.inscripcionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          aggregate: {
            args: Prisma.InscripcionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInscripciones>
          }
          groupBy: {
            args: Prisma.inscripcionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InscripcionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.inscripcionesCountArgs<ExtArgs>
            result: $Utils.Optional<InscripcionesCountAggregateOutputType> | number
          }
        }
      }
      certificados: {
        payload: Prisma.$certificadosPayload<ExtArgs>
        fields: Prisma.certificadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.certificadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.certificadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          findFirst: {
            args: Prisma.certificadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.certificadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          findMany: {
            args: Prisma.certificadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>[]
          }
          create: {
            args: Prisma.certificadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          createMany: {
            args: Prisma.certificadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.certificadosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>[]
          }
          delete: {
            args: Prisma.certificadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          update: {
            args: Prisma.certificadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          deleteMany: {
            args: Prisma.certificadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.certificadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.certificadosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>[]
          }
          upsert: {
            args: Prisma.certificadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          aggregate: {
            args: Prisma.CertificadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificados>
          }
          groupBy: {
            args: Prisma.certificadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.certificadosCountArgs<ExtArgs>
            result: $Utils.Optional<CertificadosCountAggregateOutputType> | number
          }
        }
      }
      preciosCursos: {
        payload: Prisma.$preciosCursosPayload<ExtArgs>
        fields: Prisma.preciosCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.preciosCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.preciosCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          findFirst: {
            args: Prisma.preciosCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.preciosCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          findMany: {
            args: Prisma.preciosCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>[]
          }
          create: {
            args: Prisma.preciosCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          createMany: {
            args: Prisma.preciosCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.preciosCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>[]
          }
          delete: {
            args: Prisma.preciosCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          update: {
            args: Prisma.preciosCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          deleteMany: {
            args: Prisma.preciosCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.preciosCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.preciosCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>[]
          }
          upsert: {
            args: Prisma.preciosCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          aggregate: {
            args: Prisma.PreciosCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreciosCursos>
          }
          groupBy: {
            args: Prisma.preciosCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreciosCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.preciosCursosCountArgs<ExtArgs>
            result: $Utils.Optional<PreciosCursosCountAggregateOutputType> | number
          }
        }
      }
      compras: {
        payload: Prisma.$comprasPayload<ExtArgs>
        fields: Prisma.comprasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comprasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comprasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          findFirst: {
            args: Prisma.comprasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comprasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          findMany: {
            args: Prisma.comprasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>[]
          }
          create: {
            args: Prisma.comprasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          createMany: {
            args: Prisma.comprasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.comprasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>[]
          }
          delete: {
            args: Prisma.comprasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          update: {
            args: Prisma.comprasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          deleteMany: {
            args: Prisma.comprasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comprasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.comprasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>[]
          }
          upsert: {
            args: Prisma.comprasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          aggregate: {
            args: Prisma.ComprasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompras>
          }
          groupBy: {
            args: Prisma.comprasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComprasGroupByOutputType>[]
          }
          count: {
            args: Prisma.comprasCountArgs<ExtArgs>
            result: $Utils.Optional<ComprasCountAggregateOutputType> | number
          }
        }
      }
      grabaciones: {
        payload: Prisma.$grabacionesPayload<ExtArgs>
        fields: Prisma.grabacionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.grabacionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.grabacionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          findFirst: {
            args: Prisma.grabacionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.grabacionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          findMany: {
            args: Prisma.grabacionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>[]
          }
          create: {
            args: Prisma.grabacionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          createMany: {
            args: Prisma.grabacionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.grabacionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>[]
          }
          delete: {
            args: Prisma.grabacionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          update: {
            args: Prisma.grabacionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          deleteMany: {
            args: Prisma.grabacionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.grabacionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.grabacionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>[]
          }
          upsert: {
            args: Prisma.grabacionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          aggregate: {
            args: Prisma.GrabacionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrabaciones>
          }
          groupBy: {
            args: Prisma.grabacionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GrabacionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.grabacionesCountArgs<ExtArgs>
            result: $Utils.Optional<GrabacionesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    auditoria?: auditoriaOmit
    categorias?: categoriasOmit
    usuariosEstudiantes?: usuariosEstudiantesOmit
    estudiantes?: estudiantesOmit
    usuariosAdministradores?: usuariosAdministradoresOmit
    docente?: docenteOmit
    cursos?: cursosOmit
    categoriasCursos?: categoriasCursosOmit
    reviewsCursos?: reviewsCursosOmit
    edicionesCursos?: edicionesCursosOmit
    beneficiosCursos?: beneficiosCursosOmit
    objetivosCursos?: objetivosCursosOmit
    requisitosCursos?: requisitosCursosOmit
    clases?: clasesOmit
    materiales?: materialesOmit
    examenes?: examenesOmit
    calificaciones?: calificacionesOmit
    inscripciones?: inscripcionesOmit
    certificados?: certificadosOmit
    preciosCursos?: preciosCursosOmit
    compras?: comprasOmit
    grabaciones?: grabacionesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriasCountOutputType
   */

  export type CategoriasCountOutputType = {
    categoriasCursos: number
  }

  export type CategoriasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoriasCursos?: boolean | CategoriasCountOutputTypeCountCategoriasCursosArgs
  }

  // Custom InputTypes
  /**
   * CategoriasCountOutputType without action
   */
  export type CategoriasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasCountOutputType
     */
    select?: CategoriasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriasCountOutputType without action
   */
  export type CategoriasCountOutputTypeCountCategoriasCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriasCursosWhereInput
  }


  /**
   * Count Type UsuariosEstudiantesCountOutputType
   */

  export type UsuariosEstudiantesCountOutputType = {
    reviews: number
    compras: number
  }

  export type UsuariosEstudiantesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | UsuariosEstudiantesCountOutputTypeCountReviewsArgs
    compras?: boolean | UsuariosEstudiantesCountOutputTypeCountComprasArgs
  }

  // Custom InputTypes
  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosEstudiantesCountOutputType
     */
    select?: UsuariosEstudiantesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsCursosWhereInput
  }

  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeCountComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprasWhereInput
  }


  /**
   * Count Type EstudiantesCountOutputType
   */

  export type EstudiantesCountOutputType = {
    calificaciones: number
    certificados: number
    inscripciones: number
  }

  export type EstudiantesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calificaciones?: boolean | EstudiantesCountOutputTypeCountCalificacionesArgs
    certificados?: boolean | EstudiantesCountOutputTypeCountCertificadosArgs
    inscripciones?: boolean | EstudiantesCountOutputTypeCountInscripcionesArgs
  }

  // Custom InputTypes
  /**
   * EstudiantesCountOutputType without action
   */
  export type EstudiantesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantesCountOutputType
     */
    select?: EstudiantesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstudiantesCountOutputType without action
   */
  export type EstudiantesCountOutputTypeCountCalificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: calificacionesWhereInput
  }

  /**
   * EstudiantesCountOutputType without action
   */
  export type EstudiantesCountOutputTypeCountCertificadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificadosWhereInput
  }

  /**
   * EstudiantesCountOutputType without action
   */
  export type EstudiantesCountOutputTypeCountInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inscripcionesWhereInput
  }


  /**
   * Count Type UsuariosAdministradoresCountOutputType
   */

  export type UsuariosAdministradoresCountOutputType = {
    auditorias: number
    grabaciones: number
  }

  export type UsuariosAdministradoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditorias?: boolean | UsuariosAdministradoresCountOutputTypeCountAuditoriasArgs
    grabaciones?: boolean | UsuariosAdministradoresCountOutputTypeCountGrabacionesArgs
  }

  // Custom InputTypes
  /**
   * UsuariosAdministradoresCountOutputType without action
   */
  export type UsuariosAdministradoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosAdministradoresCountOutputType
     */
    select?: UsuariosAdministradoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosAdministradoresCountOutputType without action
   */
  export type UsuariosAdministradoresCountOutputTypeCountAuditoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditoriaWhereInput
  }

  /**
   * UsuariosAdministradoresCountOutputType without action
   */
  export type UsuariosAdministradoresCountOutputTypeCountGrabacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grabacionesWhereInput
  }


  /**
   * Count Type DocenteCountOutputType
   */

  export type DocenteCountOutputType = {
    ediciones: number
  }

  export type DocenteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ediciones?: boolean | DocenteCountOutputTypeCountEdicionesArgs
  }

  // Custom InputTypes
  /**
   * DocenteCountOutputType without action
   */
  export type DocenteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocenteCountOutputType
     */
    select?: DocenteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocenteCountOutputType without action
   */
  export type DocenteCountOutputTypeCountEdicionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: edicionesCursosWhereInput
  }


  /**
   * Count Type CursosCountOutputType
   */

  export type CursosCountOutputType = {
    ediciones: number
    beneficios: number
    objetivos: number
    requisitos: number
    categorias: number
    reviews: number
  }

  export type CursosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ediciones?: boolean | CursosCountOutputTypeCountEdicionesArgs
    beneficios?: boolean | CursosCountOutputTypeCountBeneficiosArgs
    objetivos?: boolean | CursosCountOutputTypeCountObjetivosArgs
    requisitos?: boolean | CursosCountOutputTypeCountRequisitosArgs
    categorias?: boolean | CursosCountOutputTypeCountCategoriasArgs
    reviews?: boolean | CursosCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosCountOutputType
     */
    select?: CursosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountEdicionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: edicionesCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountBeneficiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: beneficiosCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountObjetivosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: objetivosCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountRequisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requisitosCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountCategoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriasCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsCursosWhereInput
  }


  /**
   * Count Type EdicionesCursosCountOutputType
   */

  export type EdicionesCursosCountOutputType = {
    compras: number
    certificados: number
    clases: number
    examenes: number
    inscripciones: number
    precios: number
  }

  export type EdicionesCursosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras?: boolean | EdicionesCursosCountOutputTypeCountComprasArgs
    certificados?: boolean | EdicionesCursosCountOutputTypeCountCertificadosArgs
    clases?: boolean | EdicionesCursosCountOutputTypeCountClasesArgs
    examenes?: boolean | EdicionesCursosCountOutputTypeCountExamenesArgs
    inscripciones?: boolean | EdicionesCursosCountOutputTypeCountInscripcionesArgs
    precios?: boolean | EdicionesCursosCountOutputTypeCountPreciosArgs
  }

  // Custom InputTypes
  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdicionesCursosCountOutputType
     */
    select?: EdicionesCursosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprasWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountCertificadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificadosWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountClasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clasesWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountExamenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examenesWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inscripcionesWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountPreciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preciosCursosWhereInput
  }


  /**
   * Count Type ClasesCountOutputType
   */

  export type ClasesCountOutputType = {
    materiales: number
    grabaciones: number
  }

  export type ClasesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiales?: boolean | ClasesCountOutputTypeCountMaterialesArgs
    grabaciones?: boolean | ClasesCountOutputTypeCountGrabacionesArgs
  }

  // Custom InputTypes
  /**
   * ClasesCountOutputType without action
   */
  export type ClasesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClasesCountOutputType
     */
    select?: ClasesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClasesCountOutputType without action
   */
  export type ClasesCountOutputTypeCountMaterialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: materialesWhereInput
  }

  /**
   * ClasesCountOutputType without action
   */
  export type ClasesCountOutputTypeCountGrabacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grabacionesWhereInput
  }


  /**
   * Count Type ExamenesCountOutputType
   */

  export type ExamenesCountOutputType = {
    calificaciones: number
  }

  export type ExamenesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calificaciones?: boolean | ExamenesCountOutputTypeCountCalificacionesArgs
  }

  // Custom InputTypes
  /**
   * ExamenesCountOutputType without action
   */
  export type ExamenesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenesCountOutputType
     */
    select?: ExamenesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamenesCountOutputType without action
   */
  export type ExamenesCountOutputTypeCountCalificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: calificacionesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model auditoria
   */

  export type AggregateAuditoria = {
    _count: AuditoriaCountAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  export type AuditoriaMinAggregateOutputType = {
    id: string | null
    tabla: string | null
    registroId: string | null
    accion: $Enums.AccionAuditoria | null
    usuarioId: string | null
    creadoEn: Date | null
  }

  export type AuditoriaMaxAggregateOutputType = {
    id: string | null
    tabla: string | null
    registroId: string | null
    accion: $Enums.AccionAuditoria | null
    usuarioId: string | null
    creadoEn: Date | null
  }

  export type AuditoriaCountAggregateOutputType = {
    id: number
    tabla: number
    registroId: number
    accion: number
    detalles: number
    usuarioId: number
    creadoEn: number
    _all: number
  }


  export type AuditoriaMinAggregateInputType = {
    id?: true
    tabla?: true
    registroId?: true
    accion?: true
    usuarioId?: true
    creadoEn?: true
  }

  export type AuditoriaMaxAggregateInputType = {
    id?: true
    tabla?: true
    registroId?: true
    accion?: true
    usuarioId?: true
    creadoEn?: true
  }

  export type AuditoriaCountAggregateInputType = {
    id?: true
    tabla?: true
    registroId?: true
    accion?: true
    detalles?: true
    usuarioId?: true
    creadoEn?: true
    _all?: true
  }

  export type AuditoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditoria to aggregate.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditorias
    **/
    _count?: true | AuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditoriaMaxAggregateInputType
  }

  export type GetAuditoriaAggregateType<T extends AuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditoria[P]>
      : GetScalarType<T[P], AggregateAuditoria[P]>
  }




  export type auditoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditoriaWhereInput
    orderBy?: auditoriaOrderByWithAggregationInput | auditoriaOrderByWithAggregationInput[]
    by: AuditoriaScalarFieldEnum[] | AuditoriaScalarFieldEnum
    having?: auditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditoriaCountAggregateInputType | true
    _min?: AuditoriaMinAggregateInputType
    _max?: AuditoriaMaxAggregateInputType
  }

  export type AuditoriaGroupByOutputType = {
    id: string
    tabla: string
    registroId: string | null
    accion: $Enums.AccionAuditoria
    detalles: JsonValue | null
    usuarioId: string | null
    creadoEn: Date
    _count: AuditoriaCountAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  type GetAuditoriaGroupByPayload<T extends auditoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type auditoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tabla?: boolean
    registroId?: boolean
    accion?: boolean
    detalles?: boolean
    usuarioId?: boolean
    creadoEn?: boolean
    usuario?: boolean | auditoria$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>

  export type auditoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tabla?: boolean
    registroId?: boolean
    accion?: boolean
    detalles?: boolean
    usuarioId?: boolean
    creadoEn?: boolean
    usuario?: boolean | auditoria$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>

  export type auditoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tabla?: boolean
    registroId?: boolean
    accion?: boolean
    detalles?: boolean
    usuarioId?: boolean
    creadoEn?: boolean
    usuario?: boolean | auditoria$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>

  export type auditoriaSelectScalar = {
    id?: boolean
    tabla?: boolean
    registroId?: boolean
    accion?: boolean
    detalles?: boolean
    usuarioId?: boolean
    creadoEn?: boolean
  }

  export type auditoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tabla" | "registroId" | "accion" | "detalles" | "usuarioId" | "creadoEn", ExtArgs["result"]["auditoria"]>
  export type auditoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | auditoria$usuarioArgs<ExtArgs>
  }
  export type auditoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | auditoria$usuarioArgs<ExtArgs>
  }
  export type auditoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | auditoria$usuarioArgs<ExtArgs>
  }

  export type $auditoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditoria"
    objects: {
      usuario: Prisma.$usuariosAdministradoresPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tabla: string
      registroId: string | null
      accion: $Enums.AccionAuditoria
      detalles: Prisma.JsonValue | null
      usuarioId: string | null
      creadoEn: Date
    }, ExtArgs["result"]["auditoria"]>
    composites: {}
  }

  type auditoriaGetPayload<S extends boolean | null | undefined | auditoriaDefaultArgs> = $Result.GetResult<Prisma.$auditoriaPayload, S>

  type auditoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auditoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditoriaCountAggregateInputType | true
    }

  export interface auditoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditoria'], meta: { name: 'auditoria' } }
    /**
     * Find zero or one Auditoria that matches the filter.
     * @param {auditoriaFindUniqueArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditoriaFindUniqueArgs>(args: SelectSubset<T, auditoriaFindUniqueArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auditoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auditoriaFindUniqueOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, auditoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditoriaFindFirstArgs>(args?: SelectSubset<T, auditoriaFindFirstArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, auditoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditorias
     * const auditorias = await prisma.auditoria.findMany()
     * 
     * // Get first 10 Auditorias
     * const auditorias = await prisma.auditoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auditoriaFindManyArgs>(args?: SelectSubset<T, auditoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auditoria.
     * @param {auditoriaCreateArgs} args - Arguments to create a Auditoria.
     * @example
     * // Create one Auditoria
     * const Auditoria = await prisma.auditoria.create({
     *   data: {
     *     // ... data to create a Auditoria
     *   }
     * })
     * 
     */
    create<T extends auditoriaCreateArgs>(args: SelectSubset<T, auditoriaCreateArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auditorias.
     * @param {auditoriaCreateManyArgs} args - Arguments to create many Auditorias.
     * @example
     * // Create many Auditorias
     * const auditoria = await prisma.auditoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditoriaCreateManyArgs>(args?: SelectSubset<T, auditoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auditorias and returns the data saved in the database.
     * @param {auditoriaCreateManyAndReturnArgs} args - Arguments to create many Auditorias.
     * @example
     * // Create many Auditorias
     * const auditoria = await prisma.auditoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auditorias and only return the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auditoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, auditoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auditoria.
     * @param {auditoriaDeleteArgs} args - Arguments to delete one Auditoria.
     * @example
     * // Delete one Auditoria
     * const Auditoria = await prisma.auditoria.delete({
     *   where: {
     *     // ... filter to delete one Auditoria
     *   }
     * })
     * 
     */
    delete<T extends auditoriaDeleteArgs>(args: SelectSubset<T, auditoriaDeleteArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auditoria.
     * @param {auditoriaUpdateArgs} args - Arguments to update one Auditoria.
     * @example
     * // Update one Auditoria
     * const auditoria = await prisma.auditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditoriaUpdateArgs>(args: SelectSubset<T, auditoriaUpdateArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auditorias.
     * @param {auditoriaDeleteManyArgs} args - Arguments to filter Auditorias to delete.
     * @example
     * // Delete a few Auditorias
     * const { count } = await prisma.auditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditoriaDeleteManyArgs>(args?: SelectSubset<T, auditoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditoriaUpdateManyArgs>(args: SelectSubset<T, auditoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias and returns the data updated in the database.
     * @param {auditoriaUpdateManyAndReturnArgs} args - Arguments to update many Auditorias.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auditorias and only return the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auditoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, auditoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auditoria.
     * @param {auditoriaUpsertArgs} args - Arguments to update or create a Auditoria.
     * @example
     * // Update or create a Auditoria
     * const auditoria = await prisma.auditoria.upsert({
     *   create: {
     *     // ... data to create a Auditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditoria we want to update
     *   }
     * })
     */
    upsert<T extends auditoriaUpsertArgs>(args: SelectSubset<T, auditoriaUpsertArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaCountArgs} args - Arguments to filter Auditorias to count.
     * @example
     * // Count the number of Auditorias
     * const count = await prisma.auditoria.count({
     *   where: {
     *     // ... the filter for the Auditorias we want to count
     *   }
     * })
    **/
    count<T extends auditoriaCountArgs>(
      args?: Subset<T, auditoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditoriaAggregateArgs>(args: Subset<T, AuditoriaAggregateArgs>): Prisma.PrismaPromise<GetAuditoriaAggregateType<T>>

    /**
     * Group by Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditoriaGroupByArgs['orderBy'] }
        : { orderBy?: auditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditoria model
   */
  readonly fields: auditoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends auditoria$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, auditoria$usuarioArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auditoria model
   */
  interface auditoriaFieldRefs {
    readonly id: FieldRef<"auditoria", 'String'>
    readonly tabla: FieldRef<"auditoria", 'String'>
    readonly registroId: FieldRef<"auditoria", 'String'>
    readonly accion: FieldRef<"auditoria", 'AccionAuditoria'>
    readonly detalles: FieldRef<"auditoria", 'Json'>
    readonly usuarioId: FieldRef<"auditoria", 'String'>
    readonly creadoEn: FieldRef<"auditoria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * auditoria findUnique
   */
  export type auditoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria findUniqueOrThrow
   */
  export type auditoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria findFirst
   */
  export type auditoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditorias.
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * auditoria findFirstOrThrow
   */
  export type auditoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditorias.
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * auditoria findMany
   */
  export type auditoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditorias to fetch.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditorias.
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * auditoria create
   */
  export type auditoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a auditoria.
     */
    data: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
  }

  /**
   * auditoria createMany
   */
  export type auditoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditorias.
     */
    data: auditoriaCreateManyInput | auditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auditoria createManyAndReturn
   */
  export type auditoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * The data used to create many auditorias.
     */
    data: auditoriaCreateManyInput | auditoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auditoria update
   */
  export type auditoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a auditoria.
     */
    data: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
    /**
     * Choose, which auditoria to update.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria updateMany
   */
  export type auditoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditorias.
     */
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyInput>
    /**
     * Filter which auditorias to update
     */
    where?: auditoriaWhereInput
    /**
     * Limit how many auditorias to update.
     */
    limit?: number
  }

  /**
   * auditoria updateManyAndReturn
   */
  export type auditoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * The data used to update auditorias.
     */
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyInput>
    /**
     * Filter which auditorias to update
     */
    where?: auditoriaWhereInput
    /**
     * Limit how many auditorias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auditoria upsert
   */
  export type auditoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the auditoria to update in case it exists.
     */
    where: auditoriaWhereUniqueInput
    /**
     * In case the auditoria found by the `where` argument doesn't exist, create a new auditoria with this data.
     */
    create: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
    /**
     * In case the auditoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
  }

  /**
   * auditoria delete
   */
  export type auditoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter which auditoria to delete.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria deleteMany
   */
  export type auditoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditorias to delete
     */
    where?: auditoriaWhereInput
    /**
     * Limit how many auditorias to delete.
     */
    limit?: number
  }

  /**
   * auditoria.usuario
   */
  export type auditoria$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    where?: usuariosAdministradoresWhereInput
  }

  /**
   * auditoria without action
   */
  export type auditoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
  }


  /**
   * Model categorias
   */

  export type AggregateCategorias = {
    _count: CategoriasCountAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  export type CategoriasMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CategoriasMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CategoriasCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type CategoriasMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CategoriasMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CategoriasCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type CategoriasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categorias to aggregate.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categorias
    **/
    _count?: true | CategoriasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriasMaxAggregateInputType
  }

  export type GetCategoriasAggregateType<T extends CategoriasAggregateArgs> = {
        [P in keyof T & keyof AggregateCategorias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategorias[P]>
      : GetScalarType<T[P], AggregateCategorias[P]>
  }




  export type categoriasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriasWhereInput
    orderBy?: categoriasOrderByWithAggregationInput | categoriasOrderByWithAggregationInput[]
    by: CategoriasScalarFieldEnum[] | CategoriasScalarFieldEnum
    having?: categoriasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriasCountAggregateInputType | true
    _min?: CategoriasMinAggregateInputType
    _max?: CategoriasMaxAggregateInputType
  }

  export type CategoriasGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    creadoEn: Date
    actualizadoEn: Date
    _count: CategoriasCountAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  type GetCategoriasGroupByPayload<T extends categoriasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
        }
      >
    >


  export type categoriasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    categoriasCursos?: boolean | categorias$categoriasCursosArgs<ExtArgs>
    _count?: boolean | CategoriasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categorias"]>

  export type categoriasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["categorias"]>

  export type categoriasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["categorias"]>

  export type categoriasSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type categoriasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["categorias"]>
  export type categoriasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoriasCursos?: boolean | categorias$categoriasCursosArgs<ExtArgs>
    _count?: boolean | CategoriasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type categoriasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoriasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categorias"
    objects: {
      categoriasCursos: Prisma.$categoriasCursosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["categorias"]>
    composites: {}
  }

  type categoriasGetPayload<S extends boolean | null | undefined | categoriasDefaultArgs> = $Result.GetResult<Prisma.$categoriasPayload, S>

  type categoriasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriasCountAggregateInputType | true
    }

  export interface categoriasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categorias'], meta: { name: 'categorias' } }
    /**
     * Find zero or one Categorias that matches the filter.
     * @param {categoriasFindUniqueArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriasFindUniqueArgs>(args: SelectSubset<T, categoriasFindUniqueArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categorias that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriasFindUniqueOrThrowArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriasFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindFirstArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriasFindFirstArgs>(args?: SelectSubset<T, categoriasFindFirstArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categorias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindFirstOrThrowArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriasFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriasFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categorias.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categorias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriasWithIdOnly = await prisma.categorias.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriasFindManyArgs>(args?: SelectSubset<T, categoriasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categorias.
     * @param {categoriasCreateArgs} args - Arguments to create a Categorias.
     * @example
     * // Create one Categorias
     * const Categorias = await prisma.categorias.create({
     *   data: {
     *     // ... data to create a Categorias
     *   }
     * })
     * 
     */
    create<T extends categoriasCreateArgs>(args: SelectSubset<T, categoriasCreateArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categorias.
     * @param {categoriasCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categorias = await prisma.categorias.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriasCreateManyArgs>(args?: SelectSubset<T, categoriasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categorias and returns the data saved in the database.
     * @param {categoriasCreateManyAndReturnArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categorias = await prisma.categorias.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categorias and only return the `id`
     * const categoriasWithIdOnly = await prisma.categorias.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriasCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categorias.
     * @param {categoriasDeleteArgs} args - Arguments to delete one Categorias.
     * @example
     * // Delete one Categorias
     * const Categorias = await prisma.categorias.delete({
     *   where: {
     *     // ... filter to delete one Categorias
     *   }
     * })
     * 
     */
    delete<T extends categoriasDeleteArgs>(args: SelectSubset<T, categoriasDeleteArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categorias.
     * @param {categoriasUpdateArgs} args - Arguments to update one Categorias.
     * @example
     * // Update one Categorias
     * const categorias = await prisma.categorias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriasUpdateArgs>(args: SelectSubset<T, categoriasUpdateArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categorias.
     * @param {categoriasDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categorias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriasDeleteManyArgs>(args?: SelectSubset<T, categoriasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categorias = await prisma.categorias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriasUpdateManyArgs>(args: SelectSubset<T, categoriasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias and returns the data updated in the database.
     * @param {categoriasUpdateManyAndReturnArgs} args - Arguments to update many Categorias.
     * @example
     * // Update many Categorias
     * const categorias = await prisma.categorias.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categorias and only return the `id`
     * const categoriasWithIdOnly = await prisma.categorias.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriasUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categorias.
     * @param {categoriasUpsertArgs} args - Arguments to update or create a Categorias.
     * @example
     * // Update or create a Categorias
     * const categorias = await prisma.categorias.upsert({
     *   create: {
     *     // ... data to create a Categorias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categorias we want to update
     *   }
     * })
     */
    upsert<T extends categoriasUpsertArgs>(args: SelectSubset<T, categoriasUpsertArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categorias.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends categoriasCountArgs>(
      args?: Subset<T, categoriasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriasAggregateArgs>(args: Subset<T, CategoriasAggregateArgs>): Prisma.PrismaPromise<GetCategoriasAggregateType<T>>

    /**
     * Group by Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriasGroupByArgs['orderBy'] }
        : { orderBy?: categoriasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categorias model
   */
  readonly fields: categoriasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categorias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categoriasCursos<T extends categorias$categoriasCursosArgs<ExtArgs> = {}>(args?: Subset<T, categorias$categoriasCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categorias model
   */
  interface categoriasFieldRefs {
    readonly id: FieldRef<"categorias", 'String'>
    readonly nombre: FieldRef<"categorias", 'String'>
    readonly descripcion: FieldRef<"categorias", 'String'>
    readonly creadoEn: FieldRef<"categorias", 'DateTime'>
    readonly actualizadoEn: FieldRef<"categorias", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * categorias findUnique
   */
  export type categoriasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias findUniqueOrThrow
   */
  export type categoriasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias findFirst
   */
  export type categoriasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriasScalarFieldEnum | CategoriasScalarFieldEnum[]
  }

  /**
   * categorias findFirstOrThrow
   */
  export type categoriasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriasScalarFieldEnum | CategoriasScalarFieldEnum[]
  }

  /**
   * categorias findMany
   */
  export type categoriasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    distinct?: CategoriasScalarFieldEnum | CategoriasScalarFieldEnum[]
  }

  /**
   * categorias create
   */
  export type categoriasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * The data needed to create a categorias.
     */
    data: XOR<categoriasCreateInput, categoriasUncheckedCreateInput>
  }

  /**
   * categorias createMany
   */
  export type categoriasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categorias.
     */
    data: categoriasCreateManyInput | categoriasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categorias createManyAndReturn
   */
  export type categoriasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * The data used to create many categorias.
     */
    data: categoriasCreateManyInput | categoriasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categorias update
   */
  export type categoriasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * The data needed to update a categorias.
     */
    data: XOR<categoriasUpdateInput, categoriasUncheckedUpdateInput>
    /**
     * Choose, which categorias to update.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias updateMany
   */
  export type categoriasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriasUpdateManyMutationInput, categoriasUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriasWhereInput
    /**
     * Limit how many categorias to update.
     */
    limit?: number
  }

  /**
   * categorias updateManyAndReturn
   */
  export type categoriasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriasUpdateManyMutationInput, categoriasUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriasWhereInput
    /**
     * Limit how many categorias to update.
     */
    limit?: number
  }

  /**
   * categorias upsert
   */
  export type categoriasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * The filter to search for the categorias to update in case it exists.
     */
    where: categoriasWhereUniqueInput
    /**
     * In case the categorias found by the `where` argument doesn't exist, create a new categorias with this data.
     */
    create: XOR<categoriasCreateInput, categoriasUncheckedCreateInput>
    /**
     * In case the categorias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriasUpdateInput, categoriasUncheckedUpdateInput>
  }

  /**
   * categorias delete
   */
  export type categoriasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter which categorias to delete.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias deleteMany
   */
  export type categoriasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categorias to delete
     */
    where?: categoriasWhereInput
    /**
     * Limit how many categorias to delete.
     */
    limit?: number
  }

  /**
   * categorias.categoriasCursos
   */
  export type categorias$categoriasCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    where?: categoriasCursosWhereInput
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    cursor?: categoriasCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * categorias without action
   */
  export type categoriasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
  }


  /**
   * Model usuariosEstudiantes
   */

  export type AggregateUsuariosEstudiantes = {
    _count: UsuariosEstudiantesCountAggregateOutputType | null
    _min: UsuariosEstudiantesMinAggregateOutputType | null
    _max: UsuariosEstudiantesMaxAggregateOutputType | null
  }

  export type UsuariosEstudiantesMinAggregateOutputType = {
    id: string | null
    correo: string | null
    contrasena: string | null
    usuario: string | null
    estado: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    avatar: string | null
    estudianteId: string | null
    registrado: boolean | null
  }

  export type UsuariosEstudiantesMaxAggregateOutputType = {
    id: string | null
    correo: string | null
    contrasena: string | null
    usuario: string | null
    estado: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    avatar: string | null
    estudianteId: string | null
    registrado: boolean | null
  }

  export type UsuariosEstudiantesCountAggregateOutputType = {
    id: number
    correo: number
    contrasena: number
    usuario: number
    estado: number
    creadoEn: number
    actualizadoEn: number
    avatar: number
    estudianteId: number
    registrado: number
    _all: number
  }


  export type UsuariosEstudiantesMinAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    usuario?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    avatar?: true
    estudianteId?: true
    registrado?: true
  }

  export type UsuariosEstudiantesMaxAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    usuario?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    avatar?: true
    estudianteId?: true
    registrado?: true
  }

  export type UsuariosEstudiantesCountAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    usuario?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    avatar?: true
    estudianteId?: true
    registrado?: true
    _all?: true
  }

  export type UsuariosEstudiantesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuariosEstudiantes to aggregate.
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosEstudiantes to fetch.
     */
    orderBy?: usuariosEstudiantesOrderByWithRelationInput | usuariosEstudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuariosEstudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuariosEstudiantes
    **/
    _count?: true | UsuariosEstudiantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosEstudiantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosEstudiantesMaxAggregateInputType
  }

  export type GetUsuariosEstudiantesAggregateType<T extends UsuariosEstudiantesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuariosEstudiantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuariosEstudiantes[P]>
      : GetScalarType<T[P], AggregateUsuariosEstudiantes[P]>
  }




  export type usuariosEstudiantesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuariosEstudiantesWhereInput
    orderBy?: usuariosEstudiantesOrderByWithAggregationInput | usuariosEstudiantesOrderByWithAggregationInput[]
    by: UsuariosEstudiantesScalarFieldEnum[] | UsuariosEstudiantesScalarFieldEnum
    having?: usuariosEstudiantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosEstudiantesCountAggregateInputType | true
    _min?: UsuariosEstudiantesMinAggregateInputType
    _max?: UsuariosEstudiantesMaxAggregateInputType
  }

  export type UsuariosEstudiantesGroupByOutputType = {
    id: string
    correo: string
    contrasena: string
    usuario: string
    estado: boolean
    creadoEn: Date
    actualizadoEn: Date
    avatar: string | null
    estudianteId: string | null
    registrado: boolean
    _count: UsuariosEstudiantesCountAggregateOutputType | null
    _min: UsuariosEstudiantesMinAggregateOutputType | null
    _max: UsuariosEstudiantesMaxAggregateOutputType | null
  }

  type GetUsuariosEstudiantesGroupByPayload<T extends usuariosEstudiantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosEstudiantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosEstudiantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosEstudiantesGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosEstudiantesGroupByOutputType[P]>
        }
      >
    >


  export type usuariosEstudiantesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    usuario?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    avatar?: boolean
    estudianteId?: boolean
    registrado?: boolean
    estudiante?: boolean | usuariosEstudiantes$estudianteArgs<ExtArgs>
    reviews?: boolean | usuariosEstudiantes$reviewsArgs<ExtArgs>
    compras?: boolean | usuariosEstudiantes$comprasArgs<ExtArgs>
    _count?: boolean | UsuariosEstudiantesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosEstudiantes"]>

  export type usuariosEstudiantesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    usuario?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    avatar?: boolean
    estudianteId?: boolean
    registrado?: boolean
    estudiante?: boolean | usuariosEstudiantes$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosEstudiantes"]>

  export type usuariosEstudiantesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    usuario?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    avatar?: boolean
    estudianteId?: boolean
    registrado?: boolean
    estudiante?: boolean | usuariosEstudiantes$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosEstudiantes"]>

  export type usuariosEstudiantesSelectScalar = {
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    usuario?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    avatar?: boolean
    estudianteId?: boolean
    registrado?: boolean
  }

  export type usuariosEstudiantesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "correo" | "contrasena" | "usuario" | "estado" | "creadoEn" | "actualizadoEn" | "avatar" | "estudianteId" | "registrado", ExtArgs["result"]["usuariosEstudiantes"]>
  export type usuariosEstudiantesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | usuariosEstudiantes$estudianteArgs<ExtArgs>
    reviews?: boolean | usuariosEstudiantes$reviewsArgs<ExtArgs>
    compras?: boolean | usuariosEstudiantes$comprasArgs<ExtArgs>
    _count?: boolean | UsuariosEstudiantesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usuariosEstudiantesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | usuariosEstudiantes$estudianteArgs<ExtArgs>
  }
  export type usuariosEstudiantesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | usuariosEstudiantes$estudianteArgs<ExtArgs>
  }

  export type $usuariosEstudiantesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuariosEstudiantes"
    objects: {
      estudiante: Prisma.$estudiantesPayload<ExtArgs> | null
      reviews: Prisma.$reviewsCursosPayload<ExtArgs>[]
      compras: Prisma.$comprasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      correo: string
      contrasena: string
      usuario: string
      estado: boolean
      creadoEn: Date
      actualizadoEn: Date
      avatar: string | null
      estudianteId: string | null
      registrado: boolean
    }, ExtArgs["result"]["usuariosEstudiantes"]>
    composites: {}
  }

  type usuariosEstudiantesGetPayload<S extends boolean | null | undefined | usuariosEstudiantesDefaultArgs> = $Result.GetResult<Prisma.$usuariosEstudiantesPayload, S>

  type usuariosEstudiantesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuariosEstudiantesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosEstudiantesCountAggregateInputType | true
    }

  export interface usuariosEstudiantesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuariosEstudiantes'], meta: { name: 'usuariosEstudiantes' } }
    /**
     * Find zero or one UsuariosEstudiantes that matches the filter.
     * @param {usuariosEstudiantesFindUniqueArgs} args - Arguments to find a UsuariosEstudiantes
     * @example
     * // Get one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuariosEstudiantesFindUniqueArgs>(args: SelectSubset<T, usuariosEstudiantesFindUniqueArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsuariosEstudiantes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuariosEstudiantesFindUniqueOrThrowArgs} args - Arguments to find a UsuariosEstudiantes
     * @example
     * // Get one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuariosEstudiantesFindUniqueOrThrowArgs>(args: SelectSubset<T, usuariosEstudiantesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosEstudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesFindFirstArgs} args - Arguments to find a UsuariosEstudiantes
     * @example
     * // Get one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuariosEstudiantesFindFirstArgs>(args?: SelectSubset<T, usuariosEstudiantesFindFirstArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosEstudiantes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesFindFirstOrThrowArgs} args - Arguments to find a UsuariosEstudiantes
     * @example
     * // Get one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuariosEstudiantesFindFirstOrThrowArgs>(args?: SelectSubset<T, usuariosEstudiantesFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsuariosEstudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findMany()
     * 
     * // Get first 10 UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosEstudiantesWithIdOnly = await prisma.usuariosEstudiantes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuariosEstudiantesFindManyArgs>(args?: SelectSubset<T, usuariosEstudiantesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsuariosEstudiantes.
     * @param {usuariosEstudiantesCreateArgs} args - Arguments to create a UsuariosEstudiantes.
     * @example
     * // Create one UsuariosEstudiantes
     * const UsuariosEstudiantes = await prisma.usuariosEstudiantes.create({
     *   data: {
     *     // ... data to create a UsuariosEstudiantes
     *   }
     * })
     * 
     */
    create<T extends usuariosEstudiantesCreateArgs>(args: SelectSubset<T, usuariosEstudiantesCreateArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsuariosEstudiantes.
     * @param {usuariosEstudiantesCreateManyArgs} args - Arguments to create many UsuariosEstudiantes.
     * @example
     * // Create many UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuariosEstudiantesCreateManyArgs>(args?: SelectSubset<T, usuariosEstudiantesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuariosEstudiantes and returns the data saved in the database.
     * @param {usuariosEstudiantesCreateManyAndReturnArgs} args - Arguments to create many UsuariosEstudiantes.
     * @example
     * // Create many UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuariosEstudiantes and only return the `id`
     * const usuariosEstudiantesWithIdOnly = await prisma.usuariosEstudiantes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuariosEstudiantesCreateManyAndReturnArgs>(args?: SelectSubset<T, usuariosEstudiantesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsuariosEstudiantes.
     * @param {usuariosEstudiantesDeleteArgs} args - Arguments to delete one UsuariosEstudiantes.
     * @example
     * // Delete one UsuariosEstudiantes
     * const UsuariosEstudiantes = await prisma.usuariosEstudiantes.delete({
     *   where: {
     *     // ... filter to delete one UsuariosEstudiantes
     *   }
     * })
     * 
     */
    delete<T extends usuariosEstudiantesDeleteArgs>(args: SelectSubset<T, usuariosEstudiantesDeleteArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsuariosEstudiantes.
     * @param {usuariosEstudiantesUpdateArgs} args - Arguments to update one UsuariosEstudiantes.
     * @example
     * // Update one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuariosEstudiantesUpdateArgs>(args: SelectSubset<T, usuariosEstudiantesUpdateArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsuariosEstudiantes.
     * @param {usuariosEstudiantesDeleteManyArgs} args - Arguments to filter UsuariosEstudiantes to delete.
     * @example
     * // Delete a few UsuariosEstudiantes
     * const { count } = await prisma.usuariosEstudiantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuariosEstudiantesDeleteManyArgs>(args?: SelectSubset<T, usuariosEstudiantesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuariosEstudiantesUpdateManyArgs>(args: SelectSubset<T, usuariosEstudiantesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosEstudiantes and returns the data updated in the database.
     * @param {usuariosEstudiantesUpdateManyAndReturnArgs} args - Arguments to update many UsuariosEstudiantes.
     * @example
     * // Update many UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsuariosEstudiantes and only return the `id`
     * const usuariosEstudiantesWithIdOnly = await prisma.usuariosEstudiantes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usuariosEstudiantesUpdateManyAndReturnArgs>(args: SelectSubset<T, usuariosEstudiantesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsuariosEstudiantes.
     * @param {usuariosEstudiantesUpsertArgs} args - Arguments to update or create a UsuariosEstudiantes.
     * @example
     * // Update or create a UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.upsert({
     *   create: {
     *     // ... data to create a UsuariosEstudiantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuariosEstudiantes we want to update
     *   }
     * })
     */
    upsert<T extends usuariosEstudiantesUpsertArgs>(args: SelectSubset<T, usuariosEstudiantesUpsertArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsuariosEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesCountArgs} args - Arguments to filter UsuariosEstudiantes to count.
     * @example
     * // Count the number of UsuariosEstudiantes
     * const count = await prisma.usuariosEstudiantes.count({
     *   where: {
     *     // ... the filter for the UsuariosEstudiantes we want to count
     *   }
     * })
    **/
    count<T extends usuariosEstudiantesCountArgs>(
      args?: Subset<T, usuariosEstudiantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosEstudiantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuariosEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosEstudiantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosEstudiantesAggregateArgs>(args: Subset<T, UsuariosEstudiantesAggregateArgs>): Prisma.PrismaPromise<GetUsuariosEstudiantesAggregateType<T>>

    /**
     * Group by UsuariosEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuariosEstudiantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuariosEstudiantesGroupByArgs['orderBy'] }
        : { orderBy?: usuariosEstudiantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuariosEstudiantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosEstudiantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuariosEstudiantes model
   */
  readonly fields: usuariosEstudiantesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuariosEstudiantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuariosEstudiantesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends usuariosEstudiantes$estudianteArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$estudianteArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviews<T extends usuariosEstudiantes$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    compras<T extends usuariosEstudiantes$comprasArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$comprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuariosEstudiantes model
   */
  interface usuariosEstudiantesFieldRefs {
    readonly id: FieldRef<"usuariosEstudiantes", 'String'>
    readonly correo: FieldRef<"usuariosEstudiantes", 'String'>
    readonly contrasena: FieldRef<"usuariosEstudiantes", 'String'>
    readonly usuario: FieldRef<"usuariosEstudiantes", 'String'>
    readonly estado: FieldRef<"usuariosEstudiantes", 'Boolean'>
    readonly creadoEn: FieldRef<"usuariosEstudiantes", 'DateTime'>
    readonly actualizadoEn: FieldRef<"usuariosEstudiantes", 'DateTime'>
    readonly avatar: FieldRef<"usuariosEstudiantes", 'String'>
    readonly estudianteId: FieldRef<"usuariosEstudiantes", 'String'>
    readonly registrado: FieldRef<"usuariosEstudiantes", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * usuariosEstudiantes findUnique
   */
  export type usuariosEstudiantesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where: usuariosEstudiantesWhereUniqueInput
  }

  /**
   * usuariosEstudiantes findUniqueOrThrow
   */
  export type usuariosEstudiantesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where: usuariosEstudiantesWhereUniqueInput
  }

  /**
   * usuariosEstudiantes findFirst
   */
  export type usuariosEstudiantesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosEstudiantes to fetch.
     */
    orderBy?: usuariosEstudiantesOrderByWithRelationInput | usuariosEstudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuariosEstudiantes.
     */
    cursor?: usuariosEstudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuariosEstudiantes.
     */
    distinct?: UsuariosEstudiantesScalarFieldEnum | UsuariosEstudiantesScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes findFirstOrThrow
   */
  export type usuariosEstudiantesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosEstudiantes to fetch.
     */
    orderBy?: usuariosEstudiantesOrderByWithRelationInput | usuariosEstudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuariosEstudiantes.
     */
    cursor?: usuariosEstudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuariosEstudiantes.
     */
    distinct?: UsuariosEstudiantesScalarFieldEnum | UsuariosEstudiantesScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes findMany
   */
  export type usuariosEstudiantesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosEstudiantes to fetch.
     */
    orderBy?: usuariosEstudiantesOrderByWithRelationInput | usuariosEstudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuariosEstudiantes.
     */
    cursor?: usuariosEstudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosEstudiantes.
     */
    skip?: number
    distinct?: UsuariosEstudiantesScalarFieldEnum | UsuariosEstudiantesScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes create
   */
  export type usuariosEstudiantesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * The data needed to create a usuariosEstudiantes.
     */
    data: XOR<usuariosEstudiantesCreateInput, usuariosEstudiantesUncheckedCreateInput>
  }

  /**
   * usuariosEstudiantes createMany
   */
  export type usuariosEstudiantesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuariosEstudiantes.
     */
    data: usuariosEstudiantesCreateManyInput | usuariosEstudiantesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuariosEstudiantes createManyAndReturn
   */
  export type usuariosEstudiantesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * The data used to create many usuariosEstudiantes.
     */
    data: usuariosEstudiantesCreateManyInput | usuariosEstudiantesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuariosEstudiantes update
   */
  export type usuariosEstudiantesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * The data needed to update a usuariosEstudiantes.
     */
    data: XOR<usuariosEstudiantesUpdateInput, usuariosEstudiantesUncheckedUpdateInput>
    /**
     * Choose, which usuariosEstudiantes to update.
     */
    where: usuariosEstudiantesWhereUniqueInput
  }

  /**
   * usuariosEstudiantes updateMany
   */
  export type usuariosEstudiantesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuariosEstudiantes.
     */
    data: XOR<usuariosEstudiantesUpdateManyMutationInput, usuariosEstudiantesUncheckedUpdateManyInput>
    /**
     * Filter which usuariosEstudiantes to update
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * Limit how many usuariosEstudiantes to update.
     */
    limit?: number
  }

  /**
   * usuariosEstudiantes updateManyAndReturn
   */
  export type usuariosEstudiantesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * The data used to update usuariosEstudiantes.
     */
    data: XOR<usuariosEstudiantesUpdateManyMutationInput, usuariosEstudiantesUncheckedUpdateManyInput>
    /**
     * Filter which usuariosEstudiantes to update
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * Limit how many usuariosEstudiantes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuariosEstudiantes upsert
   */
  export type usuariosEstudiantesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * The filter to search for the usuariosEstudiantes to update in case it exists.
     */
    where: usuariosEstudiantesWhereUniqueInput
    /**
     * In case the usuariosEstudiantes found by the `where` argument doesn't exist, create a new usuariosEstudiantes with this data.
     */
    create: XOR<usuariosEstudiantesCreateInput, usuariosEstudiantesUncheckedCreateInput>
    /**
     * In case the usuariosEstudiantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuariosEstudiantesUpdateInput, usuariosEstudiantesUncheckedUpdateInput>
  }

  /**
   * usuariosEstudiantes delete
   */
  export type usuariosEstudiantesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter which usuariosEstudiantes to delete.
     */
    where: usuariosEstudiantesWhereUniqueInput
  }

  /**
   * usuariosEstudiantes deleteMany
   */
  export type usuariosEstudiantesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuariosEstudiantes to delete
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * Limit how many usuariosEstudiantes to delete.
     */
    limit?: number
  }

  /**
   * usuariosEstudiantes.estudiante
   */
  export type usuariosEstudiantes$estudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    where?: estudiantesWhereInput
  }

  /**
   * usuariosEstudiantes.reviews
   */
  export type usuariosEstudiantes$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    where?: reviewsCursosWhereInput
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    cursor?: reviewsCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes.compras
   */
  export type usuariosEstudiantes$comprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    where?: comprasWhereInput
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    cursor?: comprasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes without action
   */
  export type usuariosEstudiantesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
  }


  /**
   * Model estudiantes
   */

  export type AggregateEstudiantes = {
    _count: EstudiantesCountAggregateOutputType | null
    _min: EstudiantesMinAggregateOutputType | null
    _max: EstudiantesMaxAggregateOutputType | null
  }

  export type EstudiantesMinAggregateOutputType = {
    id: string | null
    apellido: string | null
    celular: string | null
    pais: string | null
    genero: $Enums.TipoGenero | null
    fechaNacimiento: Date | null
    nombre: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type EstudiantesMaxAggregateOutputType = {
    id: string | null
    apellido: string | null
    celular: string | null
    pais: string | null
    genero: $Enums.TipoGenero | null
    fechaNacimiento: Date | null
    nombre: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type EstudiantesCountAggregateOutputType = {
    id: number
    apellido: number
    celular: number
    pais: number
    genero: number
    fechaNacimiento: number
    nombre: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type EstudiantesMinAggregateInputType = {
    id?: true
    apellido?: true
    celular?: true
    pais?: true
    genero?: true
    fechaNacimiento?: true
    nombre?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type EstudiantesMaxAggregateInputType = {
    id?: true
    apellido?: true
    celular?: true
    pais?: true
    genero?: true
    fechaNacimiento?: true
    nombre?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type EstudiantesCountAggregateInputType = {
    id?: true
    apellido?: true
    celular?: true
    pais?: true
    genero?: true
    fechaNacimiento?: true
    nombre?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type EstudiantesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estudiantes to aggregate.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: estudiantesOrderByWithRelationInput | estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estudiantes
    **/
    _count?: true | EstudiantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudiantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudiantesMaxAggregateInputType
  }

  export type GetEstudiantesAggregateType<T extends EstudiantesAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudiantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudiantes[P]>
      : GetScalarType<T[P], AggregateEstudiantes[P]>
  }




  export type estudiantesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estudiantesWhereInput
    orderBy?: estudiantesOrderByWithAggregationInput | estudiantesOrderByWithAggregationInput[]
    by: EstudiantesScalarFieldEnum[] | EstudiantesScalarFieldEnum
    having?: estudiantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudiantesCountAggregateInputType | true
    _min?: EstudiantesMinAggregateInputType
    _max?: EstudiantesMaxAggregateInputType
  }

  export type EstudiantesGroupByOutputType = {
    id: string
    apellido: string | null
    celular: string | null
    pais: string | null
    genero: $Enums.TipoGenero | null
    fechaNacimiento: Date | null
    nombre: string
    creadoEn: Date
    actualizadoEn: Date
    _count: EstudiantesCountAggregateOutputType | null
    _min: EstudiantesMinAggregateOutputType | null
    _max: EstudiantesMaxAggregateOutputType | null
  }

  type GetEstudiantesGroupByPayload<T extends estudiantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudiantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudiantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudiantesGroupByOutputType[P]>
            : GetScalarType<T[P], EstudiantesGroupByOutputType[P]>
        }
      >
    >


  export type estudiantesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apellido?: boolean
    celular?: boolean
    pais?: boolean
    genero?: boolean
    fechaNacimiento?: boolean
    nombre?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuario?: boolean | estudiantes$usuarioArgs<ExtArgs>
    calificaciones?: boolean | estudiantes$calificacionesArgs<ExtArgs>
    certificados?: boolean | estudiantes$certificadosArgs<ExtArgs>
    inscripciones?: boolean | estudiantes$inscripcionesArgs<ExtArgs>
    _count?: boolean | EstudiantesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiantes"]>

  export type estudiantesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apellido?: boolean
    celular?: boolean
    pais?: boolean
    genero?: boolean
    fechaNacimiento?: boolean
    nombre?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["estudiantes"]>

  export type estudiantesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apellido?: boolean
    celular?: boolean
    pais?: boolean
    genero?: boolean
    fechaNacimiento?: boolean
    nombre?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["estudiantes"]>

  export type estudiantesSelectScalar = {
    id?: boolean
    apellido?: boolean
    celular?: boolean
    pais?: boolean
    genero?: boolean
    fechaNacimiento?: boolean
    nombre?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type estudiantesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apellido" | "celular" | "pais" | "genero" | "fechaNacimiento" | "nombre" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["estudiantes"]>
  export type estudiantesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | estudiantes$usuarioArgs<ExtArgs>
    calificaciones?: boolean | estudiantes$calificacionesArgs<ExtArgs>
    certificados?: boolean | estudiantes$certificadosArgs<ExtArgs>
    inscripciones?: boolean | estudiantes$inscripcionesArgs<ExtArgs>
    _count?: boolean | EstudiantesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type estudiantesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type estudiantesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $estudiantesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estudiantes"
    objects: {
      usuario: Prisma.$usuariosEstudiantesPayload<ExtArgs> | null
      calificaciones: Prisma.$calificacionesPayload<ExtArgs>[]
      certificados: Prisma.$certificadosPayload<ExtArgs>[]
      inscripciones: Prisma.$inscripcionesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apellido: string | null
      celular: string | null
      pais: string | null
      genero: $Enums.TipoGenero | null
      fechaNacimiento: Date | null
      nombre: string
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["estudiantes"]>
    composites: {}
  }

  type estudiantesGetPayload<S extends boolean | null | undefined | estudiantesDefaultArgs> = $Result.GetResult<Prisma.$estudiantesPayload, S>

  type estudiantesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estudiantesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstudiantesCountAggregateInputType | true
    }

  export interface estudiantesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estudiantes'], meta: { name: 'estudiantes' } }
    /**
     * Find zero or one Estudiantes that matches the filter.
     * @param {estudiantesFindUniqueArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estudiantesFindUniqueArgs>(args: SelectSubset<T, estudiantesFindUniqueArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estudiantes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estudiantesFindUniqueOrThrowArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estudiantesFindUniqueOrThrowArgs>(args: SelectSubset<T, estudiantesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesFindFirstArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estudiantesFindFirstArgs>(args?: SelectSubset<T, estudiantesFindFirstArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiantes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesFindFirstOrThrowArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estudiantesFindFirstOrThrowArgs>(args?: SelectSubset<T, estudiantesFindFirstOrThrowArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estudiantes
     * const estudiantes = await prisma.estudiantes.findMany()
     * 
     * // Get first 10 Estudiantes
     * const estudiantes = await prisma.estudiantes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estudiantesWithIdOnly = await prisma.estudiantes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estudiantesFindManyArgs>(args?: SelectSubset<T, estudiantesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estudiantes.
     * @param {estudiantesCreateArgs} args - Arguments to create a Estudiantes.
     * @example
     * // Create one Estudiantes
     * const Estudiantes = await prisma.estudiantes.create({
     *   data: {
     *     // ... data to create a Estudiantes
     *   }
     * })
     * 
     */
    create<T extends estudiantesCreateArgs>(args: SelectSubset<T, estudiantesCreateArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estudiantes.
     * @param {estudiantesCreateManyArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiantes = await prisma.estudiantes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estudiantesCreateManyArgs>(args?: SelectSubset<T, estudiantesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estudiantes and returns the data saved in the database.
     * @param {estudiantesCreateManyAndReturnArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiantes = await prisma.estudiantes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estudiantes and only return the `id`
     * const estudiantesWithIdOnly = await prisma.estudiantes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends estudiantesCreateManyAndReturnArgs>(args?: SelectSubset<T, estudiantesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estudiantes.
     * @param {estudiantesDeleteArgs} args - Arguments to delete one Estudiantes.
     * @example
     * // Delete one Estudiantes
     * const Estudiantes = await prisma.estudiantes.delete({
     *   where: {
     *     // ... filter to delete one Estudiantes
     *   }
     * })
     * 
     */
    delete<T extends estudiantesDeleteArgs>(args: SelectSubset<T, estudiantesDeleteArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estudiantes.
     * @param {estudiantesUpdateArgs} args - Arguments to update one Estudiantes.
     * @example
     * // Update one Estudiantes
     * const estudiantes = await prisma.estudiantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estudiantesUpdateArgs>(args: SelectSubset<T, estudiantesUpdateArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estudiantes.
     * @param {estudiantesDeleteManyArgs} args - Arguments to filter Estudiantes to delete.
     * @example
     * // Delete a few Estudiantes
     * const { count } = await prisma.estudiantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estudiantesDeleteManyArgs>(args?: SelectSubset<T, estudiantesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estudiantes
     * const estudiantes = await prisma.estudiantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estudiantesUpdateManyArgs>(args: SelectSubset<T, estudiantesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes and returns the data updated in the database.
     * @param {estudiantesUpdateManyAndReturnArgs} args - Arguments to update many Estudiantes.
     * @example
     * // Update many Estudiantes
     * const estudiantes = await prisma.estudiantes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estudiantes and only return the `id`
     * const estudiantesWithIdOnly = await prisma.estudiantes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends estudiantesUpdateManyAndReturnArgs>(args: SelectSubset<T, estudiantesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estudiantes.
     * @param {estudiantesUpsertArgs} args - Arguments to update or create a Estudiantes.
     * @example
     * // Update or create a Estudiantes
     * const estudiantes = await prisma.estudiantes.upsert({
     *   create: {
     *     // ... data to create a Estudiantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estudiantes we want to update
     *   }
     * })
     */
    upsert<T extends estudiantesUpsertArgs>(args: SelectSubset<T, estudiantesUpsertArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesCountArgs} args - Arguments to filter Estudiantes to count.
     * @example
     * // Count the number of Estudiantes
     * const count = await prisma.estudiantes.count({
     *   where: {
     *     // ... the filter for the Estudiantes we want to count
     *   }
     * })
    **/
    count<T extends estudiantesCountArgs>(
      args?: Subset<T, estudiantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudiantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudiantesAggregateArgs>(args: Subset<T, EstudiantesAggregateArgs>): Prisma.PrismaPromise<GetEstudiantesAggregateType<T>>

    /**
     * Group by Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estudiantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estudiantesGroupByArgs['orderBy'] }
        : { orderBy?: estudiantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estudiantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudiantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estudiantes model
   */
  readonly fields: estudiantesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estudiantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estudiantesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends estudiantes$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, estudiantes$usuarioArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    calificaciones<T extends estudiantes$calificacionesArgs<ExtArgs> = {}>(args?: Subset<T, estudiantes$calificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificados<T extends estudiantes$certificadosArgs<ExtArgs> = {}>(args?: Subset<T, estudiantes$certificadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inscripciones<T extends estudiantes$inscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, estudiantes$inscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estudiantes model
   */
  interface estudiantesFieldRefs {
    readonly id: FieldRef<"estudiantes", 'String'>
    readonly apellido: FieldRef<"estudiantes", 'String'>
    readonly celular: FieldRef<"estudiantes", 'String'>
    readonly pais: FieldRef<"estudiantes", 'String'>
    readonly genero: FieldRef<"estudiantes", 'TipoGenero'>
    readonly fechaNacimiento: FieldRef<"estudiantes", 'DateTime'>
    readonly nombre: FieldRef<"estudiantes", 'String'>
    readonly creadoEn: FieldRef<"estudiantes", 'DateTime'>
    readonly actualizadoEn: FieldRef<"estudiantes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * estudiantes findUnique
   */
  export type estudiantesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where: estudiantesWhereUniqueInput
  }

  /**
   * estudiantes findUniqueOrThrow
   */
  export type estudiantesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where: estudiantesWhereUniqueInput
  }

  /**
   * estudiantes findFirst
   */
  export type estudiantesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: estudiantesOrderByWithRelationInput | estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estudiantes.
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estudiantes.
     */
    distinct?: EstudiantesScalarFieldEnum | EstudiantesScalarFieldEnum[]
  }

  /**
   * estudiantes findFirstOrThrow
   */
  export type estudiantesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: estudiantesOrderByWithRelationInput | estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estudiantes.
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estudiantes.
     */
    distinct?: EstudiantesScalarFieldEnum | EstudiantesScalarFieldEnum[]
  }

  /**
   * estudiantes findMany
   */
  export type estudiantesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: estudiantesOrderByWithRelationInput | estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estudiantes.
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    distinct?: EstudiantesScalarFieldEnum | EstudiantesScalarFieldEnum[]
  }

  /**
   * estudiantes create
   */
  export type estudiantesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * The data needed to create a estudiantes.
     */
    data: XOR<estudiantesCreateInput, estudiantesUncheckedCreateInput>
  }

  /**
   * estudiantes createMany
   */
  export type estudiantesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estudiantes.
     */
    data: estudiantesCreateManyInput | estudiantesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estudiantes createManyAndReturn
   */
  export type estudiantesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * The data used to create many estudiantes.
     */
    data: estudiantesCreateManyInput | estudiantesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estudiantes update
   */
  export type estudiantesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * The data needed to update a estudiantes.
     */
    data: XOR<estudiantesUpdateInput, estudiantesUncheckedUpdateInput>
    /**
     * Choose, which estudiantes to update.
     */
    where: estudiantesWhereUniqueInput
  }

  /**
   * estudiantes updateMany
   */
  export type estudiantesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estudiantes.
     */
    data: XOR<estudiantesUpdateManyMutationInput, estudiantesUncheckedUpdateManyInput>
    /**
     * Filter which estudiantes to update
     */
    where?: estudiantesWhereInput
    /**
     * Limit how many estudiantes to update.
     */
    limit?: number
  }

  /**
   * estudiantes updateManyAndReturn
   */
  export type estudiantesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * The data used to update estudiantes.
     */
    data: XOR<estudiantesUpdateManyMutationInput, estudiantesUncheckedUpdateManyInput>
    /**
     * Filter which estudiantes to update
     */
    where?: estudiantesWhereInput
    /**
     * Limit how many estudiantes to update.
     */
    limit?: number
  }

  /**
   * estudiantes upsert
   */
  export type estudiantesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * The filter to search for the estudiantes to update in case it exists.
     */
    where: estudiantesWhereUniqueInput
    /**
     * In case the estudiantes found by the `where` argument doesn't exist, create a new estudiantes with this data.
     */
    create: XOR<estudiantesCreateInput, estudiantesUncheckedCreateInput>
    /**
     * In case the estudiantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estudiantesUpdateInput, estudiantesUncheckedUpdateInput>
  }

  /**
   * estudiantes delete
   */
  export type estudiantesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter which estudiantes to delete.
     */
    where: estudiantesWhereUniqueInput
  }

  /**
   * estudiantes deleteMany
   */
  export type estudiantesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estudiantes to delete
     */
    where?: estudiantesWhereInput
    /**
     * Limit how many estudiantes to delete.
     */
    limit?: number
  }

  /**
   * estudiantes.usuario
   */
  export type estudiantes$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    where?: usuariosEstudiantesWhereInput
  }

  /**
   * estudiantes.calificaciones
   */
  export type estudiantes$calificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    where?: calificacionesWhereInput
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    cursor?: calificacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * estudiantes.certificados
   */
  export type estudiantes$certificadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    where?: certificadosWhereInput
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    cursor?: certificadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * estudiantes.inscripciones
   */
  export type estudiantes$inscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    where?: inscripcionesWhereInput
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    cursor?: inscripcionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * estudiantes without action
   */
  export type estudiantesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
  }


  /**
   * Model usuariosAdministradores
   */

  export type AggregateUsuariosAdministradores = {
    _count: UsuariosAdministradoresCountAggregateOutputType | null
    _min: UsuariosAdministradoresMinAggregateOutputType | null
    _max: UsuariosAdministradoresMaxAggregateOutputType | null
  }

  export type UsuariosAdministradoresMinAggregateOutputType = {
    id: string | null
    correo: string | null
    contrasena: string | null
    encargado: string | null
    estado: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    tipo: $Enums.TipoCuenta | null
  }

  export type UsuariosAdministradoresMaxAggregateOutputType = {
    id: string | null
    correo: string | null
    contrasena: string | null
    encargado: string | null
    estado: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    tipo: $Enums.TipoCuenta | null
  }

  export type UsuariosAdministradoresCountAggregateOutputType = {
    id: number
    correo: number
    contrasena: number
    encargado: number
    estado: number
    creadoEn: number
    actualizadoEn: number
    tipo: number
    _all: number
  }


  export type UsuariosAdministradoresMinAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    encargado?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    tipo?: true
  }

  export type UsuariosAdministradoresMaxAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    encargado?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    tipo?: true
  }

  export type UsuariosAdministradoresCountAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    encargado?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    tipo?: true
    _all?: true
  }

  export type UsuariosAdministradoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuariosAdministradores to aggregate.
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosAdministradores to fetch.
     */
    orderBy?: usuariosAdministradoresOrderByWithRelationInput | usuariosAdministradoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuariosAdministradoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosAdministradores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosAdministradores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuariosAdministradores
    **/
    _count?: true | UsuariosAdministradoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosAdministradoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosAdministradoresMaxAggregateInputType
  }

  export type GetUsuariosAdministradoresAggregateType<T extends UsuariosAdministradoresAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuariosAdministradores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuariosAdministradores[P]>
      : GetScalarType<T[P], AggregateUsuariosAdministradores[P]>
  }




  export type usuariosAdministradoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuariosAdministradoresWhereInput
    orderBy?: usuariosAdministradoresOrderByWithAggregationInput | usuariosAdministradoresOrderByWithAggregationInput[]
    by: UsuariosAdministradoresScalarFieldEnum[] | UsuariosAdministradoresScalarFieldEnum
    having?: usuariosAdministradoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosAdministradoresCountAggregateInputType | true
    _min?: UsuariosAdministradoresMinAggregateInputType
    _max?: UsuariosAdministradoresMaxAggregateInputType
  }

  export type UsuariosAdministradoresGroupByOutputType = {
    id: string
    correo: string
    contrasena: string
    encargado: string | null
    estado: boolean
    creadoEn: Date
    actualizadoEn: Date
    tipo: $Enums.TipoCuenta
    _count: UsuariosAdministradoresCountAggregateOutputType | null
    _min: UsuariosAdministradoresMinAggregateOutputType | null
    _max: UsuariosAdministradoresMaxAggregateOutputType | null
  }

  type GetUsuariosAdministradoresGroupByPayload<T extends usuariosAdministradoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosAdministradoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosAdministradoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosAdministradoresGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosAdministradoresGroupByOutputType[P]>
        }
      >
    >


  export type usuariosAdministradoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    encargado?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    tipo?: boolean
    docente?: boolean | usuariosAdministradores$docenteArgs<ExtArgs>
    auditorias?: boolean | usuariosAdministradores$auditoriasArgs<ExtArgs>
    grabaciones?: boolean | usuariosAdministradores$grabacionesArgs<ExtArgs>
    _count?: boolean | UsuariosAdministradoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosAdministradores"]>

  export type usuariosAdministradoresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    encargado?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["usuariosAdministradores"]>

  export type usuariosAdministradoresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    encargado?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["usuariosAdministradores"]>

  export type usuariosAdministradoresSelectScalar = {
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    encargado?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    tipo?: boolean
  }

  export type usuariosAdministradoresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "correo" | "contrasena" | "encargado" | "estado" | "creadoEn" | "actualizadoEn" | "tipo", ExtArgs["result"]["usuariosAdministradores"]>
  export type usuariosAdministradoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    docente?: boolean | usuariosAdministradores$docenteArgs<ExtArgs>
    auditorias?: boolean | usuariosAdministradores$auditoriasArgs<ExtArgs>
    grabaciones?: boolean | usuariosAdministradores$grabacionesArgs<ExtArgs>
    _count?: boolean | UsuariosAdministradoresCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usuariosAdministradoresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usuariosAdministradoresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usuariosAdministradoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuariosAdministradores"
    objects: {
      docente: Prisma.$docentePayload<ExtArgs> | null
      auditorias: Prisma.$auditoriaPayload<ExtArgs>[]
      grabaciones: Prisma.$grabacionesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      correo: string
      contrasena: string
      encargado: string | null
      estado: boolean
      creadoEn: Date
      actualizadoEn: Date
      tipo: $Enums.TipoCuenta
    }, ExtArgs["result"]["usuariosAdministradores"]>
    composites: {}
  }

  type usuariosAdministradoresGetPayload<S extends boolean | null | undefined | usuariosAdministradoresDefaultArgs> = $Result.GetResult<Prisma.$usuariosAdministradoresPayload, S>

  type usuariosAdministradoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuariosAdministradoresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosAdministradoresCountAggregateInputType | true
    }

  export interface usuariosAdministradoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuariosAdministradores'], meta: { name: 'usuariosAdministradores' } }
    /**
     * Find zero or one UsuariosAdministradores that matches the filter.
     * @param {usuariosAdministradoresFindUniqueArgs} args - Arguments to find a UsuariosAdministradores
     * @example
     * // Get one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuariosAdministradoresFindUniqueArgs>(args: SelectSubset<T, usuariosAdministradoresFindUniqueArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsuariosAdministradores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuariosAdministradoresFindUniqueOrThrowArgs} args - Arguments to find a UsuariosAdministradores
     * @example
     * // Get one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuariosAdministradoresFindUniqueOrThrowArgs>(args: SelectSubset<T, usuariosAdministradoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosAdministradores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresFindFirstArgs} args - Arguments to find a UsuariosAdministradores
     * @example
     * // Get one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuariosAdministradoresFindFirstArgs>(args?: SelectSubset<T, usuariosAdministradoresFindFirstArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosAdministradores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresFindFirstOrThrowArgs} args - Arguments to find a UsuariosAdministradores
     * @example
     * // Get one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuariosAdministradoresFindFirstOrThrowArgs>(args?: SelectSubset<T, usuariosAdministradoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsuariosAdministradores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findMany()
     * 
     * // Get first 10 UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosAdministradoresWithIdOnly = await prisma.usuariosAdministradores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuariosAdministradoresFindManyArgs>(args?: SelectSubset<T, usuariosAdministradoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsuariosAdministradores.
     * @param {usuariosAdministradoresCreateArgs} args - Arguments to create a UsuariosAdministradores.
     * @example
     * // Create one UsuariosAdministradores
     * const UsuariosAdministradores = await prisma.usuariosAdministradores.create({
     *   data: {
     *     // ... data to create a UsuariosAdministradores
     *   }
     * })
     * 
     */
    create<T extends usuariosAdministradoresCreateArgs>(args: SelectSubset<T, usuariosAdministradoresCreateArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsuariosAdministradores.
     * @param {usuariosAdministradoresCreateManyArgs} args - Arguments to create many UsuariosAdministradores.
     * @example
     * // Create many UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuariosAdministradoresCreateManyArgs>(args?: SelectSubset<T, usuariosAdministradoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuariosAdministradores and returns the data saved in the database.
     * @param {usuariosAdministradoresCreateManyAndReturnArgs} args - Arguments to create many UsuariosAdministradores.
     * @example
     * // Create many UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuariosAdministradores and only return the `id`
     * const usuariosAdministradoresWithIdOnly = await prisma.usuariosAdministradores.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuariosAdministradoresCreateManyAndReturnArgs>(args?: SelectSubset<T, usuariosAdministradoresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsuariosAdministradores.
     * @param {usuariosAdministradoresDeleteArgs} args - Arguments to delete one UsuariosAdministradores.
     * @example
     * // Delete one UsuariosAdministradores
     * const UsuariosAdministradores = await prisma.usuariosAdministradores.delete({
     *   where: {
     *     // ... filter to delete one UsuariosAdministradores
     *   }
     * })
     * 
     */
    delete<T extends usuariosAdministradoresDeleteArgs>(args: SelectSubset<T, usuariosAdministradoresDeleteArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsuariosAdministradores.
     * @param {usuariosAdministradoresUpdateArgs} args - Arguments to update one UsuariosAdministradores.
     * @example
     * // Update one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuariosAdministradoresUpdateArgs>(args: SelectSubset<T, usuariosAdministradoresUpdateArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsuariosAdministradores.
     * @param {usuariosAdministradoresDeleteManyArgs} args - Arguments to filter UsuariosAdministradores to delete.
     * @example
     * // Delete a few UsuariosAdministradores
     * const { count } = await prisma.usuariosAdministradores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuariosAdministradoresDeleteManyArgs>(args?: SelectSubset<T, usuariosAdministradoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosAdministradores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuariosAdministradoresUpdateManyArgs>(args: SelectSubset<T, usuariosAdministradoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosAdministradores and returns the data updated in the database.
     * @param {usuariosAdministradoresUpdateManyAndReturnArgs} args - Arguments to update many UsuariosAdministradores.
     * @example
     * // Update many UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsuariosAdministradores and only return the `id`
     * const usuariosAdministradoresWithIdOnly = await prisma.usuariosAdministradores.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usuariosAdministradoresUpdateManyAndReturnArgs>(args: SelectSubset<T, usuariosAdministradoresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsuariosAdministradores.
     * @param {usuariosAdministradoresUpsertArgs} args - Arguments to update or create a UsuariosAdministradores.
     * @example
     * // Update or create a UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.upsert({
     *   create: {
     *     // ... data to create a UsuariosAdministradores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuariosAdministradores we want to update
     *   }
     * })
     */
    upsert<T extends usuariosAdministradoresUpsertArgs>(args: SelectSubset<T, usuariosAdministradoresUpsertArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsuariosAdministradores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresCountArgs} args - Arguments to filter UsuariosAdministradores to count.
     * @example
     * // Count the number of UsuariosAdministradores
     * const count = await prisma.usuariosAdministradores.count({
     *   where: {
     *     // ... the filter for the UsuariosAdministradores we want to count
     *   }
     * })
    **/
    count<T extends usuariosAdministradoresCountArgs>(
      args?: Subset<T, usuariosAdministradoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosAdministradoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuariosAdministradores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAdministradoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAdministradoresAggregateArgs>(args: Subset<T, UsuariosAdministradoresAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAdministradoresAggregateType<T>>

    /**
     * Group by UsuariosAdministradores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuariosAdministradoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuariosAdministradoresGroupByArgs['orderBy'] }
        : { orderBy?: usuariosAdministradoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuariosAdministradoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosAdministradoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuariosAdministradores model
   */
  readonly fields: usuariosAdministradoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuariosAdministradores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuariosAdministradoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    docente<T extends usuariosAdministradores$docenteArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradores$docenteArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditorias<T extends usuariosAdministradores$auditoriasArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradores$auditoriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grabaciones<T extends usuariosAdministradores$grabacionesArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradores$grabacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuariosAdministradores model
   */
  interface usuariosAdministradoresFieldRefs {
    readonly id: FieldRef<"usuariosAdministradores", 'String'>
    readonly correo: FieldRef<"usuariosAdministradores", 'String'>
    readonly contrasena: FieldRef<"usuariosAdministradores", 'String'>
    readonly encargado: FieldRef<"usuariosAdministradores", 'String'>
    readonly estado: FieldRef<"usuariosAdministradores", 'Boolean'>
    readonly creadoEn: FieldRef<"usuariosAdministradores", 'DateTime'>
    readonly actualizadoEn: FieldRef<"usuariosAdministradores", 'DateTime'>
    readonly tipo: FieldRef<"usuariosAdministradores", 'TipoCuenta'>
  }
    

  // Custom InputTypes
  /**
   * usuariosAdministradores findUnique
   */
  export type usuariosAdministradoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where: usuariosAdministradoresWhereUniqueInput
  }

  /**
   * usuariosAdministradores findUniqueOrThrow
   */
  export type usuariosAdministradoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where: usuariosAdministradoresWhereUniqueInput
  }

  /**
   * usuariosAdministradores findFirst
   */
  export type usuariosAdministradoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosAdministradores to fetch.
     */
    orderBy?: usuariosAdministradoresOrderByWithRelationInput | usuariosAdministradoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuariosAdministradores.
     */
    cursor?: usuariosAdministradoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosAdministradores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosAdministradores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuariosAdministradores.
     */
    distinct?: UsuariosAdministradoresScalarFieldEnum | UsuariosAdministradoresScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores findFirstOrThrow
   */
  export type usuariosAdministradoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosAdministradores to fetch.
     */
    orderBy?: usuariosAdministradoresOrderByWithRelationInput | usuariosAdministradoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuariosAdministradores.
     */
    cursor?: usuariosAdministradoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosAdministradores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosAdministradores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuariosAdministradores.
     */
    distinct?: UsuariosAdministradoresScalarFieldEnum | UsuariosAdministradoresScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores findMany
   */
  export type usuariosAdministradoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosAdministradores to fetch.
     */
    orderBy?: usuariosAdministradoresOrderByWithRelationInput | usuariosAdministradoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuariosAdministradores.
     */
    cursor?: usuariosAdministradoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosAdministradores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosAdministradores.
     */
    skip?: number
    distinct?: UsuariosAdministradoresScalarFieldEnum | UsuariosAdministradoresScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores create
   */
  export type usuariosAdministradoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * The data needed to create a usuariosAdministradores.
     */
    data: XOR<usuariosAdministradoresCreateInput, usuariosAdministradoresUncheckedCreateInput>
  }

  /**
   * usuariosAdministradores createMany
   */
  export type usuariosAdministradoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuariosAdministradores.
     */
    data: usuariosAdministradoresCreateManyInput | usuariosAdministradoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuariosAdministradores createManyAndReturn
   */
  export type usuariosAdministradoresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * The data used to create many usuariosAdministradores.
     */
    data: usuariosAdministradoresCreateManyInput | usuariosAdministradoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuariosAdministradores update
   */
  export type usuariosAdministradoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * The data needed to update a usuariosAdministradores.
     */
    data: XOR<usuariosAdministradoresUpdateInput, usuariosAdministradoresUncheckedUpdateInput>
    /**
     * Choose, which usuariosAdministradores to update.
     */
    where: usuariosAdministradoresWhereUniqueInput
  }

  /**
   * usuariosAdministradores updateMany
   */
  export type usuariosAdministradoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuariosAdministradores.
     */
    data: XOR<usuariosAdministradoresUpdateManyMutationInput, usuariosAdministradoresUncheckedUpdateManyInput>
    /**
     * Filter which usuariosAdministradores to update
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * Limit how many usuariosAdministradores to update.
     */
    limit?: number
  }

  /**
   * usuariosAdministradores updateManyAndReturn
   */
  export type usuariosAdministradoresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * The data used to update usuariosAdministradores.
     */
    data: XOR<usuariosAdministradoresUpdateManyMutationInput, usuariosAdministradoresUncheckedUpdateManyInput>
    /**
     * Filter which usuariosAdministradores to update
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * Limit how many usuariosAdministradores to update.
     */
    limit?: number
  }

  /**
   * usuariosAdministradores upsert
   */
  export type usuariosAdministradoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * The filter to search for the usuariosAdministradores to update in case it exists.
     */
    where: usuariosAdministradoresWhereUniqueInput
    /**
     * In case the usuariosAdministradores found by the `where` argument doesn't exist, create a new usuariosAdministradores with this data.
     */
    create: XOR<usuariosAdministradoresCreateInput, usuariosAdministradoresUncheckedCreateInput>
    /**
     * In case the usuariosAdministradores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuariosAdministradoresUpdateInput, usuariosAdministradoresUncheckedUpdateInput>
  }

  /**
   * usuariosAdministradores delete
   */
  export type usuariosAdministradoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter which usuariosAdministradores to delete.
     */
    where: usuariosAdministradoresWhereUniqueInput
  }

  /**
   * usuariosAdministradores deleteMany
   */
  export type usuariosAdministradoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuariosAdministradores to delete
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * Limit how many usuariosAdministradores to delete.
     */
    limit?: number
  }

  /**
   * usuariosAdministradores.docente
   */
  export type usuariosAdministradores$docenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    where?: docenteWhereInput
  }

  /**
   * usuariosAdministradores.auditorias
   */
  export type usuariosAdministradores$auditoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    where?: auditoriaWhereInput
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    cursor?: auditoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores.grabaciones
   */
  export type usuariosAdministradores$grabacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    where?: grabacionesWhereInput
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    cursor?: grabacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores without action
   */
  export type usuariosAdministradoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
  }


  /**
   * Model docente
   */

  export type AggregateDocente = {
    _count: DocenteCountAggregateOutputType | null
    _avg: DocenteAvgAggregateOutputType | null
    _sum: DocenteSumAggregateOutputType | null
    _min: DocenteMinAggregateOutputType | null
    _max: DocenteMaxAggregateOutputType | null
  }

  export type DocenteAvgAggregateOutputType = {
    experiencia: number | null
  }

  export type DocenteSumAggregateOutputType = {
    experiencia: number | null
  }

  export type DocenteMinAggregateOutputType = {
    id: string | null
    nombre_completo: string | null
    celular: string | null
    especialidad: string | null
    experiencia: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    usuarioId: string | null
  }

  export type DocenteMaxAggregateOutputType = {
    id: string | null
    nombre_completo: string | null
    celular: string | null
    especialidad: string | null
    experiencia: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    usuarioId: string | null
  }

  export type DocenteCountAggregateOutputType = {
    id: number
    nombre_completo: number
    celular: number
    especialidad: number
    experiencia: number
    creadoEn: number
    actualizadoEn: number
    usuarioId: number
    _all: number
  }


  export type DocenteAvgAggregateInputType = {
    experiencia?: true
  }

  export type DocenteSumAggregateInputType = {
    experiencia?: true
  }

  export type DocenteMinAggregateInputType = {
    id?: true
    nombre_completo?: true
    celular?: true
    especialidad?: true
    experiencia?: true
    creadoEn?: true
    actualizadoEn?: true
    usuarioId?: true
  }

  export type DocenteMaxAggregateInputType = {
    id?: true
    nombre_completo?: true
    celular?: true
    especialidad?: true
    experiencia?: true
    creadoEn?: true
    actualizadoEn?: true
    usuarioId?: true
  }

  export type DocenteCountAggregateInputType = {
    id?: true
    nombre_completo?: true
    celular?: true
    especialidad?: true
    experiencia?: true
    creadoEn?: true
    actualizadoEn?: true
    usuarioId?: true
    _all?: true
  }

  export type DocenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which docente to aggregate.
     */
    where?: docenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docentes to fetch.
     */
    orderBy?: docenteOrderByWithRelationInput | docenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: docenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned docentes
    **/
    _count?: true | DocenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocenteMaxAggregateInputType
  }

  export type GetDocenteAggregateType<T extends DocenteAggregateArgs> = {
        [P in keyof T & keyof AggregateDocente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocente[P]>
      : GetScalarType<T[P], AggregateDocente[P]>
  }




  export type docenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: docenteWhereInput
    orderBy?: docenteOrderByWithAggregationInput | docenteOrderByWithAggregationInput[]
    by: DocenteScalarFieldEnum[] | DocenteScalarFieldEnum
    having?: docenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocenteCountAggregateInputType | true
    _avg?: DocenteAvgAggregateInputType
    _sum?: DocenteSumAggregateInputType
    _min?: DocenteMinAggregateInputType
    _max?: DocenteMaxAggregateInputType
  }

  export type DocenteGroupByOutputType = {
    id: string
    nombre_completo: string
    celular: string | null
    especialidad: string
    experiencia: number
    creadoEn: Date
    actualizadoEn: Date
    usuarioId: string
    _count: DocenteCountAggregateOutputType | null
    _avg: DocenteAvgAggregateOutputType | null
    _sum: DocenteSumAggregateOutputType | null
    _min: DocenteMinAggregateOutputType | null
    _max: DocenteMaxAggregateOutputType | null
  }

  type GetDocenteGroupByPayload<T extends docenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocenteGroupByOutputType[P]>
            : GetScalarType<T[P], DocenteGroupByOutputType[P]>
        }
      >
    >


  export type docenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_completo?: boolean
    celular?: boolean
    especialidad?: boolean
    experiencia?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuarioId?: boolean
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
    ediciones?: boolean | docente$edicionesArgs<ExtArgs>
    _count?: boolean | DocenteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["docente"]>

  export type docenteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_completo?: boolean
    celular?: boolean
    especialidad?: boolean
    experiencia?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuarioId?: boolean
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["docente"]>

  export type docenteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_completo?: boolean
    celular?: boolean
    especialidad?: boolean
    experiencia?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuarioId?: boolean
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["docente"]>

  export type docenteSelectScalar = {
    id?: boolean
    nombre_completo?: boolean
    celular?: boolean
    especialidad?: boolean
    experiencia?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuarioId?: boolean
  }

  export type docenteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_completo" | "celular" | "especialidad" | "experiencia" | "creadoEn" | "actualizadoEn" | "usuarioId", ExtArgs["result"]["docente"]>
  export type docenteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
    ediciones?: boolean | docente$edicionesArgs<ExtArgs>
    _count?: boolean | DocenteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type docenteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }
  export type docenteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }

  export type $docentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "docente"
    objects: {
      usuario: Prisma.$usuariosAdministradoresPayload<ExtArgs>
      ediciones: Prisma.$edicionesCursosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre_completo: string
      celular: string | null
      especialidad: string
      experiencia: number
      creadoEn: Date
      actualizadoEn: Date
      usuarioId: string
    }, ExtArgs["result"]["docente"]>
    composites: {}
  }

  type docenteGetPayload<S extends boolean | null | undefined | docenteDefaultArgs> = $Result.GetResult<Prisma.$docentePayload, S>

  type docenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<docenteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocenteCountAggregateInputType | true
    }

  export interface docenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['docente'], meta: { name: 'docente' } }
    /**
     * Find zero or one Docente that matches the filter.
     * @param {docenteFindUniqueArgs} args - Arguments to find a Docente
     * @example
     * // Get one Docente
     * const docente = await prisma.docente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends docenteFindUniqueArgs>(args: SelectSubset<T, docenteFindUniqueArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Docente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {docenteFindUniqueOrThrowArgs} args - Arguments to find a Docente
     * @example
     * // Get one Docente
     * const docente = await prisma.docente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends docenteFindUniqueOrThrowArgs>(args: SelectSubset<T, docenteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Docente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteFindFirstArgs} args - Arguments to find a Docente
     * @example
     * // Get one Docente
     * const docente = await prisma.docente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends docenteFindFirstArgs>(args?: SelectSubset<T, docenteFindFirstArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Docente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteFindFirstOrThrowArgs} args - Arguments to find a Docente
     * @example
     * // Get one Docente
     * const docente = await prisma.docente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends docenteFindFirstOrThrowArgs>(args?: SelectSubset<T, docenteFindFirstOrThrowArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Docentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Docentes
     * const docentes = await prisma.docente.findMany()
     * 
     * // Get first 10 Docentes
     * const docentes = await prisma.docente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const docenteWithIdOnly = await prisma.docente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends docenteFindManyArgs>(args?: SelectSubset<T, docenteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Docente.
     * @param {docenteCreateArgs} args - Arguments to create a Docente.
     * @example
     * // Create one Docente
     * const Docente = await prisma.docente.create({
     *   data: {
     *     // ... data to create a Docente
     *   }
     * })
     * 
     */
    create<T extends docenteCreateArgs>(args: SelectSubset<T, docenteCreateArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Docentes.
     * @param {docenteCreateManyArgs} args - Arguments to create many Docentes.
     * @example
     * // Create many Docentes
     * const docente = await prisma.docente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends docenteCreateManyArgs>(args?: SelectSubset<T, docenteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Docentes and returns the data saved in the database.
     * @param {docenteCreateManyAndReturnArgs} args - Arguments to create many Docentes.
     * @example
     * // Create many Docentes
     * const docente = await prisma.docente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Docentes and only return the `id`
     * const docenteWithIdOnly = await prisma.docente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends docenteCreateManyAndReturnArgs>(args?: SelectSubset<T, docenteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Docente.
     * @param {docenteDeleteArgs} args - Arguments to delete one Docente.
     * @example
     * // Delete one Docente
     * const Docente = await prisma.docente.delete({
     *   where: {
     *     // ... filter to delete one Docente
     *   }
     * })
     * 
     */
    delete<T extends docenteDeleteArgs>(args: SelectSubset<T, docenteDeleteArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Docente.
     * @param {docenteUpdateArgs} args - Arguments to update one Docente.
     * @example
     * // Update one Docente
     * const docente = await prisma.docente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends docenteUpdateArgs>(args: SelectSubset<T, docenteUpdateArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Docentes.
     * @param {docenteDeleteManyArgs} args - Arguments to filter Docentes to delete.
     * @example
     * // Delete a few Docentes
     * const { count } = await prisma.docente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends docenteDeleteManyArgs>(args?: SelectSubset<T, docenteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Docentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Docentes
     * const docente = await prisma.docente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends docenteUpdateManyArgs>(args: SelectSubset<T, docenteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Docentes and returns the data updated in the database.
     * @param {docenteUpdateManyAndReturnArgs} args - Arguments to update many Docentes.
     * @example
     * // Update many Docentes
     * const docente = await prisma.docente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Docentes and only return the `id`
     * const docenteWithIdOnly = await prisma.docente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends docenteUpdateManyAndReturnArgs>(args: SelectSubset<T, docenteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Docente.
     * @param {docenteUpsertArgs} args - Arguments to update or create a Docente.
     * @example
     * // Update or create a Docente
     * const docente = await prisma.docente.upsert({
     *   create: {
     *     // ... data to create a Docente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Docente we want to update
     *   }
     * })
     */
    upsert<T extends docenteUpsertArgs>(args: SelectSubset<T, docenteUpsertArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Docentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteCountArgs} args - Arguments to filter Docentes to count.
     * @example
     * // Count the number of Docentes
     * const count = await prisma.docente.count({
     *   where: {
     *     // ... the filter for the Docentes we want to count
     *   }
     * })
    **/
    count<T extends docenteCountArgs>(
      args?: Subset<T, docenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Docente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocenteAggregateArgs>(args: Subset<T, DocenteAggregateArgs>): Prisma.PrismaPromise<GetDocenteAggregateType<T>>

    /**
     * Group by Docente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends docenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: docenteGroupByArgs['orderBy'] }
        : { orderBy?: docenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, docenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the docente model
   */
  readonly fields: docenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for docente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__docenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usuariosAdministradoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradoresDefaultArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ediciones<T extends docente$edicionesArgs<ExtArgs> = {}>(args?: Subset<T, docente$edicionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the docente model
   */
  interface docenteFieldRefs {
    readonly id: FieldRef<"docente", 'String'>
    readonly nombre_completo: FieldRef<"docente", 'String'>
    readonly celular: FieldRef<"docente", 'String'>
    readonly especialidad: FieldRef<"docente", 'String'>
    readonly experiencia: FieldRef<"docente", 'Int'>
    readonly creadoEn: FieldRef<"docente", 'DateTime'>
    readonly actualizadoEn: FieldRef<"docente", 'DateTime'>
    readonly usuarioId: FieldRef<"docente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * docente findUnique
   */
  export type docenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docente to fetch.
     */
    where: docenteWhereUniqueInput
  }

  /**
   * docente findUniqueOrThrow
   */
  export type docenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docente to fetch.
     */
    where: docenteWhereUniqueInput
  }

  /**
   * docente findFirst
   */
  export type docenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docente to fetch.
     */
    where?: docenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docentes to fetch.
     */
    orderBy?: docenteOrderByWithRelationInput | docenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for docentes.
     */
    cursor?: docenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of docentes.
     */
    distinct?: DocenteScalarFieldEnum | DocenteScalarFieldEnum[]
  }

  /**
   * docente findFirstOrThrow
   */
  export type docenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docente to fetch.
     */
    where?: docenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docentes to fetch.
     */
    orderBy?: docenteOrderByWithRelationInput | docenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for docentes.
     */
    cursor?: docenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of docentes.
     */
    distinct?: DocenteScalarFieldEnum | DocenteScalarFieldEnum[]
  }

  /**
   * docente findMany
   */
  export type docenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docentes to fetch.
     */
    where?: docenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docentes to fetch.
     */
    orderBy?: docenteOrderByWithRelationInput | docenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing docentes.
     */
    cursor?: docenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docentes.
     */
    skip?: number
    distinct?: DocenteScalarFieldEnum | DocenteScalarFieldEnum[]
  }

  /**
   * docente create
   */
  export type docenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * The data needed to create a docente.
     */
    data: XOR<docenteCreateInput, docenteUncheckedCreateInput>
  }

  /**
   * docente createMany
   */
  export type docenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many docentes.
     */
    data: docenteCreateManyInput | docenteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * docente createManyAndReturn
   */
  export type docenteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * The data used to create many docentes.
     */
    data: docenteCreateManyInput | docenteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * docente update
   */
  export type docenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * The data needed to update a docente.
     */
    data: XOR<docenteUpdateInput, docenteUncheckedUpdateInput>
    /**
     * Choose, which docente to update.
     */
    where: docenteWhereUniqueInput
  }

  /**
   * docente updateMany
   */
  export type docenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update docentes.
     */
    data: XOR<docenteUpdateManyMutationInput, docenteUncheckedUpdateManyInput>
    /**
     * Filter which docentes to update
     */
    where?: docenteWhereInput
    /**
     * Limit how many docentes to update.
     */
    limit?: number
  }

  /**
   * docente updateManyAndReturn
   */
  export type docenteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * The data used to update docentes.
     */
    data: XOR<docenteUpdateManyMutationInput, docenteUncheckedUpdateManyInput>
    /**
     * Filter which docentes to update
     */
    where?: docenteWhereInput
    /**
     * Limit how many docentes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * docente upsert
   */
  export type docenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * The filter to search for the docente to update in case it exists.
     */
    where: docenteWhereUniqueInput
    /**
     * In case the docente found by the `where` argument doesn't exist, create a new docente with this data.
     */
    create: XOR<docenteCreateInput, docenteUncheckedCreateInput>
    /**
     * In case the docente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<docenteUpdateInput, docenteUncheckedUpdateInput>
  }

  /**
   * docente delete
   */
  export type docenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter which docente to delete.
     */
    where: docenteWhereUniqueInput
  }

  /**
   * docente deleteMany
   */
  export type docenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which docentes to delete
     */
    where?: docenteWhereInput
    /**
     * Limit how many docentes to delete.
     */
    limit?: number
  }

  /**
   * docente.ediciones
   */
  export type docente$edicionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    where?: edicionesCursosWhereInput
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    cursor?: edicionesCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * docente without action
   */
  export type docenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
  }


  /**
   * Model cursos
   */

  export type AggregateCursos = {
    _count: CursosCountAggregateOutputType | null
    _min: CursosMinAggregateOutputType | null
    _max: CursosMaxAggregateOutputType | null
  }

  export type CursosMinAggregateOutputType = {
    id: string | null
    descripcion: string | null
    titulo: string | null
    urlMiniatura: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    descripcionCorta: string | null
    enVivo: boolean | null
    urlCurso: string | null
  }

  export type CursosMaxAggregateOutputType = {
    id: string | null
    descripcion: string | null
    titulo: string | null
    urlMiniatura: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    descripcionCorta: string | null
    enVivo: boolean | null
    urlCurso: string | null
  }

  export type CursosCountAggregateOutputType = {
    id: number
    descripcion: number
    titulo: number
    urlMiniatura: number
    creadoEn: number
    actualizadoEn: number
    descripcionCorta: number
    enVivo: number
    urlCurso: number
    _all: number
  }


  export type CursosMinAggregateInputType = {
    id?: true
    descripcion?: true
    titulo?: true
    urlMiniatura?: true
    creadoEn?: true
    actualizadoEn?: true
    descripcionCorta?: true
    enVivo?: true
    urlCurso?: true
  }

  export type CursosMaxAggregateInputType = {
    id?: true
    descripcion?: true
    titulo?: true
    urlMiniatura?: true
    creadoEn?: true
    actualizadoEn?: true
    descripcionCorta?: true
    enVivo?: true
    urlCurso?: true
  }

  export type CursosCountAggregateInputType = {
    id?: true
    descripcion?: true
    titulo?: true
    urlMiniatura?: true
    creadoEn?: true
    actualizadoEn?: true
    descripcionCorta?: true
    enVivo?: true
    urlCurso?: true
    _all?: true
  }

  export type CursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cursos to aggregate.
     */
    where?: cursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cursos to fetch.
     */
    orderBy?: cursosOrderByWithRelationInput | cursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cursos
    **/
    _count?: true | CursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursosMaxAggregateInputType
  }

  export type GetCursosAggregateType<T extends CursosAggregateArgs> = {
        [P in keyof T & keyof AggregateCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCursos[P]>
      : GetScalarType<T[P], AggregateCursos[P]>
  }




  export type cursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cursosWhereInput
    orderBy?: cursosOrderByWithAggregationInput | cursosOrderByWithAggregationInput[]
    by: CursosScalarFieldEnum[] | CursosScalarFieldEnum
    having?: cursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursosCountAggregateInputType | true
    _min?: CursosMinAggregateInputType
    _max?: CursosMaxAggregateInputType
  }

  export type CursosGroupByOutputType = {
    id: string
    descripcion: string
    titulo: string
    urlMiniatura: string | null
    creadoEn: Date
    actualizadoEn: Date
    descripcionCorta: string | null
    enVivo: boolean
    urlCurso: string | null
    _count: CursosCountAggregateOutputType | null
    _min: CursosMinAggregateOutputType | null
    _max: CursosMaxAggregateOutputType | null
  }

  type GetCursosGroupByPayload<T extends cursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursosGroupByOutputType[P]>
            : GetScalarType<T[P], CursosGroupByOutputType[P]>
        }
      >
    >


  export type cursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descripcion?: boolean
    titulo?: boolean
    urlMiniatura?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    descripcionCorta?: boolean
    enVivo?: boolean
    urlCurso?: boolean
    ediciones?: boolean | cursos$edicionesArgs<ExtArgs>
    beneficios?: boolean | cursos$beneficiosArgs<ExtArgs>
    objetivos?: boolean | cursos$objetivosArgs<ExtArgs>
    requisitos?: boolean | cursos$requisitosArgs<ExtArgs>
    categorias?: boolean | cursos$categoriasArgs<ExtArgs>
    reviews?: boolean | cursos$reviewsArgs<ExtArgs>
    _count?: boolean | CursosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cursos"]>

  export type cursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descripcion?: boolean
    titulo?: boolean
    urlMiniatura?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    descripcionCorta?: boolean
    enVivo?: boolean
    urlCurso?: boolean
  }, ExtArgs["result"]["cursos"]>

  export type cursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descripcion?: boolean
    titulo?: boolean
    urlMiniatura?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    descripcionCorta?: boolean
    enVivo?: boolean
    urlCurso?: boolean
  }, ExtArgs["result"]["cursos"]>

  export type cursosSelectScalar = {
    id?: boolean
    descripcion?: boolean
    titulo?: boolean
    urlMiniatura?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    descripcionCorta?: boolean
    enVivo?: boolean
    urlCurso?: boolean
  }

  export type cursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descripcion" | "titulo" | "urlMiniatura" | "creadoEn" | "actualizadoEn" | "descripcionCorta" | "enVivo" | "urlCurso", ExtArgs["result"]["cursos"]>
  export type cursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ediciones?: boolean | cursos$edicionesArgs<ExtArgs>
    beneficios?: boolean | cursos$beneficiosArgs<ExtArgs>
    objetivos?: boolean | cursos$objetivosArgs<ExtArgs>
    requisitos?: boolean | cursos$requisitosArgs<ExtArgs>
    categorias?: boolean | cursos$categoriasArgs<ExtArgs>
    reviews?: boolean | cursos$reviewsArgs<ExtArgs>
    _count?: boolean | CursosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type cursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type cursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $cursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cursos"
    objects: {
      ediciones: Prisma.$edicionesCursosPayload<ExtArgs>[]
      beneficios: Prisma.$beneficiosCursosPayload<ExtArgs>[]
      objetivos: Prisma.$objetivosCursosPayload<ExtArgs>[]
      requisitos: Prisma.$requisitosCursosPayload<ExtArgs>[]
      categorias: Prisma.$categoriasCursosPayload<ExtArgs>[]
      reviews: Prisma.$reviewsCursosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      descripcion: string
      titulo: string
      urlMiniatura: string | null
      creadoEn: Date
      actualizadoEn: Date
      descripcionCorta: string | null
      enVivo: boolean
      urlCurso: string | null
    }, ExtArgs["result"]["cursos"]>
    composites: {}
  }

  type cursosGetPayload<S extends boolean | null | undefined | cursosDefaultArgs> = $Result.GetResult<Prisma.$cursosPayload, S>

  type cursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CursosCountAggregateInputType | true
    }

  export interface cursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cursos'], meta: { name: 'cursos' } }
    /**
     * Find zero or one Cursos that matches the filter.
     * @param {cursosFindUniqueArgs} args - Arguments to find a Cursos
     * @example
     * // Get one Cursos
     * const cursos = await prisma.cursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cursosFindUniqueArgs>(args: SelectSubset<T, cursosFindUniqueArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cursosFindUniqueOrThrowArgs} args - Arguments to find a Cursos
     * @example
     * // Get one Cursos
     * const cursos = await prisma.cursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cursosFindUniqueOrThrowArgs>(args: SelectSubset<T, cursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosFindFirstArgs} args - Arguments to find a Cursos
     * @example
     * // Get one Cursos
     * const cursos = await prisma.cursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cursosFindFirstArgs>(args?: SelectSubset<T, cursosFindFirstArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosFindFirstOrThrowArgs} args - Arguments to find a Cursos
     * @example
     * // Get one Cursos
     * const cursos = await prisma.cursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cursosFindFirstOrThrowArgs>(args?: SelectSubset<T, cursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cursos
     * const cursos = await prisma.cursos.findMany()
     * 
     * // Get first 10 Cursos
     * const cursos = await prisma.cursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursosWithIdOnly = await prisma.cursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cursosFindManyArgs>(args?: SelectSubset<T, cursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cursos.
     * @param {cursosCreateArgs} args - Arguments to create a Cursos.
     * @example
     * // Create one Cursos
     * const Cursos = await prisma.cursos.create({
     *   data: {
     *     // ... data to create a Cursos
     *   }
     * })
     * 
     */
    create<T extends cursosCreateArgs>(args: SelectSubset<T, cursosCreateArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cursos.
     * @param {cursosCreateManyArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const cursos = await prisma.cursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cursosCreateManyArgs>(args?: SelectSubset<T, cursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cursos and returns the data saved in the database.
     * @param {cursosCreateManyAndReturnArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const cursos = await prisma.cursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cursos and only return the `id`
     * const cursosWithIdOnly = await prisma.cursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cursosCreateManyAndReturnArgs>(args?: SelectSubset<T, cursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cursos.
     * @param {cursosDeleteArgs} args - Arguments to delete one Cursos.
     * @example
     * // Delete one Cursos
     * const Cursos = await prisma.cursos.delete({
     *   where: {
     *     // ... filter to delete one Cursos
     *   }
     * })
     * 
     */
    delete<T extends cursosDeleteArgs>(args: SelectSubset<T, cursosDeleteArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cursos.
     * @param {cursosUpdateArgs} args - Arguments to update one Cursos.
     * @example
     * // Update one Cursos
     * const cursos = await prisma.cursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cursosUpdateArgs>(args: SelectSubset<T, cursosUpdateArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cursos.
     * @param {cursosDeleteManyArgs} args - Arguments to filter Cursos to delete.
     * @example
     * // Delete a few Cursos
     * const { count } = await prisma.cursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cursosDeleteManyArgs>(args?: SelectSubset<T, cursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cursos
     * const cursos = await prisma.cursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cursosUpdateManyArgs>(args: SelectSubset<T, cursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos and returns the data updated in the database.
     * @param {cursosUpdateManyAndReturnArgs} args - Arguments to update many Cursos.
     * @example
     * // Update many Cursos
     * const cursos = await prisma.cursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cursos and only return the `id`
     * const cursosWithIdOnly = await prisma.cursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cursosUpdateManyAndReturnArgs>(args: SelectSubset<T, cursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cursos.
     * @param {cursosUpsertArgs} args - Arguments to update or create a Cursos.
     * @example
     * // Update or create a Cursos
     * const cursos = await prisma.cursos.upsert({
     *   create: {
     *     // ... data to create a Cursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cursos we want to update
     *   }
     * })
     */
    upsert<T extends cursosUpsertArgs>(args: SelectSubset<T, cursosUpsertArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosCountArgs} args - Arguments to filter Cursos to count.
     * @example
     * // Count the number of Cursos
     * const count = await prisma.cursos.count({
     *   where: {
     *     // ... the filter for the Cursos we want to count
     *   }
     * })
    **/
    count<T extends cursosCountArgs>(
      args?: Subset<T, cursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursosAggregateArgs>(args: Subset<T, CursosAggregateArgs>): Prisma.PrismaPromise<GetCursosAggregateType<T>>

    /**
     * Group by Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cursosGroupByArgs['orderBy'] }
        : { orderBy?: cursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cursos model
   */
  readonly fields: cursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ediciones<T extends cursos$edicionesArgs<ExtArgs> = {}>(args?: Subset<T, cursos$edicionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    beneficios<T extends cursos$beneficiosArgs<ExtArgs> = {}>(args?: Subset<T, cursos$beneficiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    objetivos<T extends cursos$objetivosArgs<ExtArgs> = {}>(args?: Subset<T, cursos$objetivosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requisitos<T extends cursos$requisitosArgs<ExtArgs> = {}>(args?: Subset<T, cursos$requisitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categorias<T extends cursos$categoriasArgs<ExtArgs> = {}>(args?: Subset<T, cursos$categoriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends cursos$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, cursos$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cursos model
   */
  interface cursosFieldRefs {
    readonly id: FieldRef<"cursos", 'String'>
    readonly descripcion: FieldRef<"cursos", 'String'>
    readonly titulo: FieldRef<"cursos", 'String'>
    readonly urlMiniatura: FieldRef<"cursos", 'String'>
    readonly creadoEn: FieldRef<"cursos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"cursos", 'DateTime'>
    readonly descripcionCorta: FieldRef<"cursos", 'String'>
    readonly enVivo: FieldRef<"cursos", 'Boolean'>
    readonly urlCurso: FieldRef<"cursos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cursos findUnique
   */
  export type cursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where: cursosWhereUniqueInput
  }

  /**
   * cursos findUniqueOrThrow
   */
  export type cursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where: cursosWhereUniqueInput
  }

  /**
   * cursos findFirst
   */
  export type cursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where?: cursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cursos to fetch.
     */
    orderBy?: cursosOrderByWithRelationInput | cursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cursos.
     */
    cursor?: cursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cursos.
     */
    distinct?: CursosScalarFieldEnum | CursosScalarFieldEnum[]
  }

  /**
   * cursos findFirstOrThrow
   */
  export type cursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where?: cursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cursos to fetch.
     */
    orderBy?: cursosOrderByWithRelationInput | cursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cursos.
     */
    cursor?: cursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cursos.
     */
    distinct?: CursosScalarFieldEnum | CursosScalarFieldEnum[]
  }

  /**
   * cursos findMany
   */
  export type cursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where?: cursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cursos to fetch.
     */
    orderBy?: cursosOrderByWithRelationInput | cursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cursos.
     */
    cursor?: cursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cursos.
     */
    skip?: number
    distinct?: CursosScalarFieldEnum | CursosScalarFieldEnum[]
  }

  /**
   * cursos create
   */
  export type cursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * The data needed to create a cursos.
     */
    data: XOR<cursosCreateInput, cursosUncheckedCreateInput>
  }

  /**
   * cursos createMany
   */
  export type cursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cursos.
     */
    data: cursosCreateManyInput | cursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cursos createManyAndReturn
   */
  export type cursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * The data used to create many cursos.
     */
    data: cursosCreateManyInput | cursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cursos update
   */
  export type cursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * The data needed to update a cursos.
     */
    data: XOR<cursosUpdateInput, cursosUncheckedUpdateInput>
    /**
     * Choose, which cursos to update.
     */
    where: cursosWhereUniqueInput
  }

  /**
   * cursos updateMany
   */
  export type cursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cursos.
     */
    data: XOR<cursosUpdateManyMutationInput, cursosUncheckedUpdateManyInput>
    /**
     * Filter which cursos to update
     */
    where?: cursosWhereInput
    /**
     * Limit how many cursos to update.
     */
    limit?: number
  }

  /**
   * cursos updateManyAndReturn
   */
  export type cursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * The data used to update cursos.
     */
    data: XOR<cursosUpdateManyMutationInput, cursosUncheckedUpdateManyInput>
    /**
     * Filter which cursos to update
     */
    where?: cursosWhereInput
    /**
     * Limit how many cursos to update.
     */
    limit?: number
  }

  /**
   * cursos upsert
   */
  export type cursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * The filter to search for the cursos to update in case it exists.
     */
    where: cursosWhereUniqueInput
    /**
     * In case the cursos found by the `where` argument doesn't exist, create a new cursos with this data.
     */
    create: XOR<cursosCreateInput, cursosUncheckedCreateInput>
    /**
     * In case the cursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cursosUpdateInput, cursosUncheckedUpdateInput>
  }

  /**
   * cursos delete
   */
  export type cursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter which cursos to delete.
     */
    where: cursosWhereUniqueInput
  }

  /**
   * cursos deleteMany
   */
  export type cursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cursos to delete
     */
    where?: cursosWhereInput
    /**
     * Limit how many cursos to delete.
     */
    limit?: number
  }

  /**
   * cursos.ediciones
   */
  export type cursos$edicionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    where?: edicionesCursosWhereInput
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    cursor?: edicionesCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * cursos.beneficios
   */
  export type cursos$beneficiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    where?: beneficiosCursosWhereInput
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    cursor?: beneficiosCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeneficiosCursosScalarFieldEnum | BeneficiosCursosScalarFieldEnum[]
  }

  /**
   * cursos.objetivos
   */
  export type cursos$objetivosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    where?: objetivosCursosWhereInput
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    cursor?: objetivosCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjetivosCursosScalarFieldEnum | ObjetivosCursosScalarFieldEnum[]
  }

  /**
   * cursos.requisitos
   */
  export type cursos$requisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    where?: requisitosCursosWhereInput
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    cursor?: requisitosCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequisitosCursosScalarFieldEnum | RequisitosCursosScalarFieldEnum[]
  }

  /**
   * cursos.categorias
   */
  export type cursos$categoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    where?: categoriasCursosWhereInput
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    cursor?: categoriasCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * cursos.reviews
   */
  export type cursos$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    where?: reviewsCursosWhereInput
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    cursor?: reviewsCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * cursos without action
   */
  export type cursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
  }


  /**
   * Model categoriasCursos
   */

  export type AggregateCategoriasCursos = {
    _count: CategoriasCursosCountAggregateOutputType | null
    _min: CategoriasCursosMinAggregateOutputType | null
    _max: CategoriasCursosMaxAggregateOutputType | null
  }

  export type CategoriasCursosMinAggregateOutputType = {
    id: string | null
    categoriaId: string | null
    cursoId: string | null
  }

  export type CategoriasCursosMaxAggregateOutputType = {
    id: string | null
    categoriaId: string | null
    cursoId: string | null
  }

  export type CategoriasCursosCountAggregateOutputType = {
    id: number
    categoriaId: number
    cursoId: number
    _all: number
  }


  export type CategoriasCursosMinAggregateInputType = {
    id?: true
    categoriaId?: true
    cursoId?: true
  }

  export type CategoriasCursosMaxAggregateInputType = {
    id?: true
    categoriaId?: true
    cursoId?: true
  }

  export type CategoriasCursosCountAggregateInputType = {
    id?: true
    categoriaId?: true
    cursoId?: true
    _all?: true
  }

  export type CategoriasCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoriasCursos to aggregate.
     */
    where?: categoriasCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriasCursos to fetch.
     */
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriasCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriasCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriasCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categoriasCursos
    **/
    _count?: true | CategoriasCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriasCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriasCursosMaxAggregateInputType
  }

  export type GetCategoriasCursosAggregateType<T extends CategoriasCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoriasCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoriasCursos[P]>
      : GetScalarType<T[P], AggregateCategoriasCursos[P]>
  }




  export type categoriasCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriasCursosWhereInput
    orderBy?: categoriasCursosOrderByWithAggregationInput | categoriasCursosOrderByWithAggregationInput[]
    by: CategoriasCursosScalarFieldEnum[] | CategoriasCursosScalarFieldEnum
    having?: categoriasCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriasCursosCountAggregateInputType | true
    _min?: CategoriasCursosMinAggregateInputType
    _max?: CategoriasCursosMaxAggregateInputType
  }

  export type CategoriasCursosGroupByOutputType = {
    id: string
    categoriaId: string
    cursoId: string
    _count: CategoriasCursosCountAggregateOutputType | null
    _min: CategoriasCursosMinAggregateOutputType | null
    _max: CategoriasCursosMaxAggregateOutputType | null
  }

  type GetCategoriasCursosGroupByPayload<T extends categoriasCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriasCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriasCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriasCursosGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriasCursosGroupByOutputType[P]>
        }
      >
    >


  export type categoriasCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoriaId?: boolean
    cursoId?: boolean
    categoria?: boolean | categoriasDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriasCursos"]>

  export type categoriasCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoriaId?: boolean
    cursoId?: boolean
    categoria?: boolean | categoriasDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriasCursos"]>

  export type categoriasCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoriaId?: boolean
    cursoId?: boolean
    categoria?: boolean | categoriasDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriasCursos"]>

  export type categoriasCursosSelectScalar = {
    id?: boolean
    categoriaId?: boolean
    cursoId?: boolean
  }

  export type categoriasCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoriaId" | "cursoId", ExtArgs["result"]["categoriasCursos"]>
  export type categoriasCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | categoriasDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type categoriasCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | categoriasDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type categoriasCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | categoriasDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }

  export type $categoriasCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categoriasCursos"
    objects: {
      categoria: Prisma.$categoriasPayload<ExtArgs>
      curso: Prisma.$cursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoriaId: string
      cursoId: string
    }, ExtArgs["result"]["categoriasCursos"]>
    composites: {}
  }

  type categoriasCursosGetPayload<S extends boolean | null | undefined | categoriasCursosDefaultArgs> = $Result.GetResult<Prisma.$categoriasCursosPayload, S>

  type categoriasCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriasCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriasCursosCountAggregateInputType | true
    }

  export interface categoriasCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categoriasCursos'], meta: { name: 'categoriasCursos' } }
    /**
     * Find zero or one CategoriasCursos that matches the filter.
     * @param {categoriasCursosFindUniqueArgs} args - Arguments to find a CategoriasCursos
     * @example
     * // Get one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriasCursosFindUniqueArgs>(args: SelectSubset<T, categoriasCursosFindUniqueArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoriasCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriasCursosFindUniqueOrThrowArgs} args - Arguments to find a CategoriasCursos
     * @example
     * // Get one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriasCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriasCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoriasCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosFindFirstArgs} args - Arguments to find a CategoriasCursos
     * @example
     * // Get one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriasCursosFindFirstArgs>(args?: SelectSubset<T, categoriasCursosFindFirstArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoriasCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosFindFirstOrThrowArgs} args - Arguments to find a CategoriasCursos
     * @example
     * // Get one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriasCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriasCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoriasCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findMany()
     * 
     * // Get first 10 CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriasCursosWithIdOnly = await prisma.categoriasCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriasCursosFindManyArgs>(args?: SelectSubset<T, categoriasCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoriasCursos.
     * @param {categoriasCursosCreateArgs} args - Arguments to create a CategoriasCursos.
     * @example
     * // Create one CategoriasCursos
     * const CategoriasCursos = await prisma.categoriasCursos.create({
     *   data: {
     *     // ... data to create a CategoriasCursos
     *   }
     * })
     * 
     */
    create<T extends categoriasCursosCreateArgs>(args: SelectSubset<T, categoriasCursosCreateArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoriasCursos.
     * @param {categoriasCursosCreateManyArgs} args - Arguments to create many CategoriasCursos.
     * @example
     * // Create many CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriasCursosCreateManyArgs>(args?: SelectSubset<T, categoriasCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoriasCursos and returns the data saved in the database.
     * @param {categoriasCursosCreateManyAndReturnArgs} args - Arguments to create many CategoriasCursos.
     * @example
     * // Create many CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoriasCursos and only return the `id`
     * const categoriasCursosWithIdOnly = await prisma.categoriasCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriasCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriasCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CategoriasCursos.
     * @param {categoriasCursosDeleteArgs} args - Arguments to delete one CategoriasCursos.
     * @example
     * // Delete one CategoriasCursos
     * const CategoriasCursos = await prisma.categoriasCursos.delete({
     *   where: {
     *     // ... filter to delete one CategoriasCursos
     *   }
     * })
     * 
     */
    delete<T extends categoriasCursosDeleteArgs>(args: SelectSubset<T, categoriasCursosDeleteArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoriasCursos.
     * @param {categoriasCursosUpdateArgs} args - Arguments to update one CategoriasCursos.
     * @example
     * // Update one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriasCursosUpdateArgs>(args: SelectSubset<T, categoriasCursosUpdateArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoriasCursos.
     * @param {categoriasCursosDeleteManyArgs} args - Arguments to filter CategoriasCursos to delete.
     * @example
     * // Delete a few CategoriasCursos
     * const { count } = await prisma.categoriasCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriasCursosDeleteManyArgs>(args?: SelectSubset<T, categoriasCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriasCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriasCursosUpdateManyArgs>(args: SelectSubset<T, categoriasCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriasCursos and returns the data updated in the database.
     * @param {categoriasCursosUpdateManyAndReturnArgs} args - Arguments to update many CategoriasCursos.
     * @example
     * // Update many CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CategoriasCursos and only return the `id`
     * const categoriasCursosWithIdOnly = await prisma.categoriasCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriasCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriasCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CategoriasCursos.
     * @param {categoriasCursosUpsertArgs} args - Arguments to update or create a CategoriasCursos.
     * @example
     * // Update or create a CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.upsert({
     *   create: {
     *     // ... data to create a CategoriasCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoriasCursos we want to update
     *   }
     * })
     */
    upsert<T extends categoriasCursosUpsertArgs>(args: SelectSubset<T, categoriasCursosUpsertArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoriasCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosCountArgs} args - Arguments to filter CategoriasCursos to count.
     * @example
     * // Count the number of CategoriasCursos
     * const count = await prisma.categoriasCursos.count({
     *   where: {
     *     // ... the filter for the CategoriasCursos we want to count
     *   }
     * })
    **/
    count<T extends categoriasCursosCountArgs>(
      args?: Subset<T, categoriasCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriasCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoriasCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriasCursosAggregateArgs>(args: Subset<T, CategoriasCursosAggregateArgs>): Prisma.PrismaPromise<GetCategoriasCursosAggregateType<T>>

    /**
     * Group by CategoriasCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriasCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriasCursosGroupByArgs['orderBy'] }
        : { orderBy?: categoriasCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriasCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriasCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categoriasCursos model
   */
  readonly fields: categoriasCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categoriasCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriasCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categoria<T extends categoriasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriasDefaultArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    curso<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categoriasCursos model
   */
  interface categoriasCursosFieldRefs {
    readonly id: FieldRef<"categoriasCursos", 'String'>
    readonly categoriaId: FieldRef<"categoriasCursos", 'String'>
    readonly cursoId: FieldRef<"categoriasCursos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * categoriasCursos findUnique
   */
  export type categoriasCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where: categoriasCursosWhereUniqueInput
  }

  /**
   * categoriasCursos findUniqueOrThrow
   */
  export type categoriasCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where: categoriasCursosWhereUniqueInput
  }

  /**
   * categoriasCursos findFirst
   */
  export type categoriasCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where?: categoriasCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriasCursos to fetch.
     */
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoriasCursos.
     */
    cursor?: categoriasCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriasCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriasCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoriasCursos.
     */
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * categoriasCursos findFirstOrThrow
   */
  export type categoriasCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where?: categoriasCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriasCursos to fetch.
     */
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoriasCursos.
     */
    cursor?: categoriasCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriasCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriasCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoriasCursos.
     */
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * categoriasCursos findMany
   */
  export type categoriasCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where?: categoriasCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriasCursos to fetch.
     */
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categoriasCursos.
     */
    cursor?: categoriasCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriasCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriasCursos.
     */
    skip?: number
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * categoriasCursos create
   */
  export type categoriasCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a categoriasCursos.
     */
    data: XOR<categoriasCursosCreateInput, categoriasCursosUncheckedCreateInput>
  }

  /**
   * categoriasCursos createMany
   */
  export type categoriasCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categoriasCursos.
     */
    data: categoriasCursosCreateManyInput | categoriasCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categoriasCursos createManyAndReturn
   */
  export type categoriasCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * The data used to create many categoriasCursos.
     */
    data: categoriasCursosCreateManyInput | categoriasCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * categoriasCursos update
   */
  export type categoriasCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a categoriasCursos.
     */
    data: XOR<categoriasCursosUpdateInput, categoriasCursosUncheckedUpdateInput>
    /**
     * Choose, which categoriasCursos to update.
     */
    where: categoriasCursosWhereUniqueInput
  }

  /**
   * categoriasCursos updateMany
   */
  export type categoriasCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categoriasCursos.
     */
    data: XOR<categoriasCursosUpdateManyMutationInput, categoriasCursosUncheckedUpdateManyInput>
    /**
     * Filter which categoriasCursos to update
     */
    where?: categoriasCursosWhereInput
    /**
     * Limit how many categoriasCursos to update.
     */
    limit?: number
  }

  /**
   * categoriasCursos updateManyAndReturn
   */
  export type categoriasCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * The data used to update categoriasCursos.
     */
    data: XOR<categoriasCursosUpdateManyMutationInput, categoriasCursosUncheckedUpdateManyInput>
    /**
     * Filter which categoriasCursos to update
     */
    where?: categoriasCursosWhereInput
    /**
     * Limit how many categoriasCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * categoriasCursos upsert
   */
  export type categoriasCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the categoriasCursos to update in case it exists.
     */
    where: categoriasCursosWhereUniqueInput
    /**
     * In case the categoriasCursos found by the `where` argument doesn't exist, create a new categoriasCursos with this data.
     */
    create: XOR<categoriasCursosCreateInput, categoriasCursosUncheckedCreateInput>
    /**
     * In case the categoriasCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriasCursosUpdateInput, categoriasCursosUncheckedUpdateInput>
  }

  /**
   * categoriasCursos delete
   */
  export type categoriasCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter which categoriasCursos to delete.
     */
    where: categoriasCursosWhereUniqueInput
  }

  /**
   * categoriasCursos deleteMany
   */
  export type categoriasCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoriasCursos to delete
     */
    where?: categoriasCursosWhereInput
    /**
     * Limit how many categoriasCursos to delete.
     */
    limit?: number
  }

  /**
   * categoriasCursos without action
   */
  export type categoriasCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
  }


  /**
   * Model reviewsCursos
   */

  export type AggregateReviewsCursos = {
    _count: ReviewsCursosCountAggregateOutputType | null
    _avg: ReviewsCursosAvgAggregateOutputType | null
    _sum: ReviewsCursosSumAggregateOutputType | null
    _min: ReviewsCursosMinAggregateOutputType | null
    _max: ReviewsCursosMaxAggregateOutputType | null
  }

  export type ReviewsCursosAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsCursosSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsCursosMinAggregateOutputType = {
    id: string | null
    cursoId: string | null
    rating: number | null
    comentario: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    usuariosEstudiantesId: string | null
  }

  export type ReviewsCursosMaxAggregateOutputType = {
    id: string | null
    cursoId: string | null
    rating: number | null
    comentario: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    usuariosEstudiantesId: string | null
  }

  export type ReviewsCursosCountAggregateOutputType = {
    id: number
    cursoId: number
    rating: number
    comentario: number
    creadoEn: number
    actualizadoEn: number
    usuariosEstudiantesId: number
    _all: number
  }


  export type ReviewsCursosAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewsCursosSumAggregateInputType = {
    rating?: true
  }

  export type ReviewsCursosMinAggregateInputType = {
    id?: true
    cursoId?: true
    rating?: true
    comentario?: true
    creadoEn?: true
    actualizadoEn?: true
    usuariosEstudiantesId?: true
  }

  export type ReviewsCursosMaxAggregateInputType = {
    id?: true
    cursoId?: true
    rating?: true
    comentario?: true
    creadoEn?: true
    actualizadoEn?: true
    usuariosEstudiantesId?: true
  }

  export type ReviewsCursosCountAggregateInputType = {
    id?: true
    cursoId?: true
    rating?: true
    comentario?: true
    creadoEn?: true
    actualizadoEn?: true
    usuariosEstudiantesId?: true
    _all?: true
  }

  export type ReviewsCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviewsCursos to aggregate.
     */
    where?: reviewsCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewsCursos to fetch.
     */
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewsCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewsCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewsCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviewsCursos
    **/
    _count?: true | ReviewsCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsCursosMaxAggregateInputType
  }

  export type GetReviewsCursosAggregateType<T extends ReviewsCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewsCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewsCursos[P]>
      : GetScalarType<T[P], AggregateReviewsCursos[P]>
  }




  export type reviewsCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsCursosWhereInput
    orderBy?: reviewsCursosOrderByWithAggregationInput | reviewsCursosOrderByWithAggregationInput[]
    by: ReviewsCursosScalarFieldEnum[] | ReviewsCursosScalarFieldEnum
    having?: reviewsCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCursosCountAggregateInputType | true
    _avg?: ReviewsCursosAvgAggregateInputType
    _sum?: ReviewsCursosSumAggregateInputType
    _min?: ReviewsCursosMinAggregateInputType
    _max?: ReviewsCursosMaxAggregateInputType
  }

  export type ReviewsCursosGroupByOutputType = {
    id: string
    cursoId: string
    rating: number
    comentario: string | null
    creadoEn: Date
    actualizadoEn: Date
    usuariosEstudiantesId: string
    _count: ReviewsCursosCountAggregateOutputType | null
    _avg: ReviewsCursosAvgAggregateOutputType | null
    _sum: ReviewsCursosSumAggregateOutputType | null
    _min: ReviewsCursosMinAggregateOutputType | null
    _max: ReviewsCursosMaxAggregateOutputType | null
  }

  type GetReviewsCursosGroupByPayload<T extends reviewsCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsCursosGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsCursosGroupByOutputType[P]>
        }
      >
    >


  export type reviewsCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    rating?: boolean
    comentario?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantesId?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewsCursos"]>

  export type reviewsCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    rating?: boolean
    comentario?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantesId?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewsCursos"]>

  export type reviewsCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    rating?: boolean
    comentario?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantesId?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewsCursos"]>

  export type reviewsCursosSelectScalar = {
    id?: boolean
    cursoId?: boolean
    rating?: boolean
    comentario?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantesId?: boolean
  }

  export type reviewsCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cursoId" | "rating" | "comentario" | "creadoEn" | "actualizadoEn" | "usuariosEstudiantesId", ExtArgs["result"]["reviewsCursos"]>
  export type reviewsCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }
  export type reviewsCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }
  export type reviewsCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }

  export type $reviewsCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviewsCursos"
    objects: {
      curso: Prisma.$cursosPayload<ExtArgs>
      usuario: Prisma.$usuariosEstudiantesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cursoId: string
      rating: number
      comentario: string | null
      creadoEn: Date
      actualizadoEn: Date
      usuariosEstudiantesId: string
    }, ExtArgs["result"]["reviewsCursos"]>
    composites: {}
  }

  type reviewsCursosGetPayload<S extends boolean | null | undefined | reviewsCursosDefaultArgs> = $Result.GetResult<Prisma.$reviewsCursosPayload, S>

  type reviewsCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewsCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewsCursosCountAggregateInputType | true
    }

  export interface reviewsCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviewsCursos'], meta: { name: 'reviewsCursos' } }
    /**
     * Find zero or one ReviewsCursos that matches the filter.
     * @param {reviewsCursosFindUniqueArgs} args - Arguments to find a ReviewsCursos
     * @example
     * // Get one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewsCursosFindUniqueArgs>(args: SelectSubset<T, reviewsCursosFindUniqueArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewsCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewsCursosFindUniqueOrThrowArgs} args - Arguments to find a ReviewsCursos
     * @example
     * // Get one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewsCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewsCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewsCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosFindFirstArgs} args - Arguments to find a ReviewsCursos
     * @example
     * // Get one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewsCursosFindFirstArgs>(args?: SelectSubset<T, reviewsCursosFindFirstArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewsCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosFindFirstOrThrowArgs} args - Arguments to find a ReviewsCursos
     * @example
     * // Get one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewsCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewsCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewsCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findMany()
     * 
     * // Get first 10 ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsCursosWithIdOnly = await prisma.reviewsCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reviewsCursosFindManyArgs>(args?: SelectSubset<T, reviewsCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewsCursos.
     * @param {reviewsCursosCreateArgs} args - Arguments to create a ReviewsCursos.
     * @example
     * // Create one ReviewsCursos
     * const ReviewsCursos = await prisma.reviewsCursos.create({
     *   data: {
     *     // ... data to create a ReviewsCursos
     *   }
     * })
     * 
     */
    create<T extends reviewsCursosCreateArgs>(args: SelectSubset<T, reviewsCursosCreateArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewsCursos.
     * @param {reviewsCursosCreateManyArgs} args - Arguments to create many ReviewsCursos.
     * @example
     * // Create many ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewsCursosCreateManyArgs>(args?: SelectSubset<T, reviewsCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewsCursos and returns the data saved in the database.
     * @param {reviewsCursosCreateManyAndReturnArgs} args - Arguments to create many ReviewsCursos.
     * @example
     * // Create many ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewsCursos and only return the `id`
     * const reviewsCursosWithIdOnly = await prisma.reviewsCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewsCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewsCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewsCursos.
     * @param {reviewsCursosDeleteArgs} args - Arguments to delete one ReviewsCursos.
     * @example
     * // Delete one ReviewsCursos
     * const ReviewsCursos = await prisma.reviewsCursos.delete({
     *   where: {
     *     // ... filter to delete one ReviewsCursos
     *   }
     * })
     * 
     */
    delete<T extends reviewsCursosDeleteArgs>(args: SelectSubset<T, reviewsCursosDeleteArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewsCursos.
     * @param {reviewsCursosUpdateArgs} args - Arguments to update one ReviewsCursos.
     * @example
     * // Update one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewsCursosUpdateArgs>(args: SelectSubset<T, reviewsCursosUpdateArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewsCursos.
     * @param {reviewsCursosDeleteManyArgs} args - Arguments to filter ReviewsCursos to delete.
     * @example
     * // Delete a few ReviewsCursos
     * const { count } = await prisma.reviewsCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewsCursosDeleteManyArgs>(args?: SelectSubset<T, reviewsCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewsCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewsCursosUpdateManyArgs>(args: SelectSubset<T, reviewsCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewsCursos and returns the data updated in the database.
     * @param {reviewsCursosUpdateManyAndReturnArgs} args - Arguments to update many ReviewsCursos.
     * @example
     * // Update many ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewsCursos and only return the `id`
     * const reviewsCursosWithIdOnly = await prisma.reviewsCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewsCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewsCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewsCursos.
     * @param {reviewsCursosUpsertArgs} args - Arguments to update or create a ReviewsCursos.
     * @example
     * // Update or create a ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.upsert({
     *   create: {
     *     // ... data to create a ReviewsCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewsCursos we want to update
     *   }
     * })
     */
    upsert<T extends reviewsCursosUpsertArgs>(args: SelectSubset<T, reviewsCursosUpsertArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewsCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosCountArgs} args - Arguments to filter ReviewsCursos to count.
     * @example
     * // Count the number of ReviewsCursos
     * const count = await prisma.reviewsCursos.count({
     *   where: {
     *     // ... the filter for the ReviewsCursos we want to count
     *   }
     * })
    **/
    count<T extends reviewsCursosCountArgs>(
      args?: Subset<T, reviewsCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewsCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsCursosAggregateArgs>(args: Subset<T, ReviewsCursosAggregateArgs>): Prisma.PrismaPromise<GetReviewsCursosAggregateType<T>>

    /**
     * Group by ReviewsCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewsCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewsCursosGroupByArgs['orderBy'] }
        : { orderBy?: reviewsCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewsCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviewsCursos model
   */
  readonly fields: reviewsCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviewsCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewsCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curso<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends usuariosEstudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantesDefaultArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviewsCursos model
   */
  interface reviewsCursosFieldRefs {
    readonly id: FieldRef<"reviewsCursos", 'String'>
    readonly cursoId: FieldRef<"reviewsCursos", 'String'>
    readonly rating: FieldRef<"reviewsCursos", 'Int'>
    readonly comentario: FieldRef<"reviewsCursos", 'String'>
    readonly creadoEn: FieldRef<"reviewsCursos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"reviewsCursos", 'DateTime'>
    readonly usuariosEstudiantesId: FieldRef<"reviewsCursos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * reviewsCursos findUnique
   */
  export type reviewsCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where: reviewsCursosWhereUniqueInput
  }

  /**
   * reviewsCursos findUniqueOrThrow
   */
  export type reviewsCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where: reviewsCursosWhereUniqueInput
  }

  /**
   * reviewsCursos findFirst
   */
  export type reviewsCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where?: reviewsCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewsCursos to fetch.
     */
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviewsCursos.
     */
    cursor?: reviewsCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewsCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewsCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviewsCursos.
     */
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * reviewsCursos findFirstOrThrow
   */
  export type reviewsCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where?: reviewsCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewsCursos to fetch.
     */
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviewsCursos.
     */
    cursor?: reviewsCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewsCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewsCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviewsCursos.
     */
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * reviewsCursos findMany
   */
  export type reviewsCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where?: reviewsCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewsCursos to fetch.
     */
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviewsCursos.
     */
    cursor?: reviewsCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewsCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewsCursos.
     */
    skip?: number
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * reviewsCursos create
   */
  export type reviewsCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a reviewsCursos.
     */
    data: XOR<reviewsCursosCreateInput, reviewsCursosUncheckedCreateInput>
  }

  /**
   * reviewsCursos createMany
   */
  export type reviewsCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviewsCursos.
     */
    data: reviewsCursosCreateManyInput | reviewsCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviewsCursos createManyAndReturn
   */
  export type reviewsCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * The data used to create many reviewsCursos.
     */
    data: reviewsCursosCreateManyInput | reviewsCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviewsCursos update
   */
  export type reviewsCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a reviewsCursos.
     */
    data: XOR<reviewsCursosUpdateInput, reviewsCursosUncheckedUpdateInput>
    /**
     * Choose, which reviewsCursos to update.
     */
    where: reviewsCursosWhereUniqueInput
  }

  /**
   * reviewsCursos updateMany
   */
  export type reviewsCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviewsCursos.
     */
    data: XOR<reviewsCursosUpdateManyMutationInput, reviewsCursosUncheckedUpdateManyInput>
    /**
     * Filter which reviewsCursos to update
     */
    where?: reviewsCursosWhereInput
    /**
     * Limit how many reviewsCursos to update.
     */
    limit?: number
  }

  /**
   * reviewsCursos updateManyAndReturn
   */
  export type reviewsCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * The data used to update reviewsCursos.
     */
    data: XOR<reviewsCursosUpdateManyMutationInput, reviewsCursosUncheckedUpdateManyInput>
    /**
     * Filter which reviewsCursos to update
     */
    where?: reviewsCursosWhereInput
    /**
     * Limit how many reviewsCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviewsCursos upsert
   */
  export type reviewsCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the reviewsCursos to update in case it exists.
     */
    where: reviewsCursosWhereUniqueInput
    /**
     * In case the reviewsCursos found by the `where` argument doesn't exist, create a new reviewsCursos with this data.
     */
    create: XOR<reviewsCursosCreateInput, reviewsCursosUncheckedCreateInput>
    /**
     * In case the reviewsCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewsCursosUpdateInput, reviewsCursosUncheckedUpdateInput>
  }

  /**
   * reviewsCursos delete
   */
  export type reviewsCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter which reviewsCursos to delete.
     */
    where: reviewsCursosWhereUniqueInput
  }

  /**
   * reviewsCursos deleteMany
   */
  export type reviewsCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviewsCursos to delete
     */
    where?: reviewsCursosWhereInput
    /**
     * Limit how many reviewsCursos to delete.
     */
    limit?: number
  }

  /**
   * reviewsCursos without action
   */
  export type reviewsCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
  }


  /**
   * Model edicionesCursos
   */

  export type AggregateEdicionesCursos = {
    _count: EdicionesCursosCountAggregateOutputType | null
    _avg: EdicionesCursosAvgAggregateOutputType | null
    _sum: EdicionesCursosSumAggregateOutputType | null
    _min: EdicionesCursosMinAggregateOutputType | null
    _max: EdicionesCursosMaxAggregateOutputType | null
  }

  export type EdicionesCursosAvgAggregateOutputType = {
    notaMaxima: number | null
    notaMinima: number | null
  }

  export type EdicionesCursosSumAggregateOutputType = {
    notaMaxima: number | null
    notaMinima: number | null
  }

  export type EdicionesCursosMinAggregateOutputType = {
    id: string | null
    codigo: string | null
    cursoId: string | null
    descripcion: string | null
    estado: $Enums.EdicionEstado | null
    fechaFin: Date | null
    fechaInicio: Date | null
    notaMaxima: number | null
    notaMinima: number | null
    urlWhatsapp: string | null
    vigente: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    docenteId: string | null
  }

  export type EdicionesCursosMaxAggregateOutputType = {
    id: string | null
    codigo: string | null
    cursoId: string | null
    descripcion: string | null
    estado: $Enums.EdicionEstado | null
    fechaFin: Date | null
    fechaInicio: Date | null
    notaMaxima: number | null
    notaMinima: number | null
    urlWhatsapp: string | null
    vigente: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    docenteId: string | null
  }

  export type EdicionesCursosCountAggregateOutputType = {
    id: number
    codigo: number
    cursoId: number
    descripcion: number
    estado: number
    fechaFin: number
    fechaInicio: number
    notaMaxima: number
    notaMinima: number
    urlWhatsapp: number
    vigente: number
    creadoEn: number
    actualizadoEn: number
    docenteId: number
    _all: number
  }


  export type EdicionesCursosAvgAggregateInputType = {
    notaMaxima?: true
    notaMinima?: true
  }

  export type EdicionesCursosSumAggregateInputType = {
    notaMaxima?: true
    notaMinima?: true
  }

  export type EdicionesCursosMinAggregateInputType = {
    id?: true
    codigo?: true
    cursoId?: true
    descripcion?: true
    estado?: true
    fechaFin?: true
    fechaInicio?: true
    notaMaxima?: true
    notaMinima?: true
    urlWhatsapp?: true
    vigente?: true
    creadoEn?: true
    actualizadoEn?: true
    docenteId?: true
  }

  export type EdicionesCursosMaxAggregateInputType = {
    id?: true
    codigo?: true
    cursoId?: true
    descripcion?: true
    estado?: true
    fechaFin?: true
    fechaInicio?: true
    notaMaxima?: true
    notaMinima?: true
    urlWhatsapp?: true
    vigente?: true
    creadoEn?: true
    actualizadoEn?: true
    docenteId?: true
  }

  export type EdicionesCursosCountAggregateInputType = {
    id?: true
    codigo?: true
    cursoId?: true
    descripcion?: true
    estado?: true
    fechaFin?: true
    fechaInicio?: true
    notaMaxima?: true
    notaMinima?: true
    urlWhatsapp?: true
    vigente?: true
    creadoEn?: true
    actualizadoEn?: true
    docenteId?: true
    _all?: true
  }

  export type EdicionesCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which edicionesCursos to aggregate.
     */
    where?: edicionesCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edicionesCursos to fetch.
     */
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: edicionesCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edicionesCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edicionesCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned edicionesCursos
    **/
    _count?: true | EdicionesCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EdicionesCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EdicionesCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EdicionesCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EdicionesCursosMaxAggregateInputType
  }

  export type GetEdicionesCursosAggregateType<T extends EdicionesCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateEdicionesCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdicionesCursos[P]>
      : GetScalarType<T[P], AggregateEdicionesCursos[P]>
  }




  export type edicionesCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: edicionesCursosWhereInput
    orderBy?: edicionesCursosOrderByWithAggregationInput | edicionesCursosOrderByWithAggregationInput[]
    by: EdicionesCursosScalarFieldEnum[] | EdicionesCursosScalarFieldEnum
    having?: edicionesCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EdicionesCursosCountAggregateInputType | true
    _avg?: EdicionesCursosAvgAggregateInputType
    _sum?: EdicionesCursosSumAggregateInputType
    _min?: EdicionesCursosMinAggregateInputType
    _max?: EdicionesCursosMaxAggregateInputType
  }

  export type EdicionesCursosGroupByOutputType = {
    id: string
    codigo: string
    cursoId: string
    descripcion: string | null
    estado: $Enums.EdicionEstado
    fechaFin: Date
    fechaInicio: Date
    notaMaxima: number
    notaMinima: number
    urlWhatsapp: string | null
    vigente: boolean
    creadoEn: Date
    actualizadoEn: Date
    docenteId: string
    _count: EdicionesCursosCountAggregateOutputType | null
    _avg: EdicionesCursosAvgAggregateOutputType | null
    _sum: EdicionesCursosSumAggregateOutputType | null
    _min: EdicionesCursosMinAggregateOutputType | null
    _max: EdicionesCursosMaxAggregateOutputType | null
  }

  type GetEdicionesCursosGroupByPayload<T extends edicionesCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EdicionesCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EdicionesCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EdicionesCursosGroupByOutputType[P]>
            : GetScalarType<T[P], EdicionesCursosGroupByOutputType[P]>
        }
      >
    >


  export type edicionesCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    cursoId?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    urlWhatsapp?: boolean
    vigente?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docenteId?: boolean
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
    compras?: boolean | edicionesCursos$comprasArgs<ExtArgs>
    certificados?: boolean | edicionesCursos$certificadosArgs<ExtArgs>
    clases?: boolean | edicionesCursos$clasesArgs<ExtArgs>
    examenes?: boolean | edicionesCursos$examenesArgs<ExtArgs>
    inscripciones?: boolean | edicionesCursos$inscripcionesArgs<ExtArgs>
    precios?: boolean | edicionesCursos$preciosArgs<ExtArgs>
    _count?: boolean | EdicionesCursosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edicionesCursos"]>

  export type edicionesCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    cursoId?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    urlWhatsapp?: boolean
    vigente?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docenteId?: boolean
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edicionesCursos"]>

  export type edicionesCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    cursoId?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    urlWhatsapp?: boolean
    vigente?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docenteId?: boolean
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edicionesCursos"]>

  export type edicionesCursosSelectScalar = {
    id?: boolean
    codigo?: boolean
    cursoId?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    urlWhatsapp?: boolean
    vigente?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docenteId?: boolean
  }

  export type edicionesCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "cursoId" | "descripcion" | "estado" | "fechaFin" | "fechaInicio" | "notaMaxima" | "notaMinima" | "urlWhatsapp" | "vigente" | "creadoEn" | "actualizadoEn" | "docenteId", ExtArgs["result"]["edicionesCursos"]>
  export type edicionesCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
    compras?: boolean | edicionesCursos$comprasArgs<ExtArgs>
    certificados?: boolean | edicionesCursos$certificadosArgs<ExtArgs>
    clases?: boolean | edicionesCursos$clasesArgs<ExtArgs>
    examenes?: boolean | edicionesCursos$examenesArgs<ExtArgs>
    inscripciones?: boolean | edicionesCursos$inscripcionesArgs<ExtArgs>
    precios?: boolean | edicionesCursos$preciosArgs<ExtArgs>
    _count?: boolean | EdicionesCursosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type edicionesCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type edicionesCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }

  export type $edicionesCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "edicionesCursos"
    objects: {
      docente: Prisma.$docentePayload<ExtArgs>
      curso: Prisma.$cursosPayload<ExtArgs>
      compras: Prisma.$comprasPayload<ExtArgs>[]
      certificados: Prisma.$certificadosPayload<ExtArgs>[]
      clases: Prisma.$clasesPayload<ExtArgs>[]
      examenes: Prisma.$examenesPayload<ExtArgs>[]
      inscripciones: Prisma.$inscripcionesPayload<ExtArgs>[]
      precios: Prisma.$preciosCursosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigo: string
      cursoId: string
      descripcion: string | null
      estado: $Enums.EdicionEstado
      fechaFin: Date
      fechaInicio: Date
      notaMaxima: number
      notaMinima: number
      urlWhatsapp: string | null
      vigente: boolean
      creadoEn: Date
      actualizadoEn: Date
      docenteId: string
    }, ExtArgs["result"]["edicionesCursos"]>
    composites: {}
  }

  type edicionesCursosGetPayload<S extends boolean | null | undefined | edicionesCursosDefaultArgs> = $Result.GetResult<Prisma.$edicionesCursosPayload, S>

  type edicionesCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<edicionesCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EdicionesCursosCountAggregateInputType | true
    }

  export interface edicionesCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['edicionesCursos'], meta: { name: 'edicionesCursos' } }
    /**
     * Find zero or one EdicionesCursos that matches the filter.
     * @param {edicionesCursosFindUniqueArgs} args - Arguments to find a EdicionesCursos
     * @example
     * // Get one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends edicionesCursosFindUniqueArgs>(args: SelectSubset<T, edicionesCursosFindUniqueArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EdicionesCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {edicionesCursosFindUniqueOrThrowArgs} args - Arguments to find a EdicionesCursos
     * @example
     * // Get one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends edicionesCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, edicionesCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EdicionesCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosFindFirstArgs} args - Arguments to find a EdicionesCursos
     * @example
     * // Get one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends edicionesCursosFindFirstArgs>(args?: SelectSubset<T, edicionesCursosFindFirstArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EdicionesCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosFindFirstOrThrowArgs} args - Arguments to find a EdicionesCursos
     * @example
     * // Get one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends edicionesCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, edicionesCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EdicionesCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findMany()
     * 
     * // Get first 10 EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edicionesCursosWithIdOnly = await prisma.edicionesCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends edicionesCursosFindManyArgs>(args?: SelectSubset<T, edicionesCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EdicionesCursos.
     * @param {edicionesCursosCreateArgs} args - Arguments to create a EdicionesCursos.
     * @example
     * // Create one EdicionesCursos
     * const EdicionesCursos = await prisma.edicionesCursos.create({
     *   data: {
     *     // ... data to create a EdicionesCursos
     *   }
     * })
     * 
     */
    create<T extends edicionesCursosCreateArgs>(args: SelectSubset<T, edicionesCursosCreateArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EdicionesCursos.
     * @param {edicionesCursosCreateManyArgs} args - Arguments to create many EdicionesCursos.
     * @example
     * // Create many EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends edicionesCursosCreateManyArgs>(args?: SelectSubset<T, edicionesCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EdicionesCursos and returns the data saved in the database.
     * @param {edicionesCursosCreateManyAndReturnArgs} args - Arguments to create many EdicionesCursos.
     * @example
     * // Create many EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EdicionesCursos and only return the `id`
     * const edicionesCursosWithIdOnly = await prisma.edicionesCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends edicionesCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, edicionesCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EdicionesCursos.
     * @param {edicionesCursosDeleteArgs} args - Arguments to delete one EdicionesCursos.
     * @example
     * // Delete one EdicionesCursos
     * const EdicionesCursos = await prisma.edicionesCursos.delete({
     *   where: {
     *     // ... filter to delete one EdicionesCursos
     *   }
     * })
     * 
     */
    delete<T extends edicionesCursosDeleteArgs>(args: SelectSubset<T, edicionesCursosDeleteArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EdicionesCursos.
     * @param {edicionesCursosUpdateArgs} args - Arguments to update one EdicionesCursos.
     * @example
     * // Update one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends edicionesCursosUpdateArgs>(args: SelectSubset<T, edicionesCursosUpdateArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EdicionesCursos.
     * @param {edicionesCursosDeleteManyArgs} args - Arguments to filter EdicionesCursos to delete.
     * @example
     * // Delete a few EdicionesCursos
     * const { count } = await prisma.edicionesCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends edicionesCursosDeleteManyArgs>(args?: SelectSubset<T, edicionesCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EdicionesCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends edicionesCursosUpdateManyArgs>(args: SelectSubset<T, edicionesCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EdicionesCursos and returns the data updated in the database.
     * @param {edicionesCursosUpdateManyAndReturnArgs} args - Arguments to update many EdicionesCursos.
     * @example
     * // Update many EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EdicionesCursos and only return the `id`
     * const edicionesCursosWithIdOnly = await prisma.edicionesCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends edicionesCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, edicionesCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EdicionesCursos.
     * @param {edicionesCursosUpsertArgs} args - Arguments to update or create a EdicionesCursos.
     * @example
     * // Update or create a EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.upsert({
     *   create: {
     *     // ... data to create a EdicionesCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EdicionesCursos we want to update
     *   }
     * })
     */
    upsert<T extends edicionesCursosUpsertArgs>(args: SelectSubset<T, edicionesCursosUpsertArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EdicionesCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosCountArgs} args - Arguments to filter EdicionesCursos to count.
     * @example
     * // Count the number of EdicionesCursos
     * const count = await prisma.edicionesCursos.count({
     *   where: {
     *     // ... the filter for the EdicionesCursos we want to count
     *   }
     * })
    **/
    count<T extends edicionesCursosCountArgs>(
      args?: Subset<T, edicionesCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EdicionesCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EdicionesCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdicionesCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EdicionesCursosAggregateArgs>(args: Subset<T, EdicionesCursosAggregateArgs>): Prisma.PrismaPromise<GetEdicionesCursosAggregateType<T>>

    /**
     * Group by EdicionesCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends edicionesCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: edicionesCursosGroupByArgs['orderBy'] }
        : { orderBy?: edicionesCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, edicionesCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdicionesCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the edicionesCursos model
   */
  readonly fields: edicionesCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for edicionesCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__edicionesCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    docente<T extends docenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, docenteDefaultArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    curso<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    compras<T extends edicionesCursos$comprasArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$comprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificados<T extends edicionesCursos$certificadosArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$certificadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clases<T extends edicionesCursos$clasesArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$clasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examenes<T extends edicionesCursos$examenesArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$examenesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inscripciones<T extends edicionesCursos$inscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$inscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    precios<T extends edicionesCursos$preciosArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$preciosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the edicionesCursos model
   */
  interface edicionesCursosFieldRefs {
    readonly id: FieldRef<"edicionesCursos", 'String'>
    readonly codigo: FieldRef<"edicionesCursos", 'String'>
    readonly cursoId: FieldRef<"edicionesCursos", 'String'>
    readonly descripcion: FieldRef<"edicionesCursos", 'String'>
    readonly estado: FieldRef<"edicionesCursos", 'EdicionEstado'>
    readonly fechaFin: FieldRef<"edicionesCursos", 'DateTime'>
    readonly fechaInicio: FieldRef<"edicionesCursos", 'DateTime'>
    readonly notaMaxima: FieldRef<"edicionesCursos", 'Float'>
    readonly notaMinima: FieldRef<"edicionesCursos", 'Float'>
    readonly urlWhatsapp: FieldRef<"edicionesCursos", 'String'>
    readonly vigente: FieldRef<"edicionesCursos", 'Boolean'>
    readonly creadoEn: FieldRef<"edicionesCursos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"edicionesCursos", 'DateTime'>
    readonly docenteId: FieldRef<"edicionesCursos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * edicionesCursos findUnique
   */
  export type edicionesCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where: edicionesCursosWhereUniqueInput
  }

  /**
   * edicionesCursos findUniqueOrThrow
   */
  export type edicionesCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where: edicionesCursosWhereUniqueInput
  }

  /**
   * edicionesCursos findFirst
   */
  export type edicionesCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where?: edicionesCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edicionesCursos to fetch.
     */
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edicionesCursos.
     */
    cursor?: edicionesCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edicionesCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edicionesCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edicionesCursos.
     */
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * edicionesCursos findFirstOrThrow
   */
  export type edicionesCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where?: edicionesCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edicionesCursos to fetch.
     */
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edicionesCursos.
     */
    cursor?: edicionesCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edicionesCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edicionesCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edicionesCursos.
     */
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * edicionesCursos findMany
   */
  export type edicionesCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where?: edicionesCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edicionesCursos to fetch.
     */
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing edicionesCursos.
     */
    cursor?: edicionesCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edicionesCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edicionesCursos.
     */
    skip?: number
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * edicionesCursos create
   */
  export type edicionesCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a edicionesCursos.
     */
    data: XOR<edicionesCursosCreateInput, edicionesCursosUncheckedCreateInput>
  }

  /**
   * edicionesCursos createMany
   */
  export type edicionesCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many edicionesCursos.
     */
    data: edicionesCursosCreateManyInput | edicionesCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * edicionesCursos createManyAndReturn
   */
  export type edicionesCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * The data used to create many edicionesCursos.
     */
    data: edicionesCursosCreateManyInput | edicionesCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * edicionesCursos update
   */
  export type edicionesCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a edicionesCursos.
     */
    data: XOR<edicionesCursosUpdateInput, edicionesCursosUncheckedUpdateInput>
    /**
     * Choose, which edicionesCursos to update.
     */
    where: edicionesCursosWhereUniqueInput
  }

  /**
   * edicionesCursos updateMany
   */
  export type edicionesCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update edicionesCursos.
     */
    data: XOR<edicionesCursosUpdateManyMutationInput, edicionesCursosUncheckedUpdateManyInput>
    /**
     * Filter which edicionesCursos to update
     */
    where?: edicionesCursosWhereInput
    /**
     * Limit how many edicionesCursos to update.
     */
    limit?: number
  }

  /**
   * edicionesCursos updateManyAndReturn
   */
  export type edicionesCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * The data used to update edicionesCursos.
     */
    data: XOR<edicionesCursosUpdateManyMutationInput, edicionesCursosUncheckedUpdateManyInput>
    /**
     * Filter which edicionesCursos to update
     */
    where?: edicionesCursosWhereInput
    /**
     * Limit how many edicionesCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * edicionesCursos upsert
   */
  export type edicionesCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the edicionesCursos to update in case it exists.
     */
    where: edicionesCursosWhereUniqueInput
    /**
     * In case the edicionesCursos found by the `where` argument doesn't exist, create a new edicionesCursos with this data.
     */
    create: XOR<edicionesCursosCreateInput, edicionesCursosUncheckedCreateInput>
    /**
     * In case the edicionesCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<edicionesCursosUpdateInput, edicionesCursosUncheckedUpdateInput>
  }

  /**
   * edicionesCursos delete
   */
  export type edicionesCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter which edicionesCursos to delete.
     */
    where: edicionesCursosWhereUniqueInput
  }

  /**
   * edicionesCursos deleteMany
   */
  export type edicionesCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which edicionesCursos to delete
     */
    where?: edicionesCursosWhereInput
    /**
     * Limit how many edicionesCursos to delete.
     */
    limit?: number
  }

  /**
   * edicionesCursos.compras
   */
  export type edicionesCursos$comprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    where?: comprasWhereInput
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    cursor?: comprasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * edicionesCursos.certificados
   */
  export type edicionesCursos$certificadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    where?: certificadosWhereInput
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    cursor?: certificadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * edicionesCursos.clases
   */
  export type edicionesCursos$clasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    where?: clasesWhereInput
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    cursor?: clasesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClasesScalarFieldEnum | ClasesScalarFieldEnum[]
  }

  /**
   * edicionesCursos.examenes
   */
  export type edicionesCursos$examenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    where?: examenesWhereInput
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    cursor?: examenesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamenesScalarFieldEnum | ExamenesScalarFieldEnum[]
  }

  /**
   * edicionesCursos.inscripciones
   */
  export type edicionesCursos$inscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    where?: inscripcionesWhereInput
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    cursor?: inscripcionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * edicionesCursos.precios
   */
  export type edicionesCursos$preciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    where?: preciosCursosWhereInput
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    cursor?: preciosCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreciosCursosScalarFieldEnum | PreciosCursosScalarFieldEnum[]
  }

  /**
   * edicionesCursos without action
   */
  export type edicionesCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
  }


  /**
   * Model beneficiosCursos
   */

  export type AggregateBeneficiosCursos = {
    _count: BeneficiosCursosCountAggregateOutputType | null
    _avg: BeneficiosCursosAvgAggregateOutputType | null
    _sum: BeneficiosCursosSumAggregateOutputType | null
    _min: BeneficiosCursosMinAggregateOutputType | null
    _max: BeneficiosCursosMaxAggregateOutputType | null
  }

  export type BeneficiosCursosAvgAggregateOutputType = {
    orden: number | null
  }

  export type BeneficiosCursosSumAggregateOutputType = {
    orden: number | null
  }

  export type BeneficiosCursosMinAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type BeneficiosCursosMaxAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type BeneficiosCursosCountAggregateOutputType = {
    id: number
    cursoId: number
    descripcion: number
    orden: number
    creadoEn: number
    _all: number
  }


  export type BeneficiosCursosAvgAggregateInputType = {
    orden?: true
  }

  export type BeneficiosCursosSumAggregateInputType = {
    orden?: true
  }

  export type BeneficiosCursosMinAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type BeneficiosCursosMaxAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type BeneficiosCursosCountAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
    _all?: true
  }

  export type BeneficiosCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which beneficiosCursos to aggregate.
     */
    where?: beneficiosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficiosCursos to fetch.
     */
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: beneficiosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficiosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficiosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned beneficiosCursos
    **/
    _count?: true | BeneficiosCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BeneficiosCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BeneficiosCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeneficiosCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeneficiosCursosMaxAggregateInputType
  }

  export type GetBeneficiosCursosAggregateType<T extends BeneficiosCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateBeneficiosCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeneficiosCursos[P]>
      : GetScalarType<T[P], AggregateBeneficiosCursos[P]>
  }




  export type beneficiosCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: beneficiosCursosWhereInput
    orderBy?: beneficiosCursosOrderByWithAggregationInput | beneficiosCursosOrderByWithAggregationInput[]
    by: BeneficiosCursosScalarFieldEnum[] | BeneficiosCursosScalarFieldEnum
    having?: beneficiosCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeneficiosCursosCountAggregateInputType | true
    _avg?: BeneficiosCursosAvgAggregateInputType
    _sum?: BeneficiosCursosSumAggregateInputType
    _min?: BeneficiosCursosMinAggregateInputType
    _max?: BeneficiosCursosMaxAggregateInputType
  }

  export type BeneficiosCursosGroupByOutputType = {
    id: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn: Date
    _count: BeneficiosCursosCountAggregateOutputType | null
    _avg: BeneficiosCursosAvgAggregateOutputType | null
    _sum: BeneficiosCursosSumAggregateOutputType | null
    _min: BeneficiosCursosMinAggregateOutputType | null
    _max: BeneficiosCursosMaxAggregateOutputType | null
  }

  type GetBeneficiosCursosGroupByPayload<T extends beneficiosCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeneficiosCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeneficiosCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeneficiosCursosGroupByOutputType[P]>
            : GetScalarType<T[P], BeneficiosCursosGroupByOutputType[P]>
        }
      >
    >


  export type beneficiosCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiosCursos"]>

  export type beneficiosCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiosCursos"]>

  export type beneficiosCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiosCursos"]>

  export type beneficiosCursosSelectScalar = {
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
  }

  export type beneficiosCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cursoId" | "descripcion" | "orden" | "creadoEn", ExtArgs["result"]["beneficiosCursos"]>
  export type beneficiosCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type beneficiosCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type beneficiosCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }

  export type $beneficiosCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "beneficiosCursos"
    objects: {
      curso: Prisma.$cursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cursoId: string
      descripcion: string
      orden: number
      creadoEn: Date
    }, ExtArgs["result"]["beneficiosCursos"]>
    composites: {}
  }

  type beneficiosCursosGetPayload<S extends boolean | null | undefined | beneficiosCursosDefaultArgs> = $Result.GetResult<Prisma.$beneficiosCursosPayload, S>

  type beneficiosCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<beneficiosCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BeneficiosCursosCountAggregateInputType | true
    }

  export interface beneficiosCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['beneficiosCursos'], meta: { name: 'beneficiosCursos' } }
    /**
     * Find zero or one BeneficiosCursos that matches the filter.
     * @param {beneficiosCursosFindUniqueArgs} args - Arguments to find a BeneficiosCursos
     * @example
     * // Get one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends beneficiosCursosFindUniqueArgs>(args: SelectSubset<T, beneficiosCursosFindUniqueArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BeneficiosCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {beneficiosCursosFindUniqueOrThrowArgs} args - Arguments to find a BeneficiosCursos
     * @example
     * // Get one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends beneficiosCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, beneficiosCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BeneficiosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosFindFirstArgs} args - Arguments to find a BeneficiosCursos
     * @example
     * // Get one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends beneficiosCursosFindFirstArgs>(args?: SelectSubset<T, beneficiosCursosFindFirstArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BeneficiosCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosFindFirstOrThrowArgs} args - Arguments to find a BeneficiosCursos
     * @example
     * // Get one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends beneficiosCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, beneficiosCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BeneficiosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findMany()
     * 
     * // Get first 10 BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beneficiosCursosWithIdOnly = await prisma.beneficiosCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends beneficiosCursosFindManyArgs>(args?: SelectSubset<T, beneficiosCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BeneficiosCursos.
     * @param {beneficiosCursosCreateArgs} args - Arguments to create a BeneficiosCursos.
     * @example
     * // Create one BeneficiosCursos
     * const BeneficiosCursos = await prisma.beneficiosCursos.create({
     *   data: {
     *     // ... data to create a BeneficiosCursos
     *   }
     * })
     * 
     */
    create<T extends beneficiosCursosCreateArgs>(args: SelectSubset<T, beneficiosCursosCreateArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BeneficiosCursos.
     * @param {beneficiosCursosCreateManyArgs} args - Arguments to create many BeneficiosCursos.
     * @example
     * // Create many BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends beneficiosCursosCreateManyArgs>(args?: SelectSubset<T, beneficiosCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BeneficiosCursos and returns the data saved in the database.
     * @param {beneficiosCursosCreateManyAndReturnArgs} args - Arguments to create many BeneficiosCursos.
     * @example
     * // Create many BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BeneficiosCursos and only return the `id`
     * const beneficiosCursosWithIdOnly = await prisma.beneficiosCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends beneficiosCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, beneficiosCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BeneficiosCursos.
     * @param {beneficiosCursosDeleteArgs} args - Arguments to delete one BeneficiosCursos.
     * @example
     * // Delete one BeneficiosCursos
     * const BeneficiosCursos = await prisma.beneficiosCursos.delete({
     *   where: {
     *     // ... filter to delete one BeneficiosCursos
     *   }
     * })
     * 
     */
    delete<T extends beneficiosCursosDeleteArgs>(args: SelectSubset<T, beneficiosCursosDeleteArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BeneficiosCursos.
     * @param {beneficiosCursosUpdateArgs} args - Arguments to update one BeneficiosCursos.
     * @example
     * // Update one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends beneficiosCursosUpdateArgs>(args: SelectSubset<T, beneficiosCursosUpdateArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BeneficiosCursos.
     * @param {beneficiosCursosDeleteManyArgs} args - Arguments to filter BeneficiosCursos to delete.
     * @example
     * // Delete a few BeneficiosCursos
     * const { count } = await prisma.beneficiosCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends beneficiosCursosDeleteManyArgs>(args?: SelectSubset<T, beneficiosCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BeneficiosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends beneficiosCursosUpdateManyArgs>(args: SelectSubset<T, beneficiosCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BeneficiosCursos and returns the data updated in the database.
     * @param {beneficiosCursosUpdateManyAndReturnArgs} args - Arguments to update many BeneficiosCursos.
     * @example
     * // Update many BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BeneficiosCursos and only return the `id`
     * const beneficiosCursosWithIdOnly = await prisma.beneficiosCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends beneficiosCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, beneficiosCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BeneficiosCursos.
     * @param {beneficiosCursosUpsertArgs} args - Arguments to update or create a BeneficiosCursos.
     * @example
     * // Update or create a BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.upsert({
     *   create: {
     *     // ... data to create a BeneficiosCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BeneficiosCursos we want to update
     *   }
     * })
     */
    upsert<T extends beneficiosCursosUpsertArgs>(args: SelectSubset<T, beneficiosCursosUpsertArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BeneficiosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosCountArgs} args - Arguments to filter BeneficiosCursos to count.
     * @example
     * // Count the number of BeneficiosCursos
     * const count = await prisma.beneficiosCursos.count({
     *   where: {
     *     // ... the filter for the BeneficiosCursos we want to count
     *   }
     * })
    **/
    count<T extends beneficiosCursosCountArgs>(
      args?: Subset<T, beneficiosCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeneficiosCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BeneficiosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiosCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeneficiosCursosAggregateArgs>(args: Subset<T, BeneficiosCursosAggregateArgs>): Prisma.PrismaPromise<GetBeneficiosCursosAggregateType<T>>

    /**
     * Group by BeneficiosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends beneficiosCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: beneficiosCursosGroupByArgs['orderBy'] }
        : { orderBy?: beneficiosCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, beneficiosCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeneficiosCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the beneficiosCursos model
   */
  readonly fields: beneficiosCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for beneficiosCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__beneficiosCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curso<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the beneficiosCursos model
   */
  interface beneficiosCursosFieldRefs {
    readonly id: FieldRef<"beneficiosCursos", 'String'>
    readonly cursoId: FieldRef<"beneficiosCursos", 'String'>
    readonly descripcion: FieldRef<"beneficiosCursos", 'String'>
    readonly orden: FieldRef<"beneficiosCursos", 'Int'>
    readonly creadoEn: FieldRef<"beneficiosCursos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * beneficiosCursos findUnique
   */
  export type beneficiosCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where: beneficiosCursosWhereUniqueInput
  }

  /**
   * beneficiosCursos findUniqueOrThrow
   */
  export type beneficiosCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where: beneficiosCursosWhereUniqueInput
  }

  /**
   * beneficiosCursos findFirst
   */
  export type beneficiosCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where?: beneficiosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficiosCursos to fetch.
     */
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beneficiosCursos.
     */
    cursor?: beneficiosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficiosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficiosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beneficiosCursos.
     */
    distinct?: BeneficiosCursosScalarFieldEnum | BeneficiosCursosScalarFieldEnum[]
  }

  /**
   * beneficiosCursos findFirstOrThrow
   */
  export type beneficiosCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where?: beneficiosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficiosCursos to fetch.
     */
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beneficiosCursos.
     */
    cursor?: beneficiosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficiosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficiosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beneficiosCursos.
     */
    distinct?: BeneficiosCursosScalarFieldEnum | BeneficiosCursosScalarFieldEnum[]
  }

  /**
   * beneficiosCursos findMany
   */
  export type beneficiosCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where?: beneficiosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficiosCursos to fetch.
     */
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing beneficiosCursos.
     */
    cursor?: beneficiosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficiosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficiosCursos.
     */
    skip?: number
    distinct?: BeneficiosCursosScalarFieldEnum | BeneficiosCursosScalarFieldEnum[]
  }

  /**
   * beneficiosCursos create
   */
  export type beneficiosCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a beneficiosCursos.
     */
    data: XOR<beneficiosCursosCreateInput, beneficiosCursosUncheckedCreateInput>
  }

  /**
   * beneficiosCursos createMany
   */
  export type beneficiosCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many beneficiosCursos.
     */
    data: beneficiosCursosCreateManyInput | beneficiosCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * beneficiosCursos createManyAndReturn
   */
  export type beneficiosCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * The data used to create many beneficiosCursos.
     */
    data: beneficiosCursosCreateManyInput | beneficiosCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * beneficiosCursos update
   */
  export type beneficiosCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a beneficiosCursos.
     */
    data: XOR<beneficiosCursosUpdateInput, beneficiosCursosUncheckedUpdateInput>
    /**
     * Choose, which beneficiosCursos to update.
     */
    where: beneficiosCursosWhereUniqueInput
  }

  /**
   * beneficiosCursos updateMany
   */
  export type beneficiosCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update beneficiosCursos.
     */
    data: XOR<beneficiosCursosUpdateManyMutationInput, beneficiosCursosUncheckedUpdateManyInput>
    /**
     * Filter which beneficiosCursos to update
     */
    where?: beneficiosCursosWhereInput
    /**
     * Limit how many beneficiosCursos to update.
     */
    limit?: number
  }

  /**
   * beneficiosCursos updateManyAndReturn
   */
  export type beneficiosCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * The data used to update beneficiosCursos.
     */
    data: XOR<beneficiosCursosUpdateManyMutationInput, beneficiosCursosUncheckedUpdateManyInput>
    /**
     * Filter which beneficiosCursos to update
     */
    where?: beneficiosCursosWhereInput
    /**
     * Limit how many beneficiosCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * beneficiosCursos upsert
   */
  export type beneficiosCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the beneficiosCursos to update in case it exists.
     */
    where: beneficiosCursosWhereUniqueInput
    /**
     * In case the beneficiosCursos found by the `where` argument doesn't exist, create a new beneficiosCursos with this data.
     */
    create: XOR<beneficiosCursosCreateInput, beneficiosCursosUncheckedCreateInput>
    /**
     * In case the beneficiosCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<beneficiosCursosUpdateInput, beneficiosCursosUncheckedUpdateInput>
  }

  /**
   * beneficiosCursos delete
   */
  export type beneficiosCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter which beneficiosCursos to delete.
     */
    where: beneficiosCursosWhereUniqueInput
  }

  /**
   * beneficiosCursos deleteMany
   */
  export type beneficiosCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which beneficiosCursos to delete
     */
    where?: beneficiosCursosWhereInput
    /**
     * Limit how many beneficiosCursos to delete.
     */
    limit?: number
  }

  /**
   * beneficiosCursos without action
   */
  export type beneficiosCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
  }


  /**
   * Model objetivosCursos
   */

  export type AggregateObjetivosCursos = {
    _count: ObjetivosCursosCountAggregateOutputType | null
    _avg: ObjetivosCursosAvgAggregateOutputType | null
    _sum: ObjetivosCursosSumAggregateOutputType | null
    _min: ObjetivosCursosMinAggregateOutputType | null
    _max: ObjetivosCursosMaxAggregateOutputType | null
  }

  export type ObjetivosCursosAvgAggregateOutputType = {
    orden: number | null
  }

  export type ObjetivosCursosSumAggregateOutputType = {
    orden: number | null
  }

  export type ObjetivosCursosMinAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type ObjetivosCursosMaxAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type ObjetivosCursosCountAggregateOutputType = {
    id: number
    cursoId: number
    descripcion: number
    orden: number
    creadoEn: number
    _all: number
  }


  export type ObjetivosCursosAvgAggregateInputType = {
    orden?: true
  }

  export type ObjetivosCursosSumAggregateInputType = {
    orden?: true
  }

  export type ObjetivosCursosMinAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type ObjetivosCursosMaxAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type ObjetivosCursosCountAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
    _all?: true
  }

  export type ObjetivosCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which objetivosCursos to aggregate.
     */
    where?: objetivosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetivosCursos to fetch.
     */
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: objetivosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetivosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetivosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned objetivosCursos
    **/
    _count?: true | ObjetivosCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjetivosCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjetivosCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjetivosCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjetivosCursosMaxAggregateInputType
  }

  export type GetObjetivosCursosAggregateType<T extends ObjetivosCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateObjetivosCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjetivosCursos[P]>
      : GetScalarType<T[P], AggregateObjetivosCursos[P]>
  }




  export type objetivosCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: objetivosCursosWhereInput
    orderBy?: objetivosCursosOrderByWithAggregationInput | objetivosCursosOrderByWithAggregationInput[]
    by: ObjetivosCursosScalarFieldEnum[] | ObjetivosCursosScalarFieldEnum
    having?: objetivosCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjetivosCursosCountAggregateInputType | true
    _avg?: ObjetivosCursosAvgAggregateInputType
    _sum?: ObjetivosCursosSumAggregateInputType
    _min?: ObjetivosCursosMinAggregateInputType
    _max?: ObjetivosCursosMaxAggregateInputType
  }

  export type ObjetivosCursosGroupByOutputType = {
    id: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn: Date
    _count: ObjetivosCursosCountAggregateOutputType | null
    _avg: ObjetivosCursosAvgAggregateOutputType | null
    _sum: ObjetivosCursosSumAggregateOutputType | null
    _min: ObjetivosCursosMinAggregateOutputType | null
    _max: ObjetivosCursosMaxAggregateOutputType | null
  }

  type GetObjetivosCursosGroupByPayload<T extends objetivosCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjetivosCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjetivosCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjetivosCursosGroupByOutputType[P]>
            : GetScalarType<T[P], ObjetivosCursosGroupByOutputType[P]>
        }
      >
    >


  export type objetivosCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objetivosCursos"]>

  export type objetivosCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objetivosCursos"]>

  export type objetivosCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objetivosCursos"]>

  export type objetivosCursosSelectScalar = {
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
  }

  export type objetivosCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cursoId" | "descripcion" | "orden" | "creadoEn", ExtArgs["result"]["objetivosCursos"]>
  export type objetivosCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type objetivosCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type objetivosCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }

  export type $objetivosCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "objetivosCursos"
    objects: {
      curso: Prisma.$cursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cursoId: string
      descripcion: string
      orden: number
      creadoEn: Date
    }, ExtArgs["result"]["objetivosCursos"]>
    composites: {}
  }

  type objetivosCursosGetPayload<S extends boolean | null | undefined | objetivosCursosDefaultArgs> = $Result.GetResult<Prisma.$objetivosCursosPayload, S>

  type objetivosCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<objetivosCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObjetivosCursosCountAggregateInputType | true
    }

  export interface objetivosCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['objetivosCursos'], meta: { name: 'objetivosCursos' } }
    /**
     * Find zero or one ObjetivosCursos that matches the filter.
     * @param {objetivosCursosFindUniqueArgs} args - Arguments to find a ObjetivosCursos
     * @example
     * // Get one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends objetivosCursosFindUniqueArgs>(args: SelectSubset<T, objetivosCursosFindUniqueArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ObjetivosCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {objetivosCursosFindUniqueOrThrowArgs} args - Arguments to find a ObjetivosCursos
     * @example
     * // Get one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends objetivosCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, objetivosCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ObjetivosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosFindFirstArgs} args - Arguments to find a ObjetivosCursos
     * @example
     * // Get one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends objetivosCursosFindFirstArgs>(args?: SelectSubset<T, objetivosCursosFindFirstArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ObjetivosCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosFindFirstOrThrowArgs} args - Arguments to find a ObjetivosCursos
     * @example
     * // Get one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends objetivosCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, objetivosCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ObjetivosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findMany()
     * 
     * // Get first 10 ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objetivosCursosWithIdOnly = await prisma.objetivosCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends objetivosCursosFindManyArgs>(args?: SelectSubset<T, objetivosCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ObjetivosCursos.
     * @param {objetivosCursosCreateArgs} args - Arguments to create a ObjetivosCursos.
     * @example
     * // Create one ObjetivosCursos
     * const ObjetivosCursos = await prisma.objetivosCursos.create({
     *   data: {
     *     // ... data to create a ObjetivosCursos
     *   }
     * })
     * 
     */
    create<T extends objetivosCursosCreateArgs>(args: SelectSubset<T, objetivosCursosCreateArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ObjetivosCursos.
     * @param {objetivosCursosCreateManyArgs} args - Arguments to create many ObjetivosCursos.
     * @example
     * // Create many ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends objetivosCursosCreateManyArgs>(args?: SelectSubset<T, objetivosCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ObjetivosCursos and returns the data saved in the database.
     * @param {objetivosCursosCreateManyAndReturnArgs} args - Arguments to create many ObjetivosCursos.
     * @example
     * // Create many ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ObjetivosCursos and only return the `id`
     * const objetivosCursosWithIdOnly = await prisma.objetivosCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends objetivosCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, objetivosCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ObjetivosCursos.
     * @param {objetivosCursosDeleteArgs} args - Arguments to delete one ObjetivosCursos.
     * @example
     * // Delete one ObjetivosCursos
     * const ObjetivosCursos = await prisma.objetivosCursos.delete({
     *   where: {
     *     // ... filter to delete one ObjetivosCursos
     *   }
     * })
     * 
     */
    delete<T extends objetivosCursosDeleteArgs>(args: SelectSubset<T, objetivosCursosDeleteArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ObjetivosCursos.
     * @param {objetivosCursosUpdateArgs} args - Arguments to update one ObjetivosCursos.
     * @example
     * // Update one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends objetivosCursosUpdateArgs>(args: SelectSubset<T, objetivosCursosUpdateArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ObjetivosCursos.
     * @param {objetivosCursosDeleteManyArgs} args - Arguments to filter ObjetivosCursos to delete.
     * @example
     * // Delete a few ObjetivosCursos
     * const { count } = await prisma.objetivosCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends objetivosCursosDeleteManyArgs>(args?: SelectSubset<T, objetivosCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjetivosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends objetivosCursosUpdateManyArgs>(args: SelectSubset<T, objetivosCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjetivosCursos and returns the data updated in the database.
     * @param {objetivosCursosUpdateManyAndReturnArgs} args - Arguments to update many ObjetivosCursos.
     * @example
     * // Update many ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ObjetivosCursos and only return the `id`
     * const objetivosCursosWithIdOnly = await prisma.objetivosCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends objetivosCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, objetivosCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ObjetivosCursos.
     * @param {objetivosCursosUpsertArgs} args - Arguments to update or create a ObjetivosCursos.
     * @example
     * // Update or create a ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.upsert({
     *   create: {
     *     // ... data to create a ObjetivosCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjetivosCursos we want to update
     *   }
     * })
     */
    upsert<T extends objetivosCursosUpsertArgs>(args: SelectSubset<T, objetivosCursosUpsertArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ObjetivosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosCountArgs} args - Arguments to filter ObjetivosCursos to count.
     * @example
     * // Count the number of ObjetivosCursos
     * const count = await prisma.objetivosCursos.count({
     *   where: {
     *     // ... the filter for the ObjetivosCursos we want to count
     *   }
     * })
    **/
    count<T extends objetivosCursosCountArgs>(
      args?: Subset<T, objetivosCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjetivosCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjetivosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetivosCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjetivosCursosAggregateArgs>(args: Subset<T, ObjetivosCursosAggregateArgs>): Prisma.PrismaPromise<GetObjetivosCursosAggregateType<T>>

    /**
     * Group by ObjetivosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends objetivosCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: objetivosCursosGroupByArgs['orderBy'] }
        : { orderBy?: objetivosCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, objetivosCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjetivosCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the objetivosCursos model
   */
  readonly fields: objetivosCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for objetivosCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__objetivosCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curso<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the objetivosCursos model
   */
  interface objetivosCursosFieldRefs {
    readonly id: FieldRef<"objetivosCursos", 'String'>
    readonly cursoId: FieldRef<"objetivosCursos", 'String'>
    readonly descripcion: FieldRef<"objetivosCursos", 'String'>
    readonly orden: FieldRef<"objetivosCursos", 'Int'>
    readonly creadoEn: FieldRef<"objetivosCursos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * objetivosCursos findUnique
   */
  export type objetivosCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where: objetivosCursosWhereUniqueInput
  }

  /**
   * objetivosCursos findUniqueOrThrow
   */
  export type objetivosCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where: objetivosCursosWhereUniqueInput
  }

  /**
   * objetivosCursos findFirst
   */
  export type objetivosCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where?: objetivosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetivosCursos to fetch.
     */
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for objetivosCursos.
     */
    cursor?: objetivosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetivosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetivosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of objetivosCursos.
     */
    distinct?: ObjetivosCursosScalarFieldEnum | ObjetivosCursosScalarFieldEnum[]
  }

  /**
   * objetivosCursos findFirstOrThrow
   */
  export type objetivosCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where?: objetivosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetivosCursos to fetch.
     */
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for objetivosCursos.
     */
    cursor?: objetivosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetivosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetivosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of objetivosCursos.
     */
    distinct?: ObjetivosCursosScalarFieldEnum | ObjetivosCursosScalarFieldEnum[]
  }

  /**
   * objetivosCursos findMany
   */
  export type objetivosCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where?: objetivosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetivosCursos to fetch.
     */
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing objetivosCursos.
     */
    cursor?: objetivosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetivosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetivosCursos.
     */
    skip?: number
    distinct?: ObjetivosCursosScalarFieldEnum | ObjetivosCursosScalarFieldEnum[]
  }

  /**
   * objetivosCursos create
   */
  export type objetivosCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a objetivosCursos.
     */
    data: XOR<objetivosCursosCreateInput, objetivosCursosUncheckedCreateInput>
  }

  /**
   * objetivosCursos createMany
   */
  export type objetivosCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many objetivosCursos.
     */
    data: objetivosCursosCreateManyInput | objetivosCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * objetivosCursos createManyAndReturn
   */
  export type objetivosCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * The data used to create many objetivosCursos.
     */
    data: objetivosCursosCreateManyInput | objetivosCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * objetivosCursos update
   */
  export type objetivosCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a objetivosCursos.
     */
    data: XOR<objetivosCursosUpdateInput, objetivosCursosUncheckedUpdateInput>
    /**
     * Choose, which objetivosCursos to update.
     */
    where: objetivosCursosWhereUniqueInput
  }

  /**
   * objetivosCursos updateMany
   */
  export type objetivosCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update objetivosCursos.
     */
    data: XOR<objetivosCursosUpdateManyMutationInput, objetivosCursosUncheckedUpdateManyInput>
    /**
     * Filter which objetivosCursos to update
     */
    where?: objetivosCursosWhereInput
    /**
     * Limit how many objetivosCursos to update.
     */
    limit?: number
  }

  /**
   * objetivosCursos updateManyAndReturn
   */
  export type objetivosCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * The data used to update objetivosCursos.
     */
    data: XOR<objetivosCursosUpdateManyMutationInput, objetivosCursosUncheckedUpdateManyInput>
    /**
     * Filter which objetivosCursos to update
     */
    where?: objetivosCursosWhereInput
    /**
     * Limit how many objetivosCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * objetivosCursos upsert
   */
  export type objetivosCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the objetivosCursos to update in case it exists.
     */
    where: objetivosCursosWhereUniqueInput
    /**
     * In case the objetivosCursos found by the `where` argument doesn't exist, create a new objetivosCursos with this data.
     */
    create: XOR<objetivosCursosCreateInput, objetivosCursosUncheckedCreateInput>
    /**
     * In case the objetivosCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<objetivosCursosUpdateInput, objetivosCursosUncheckedUpdateInput>
  }

  /**
   * objetivosCursos delete
   */
  export type objetivosCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter which objetivosCursos to delete.
     */
    where: objetivosCursosWhereUniqueInput
  }

  /**
   * objetivosCursos deleteMany
   */
  export type objetivosCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which objetivosCursos to delete
     */
    where?: objetivosCursosWhereInput
    /**
     * Limit how many objetivosCursos to delete.
     */
    limit?: number
  }

  /**
   * objetivosCursos without action
   */
  export type objetivosCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
  }


  /**
   * Model requisitosCursos
   */

  export type AggregateRequisitosCursos = {
    _count: RequisitosCursosCountAggregateOutputType | null
    _avg: RequisitosCursosAvgAggregateOutputType | null
    _sum: RequisitosCursosSumAggregateOutputType | null
    _min: RequisitosCursosMinAggregateOutputType | null
    _max: RequisitosCursosMaxAggregateOutputType | null
  }

  export type RequisitosCursosAvgAggregateOutputType = {
    orden: number | null
  }

  export type RequisitosCursosSumAggregateOutputType = {
    orden: number | null
  }

  export type RequisitosCursosMinAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type RequisitosCursosMaxAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type RequisitosCursosCountAggregateOutputType = {
    id: number
    cursoId: number
    descripcion: number
    orden: number
    creadoEn: number
    _all: number
  }


  export type RequisitosCursosAvgAggregateInputType = {
    orden?: true
  }

  export type RequisitosCursosSumAggregateInputType = {
    orden?: true
  }

  export type RequisitosCursosMinAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type RequisitosCursosMaxAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type RequisitosCursosCountAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
    _all?: true
  }

  export type RequisitosCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requisitosCursos to aggregate.
     */
    where?: requisitosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requisitosCursos to fetch.
     */
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: requisitosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requisitosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requisitosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requisitosCursos
    **/
    _count?: true | RequisitosCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequisitosCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequisitosCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequisitosCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequisitosCursosMaxAggregateInputType
  }

  export type GetRequisitosCursosAggregateType<T extends RequisitosCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateRequisitosCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequisitosCursos[P]>
      : GetScalarType<T[P], AggregateRequisitosCursos[P]>
  }




  export type requisitosCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requisitosCursosWhereInput
    orderBy?: requisitosCursosOrderByWithAggregationInput | requisitosCursosOrderByWithAggregationInput[]
    by: RequisitosCursosScalarFieldEnum[] | RequisitosCursosScalarFieldEnum
    having?: requisitosCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequisitosCursosCountAggregateInputType | true
    _avg?: RequisitosCursosAvgAggregateInputType
    _sum?: RequisitosCursosSumAggregateInputType
    _min?: RequisitosCursosMinAggregateInputType
    _max?: RequisitosCursosMaxAggregateInputType
  }

  export type RequisitosCursosGroupByOutputType = {
    id: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn: Date
    _count: RequisitosCursosCountAggregateOutputType | null
    _avg: RequisitosCursosAvgAggregateOutputType | null
    _sum: RequisitosCursosSumAggregateOutputType | null
    _min: RequisitosCursosMinAggregateOutputType | null
    _max: RequisitosCursosMaxAggregateOutputType | null
  }

  type GetRequisitosCursosGroupByPayload<T extends requisitosCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequisitosCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequisitosCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequisitosCursosGroupByOutputType[P]>
            : GetScalarType<T[P], RequisitosCursosGroupByOutputType[P]>
        }
      >
    >


  export type requisitosCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisitosCursos"]>

  export type requisitosCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisitosCursos"]>

  export type requisitosCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisitosCursos"]>

  export type requisitosCursosSelectScalar = {
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
  }

  export type requisitosCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cursoId" | "descripcion" | "orden" | "creadoEn", ExtArgs["result"]["requisitosCursos"]>
  export type requisitosCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type requisitosCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type requisitosCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | cursosDefaultArgs<ExtArgs>
  }

  export type $requisitosCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "requisitosCursos"
    objects: {
      curso: Prisma.$cursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cursoId: string
      descripcion: string
      orden: number
      creadoEn: Date
    }, ExtArgs["result"]["requisitosCursos"]>
    composites: {}
  }

  type requisitosCursosGetPayload<S extends boolean | null | undefined | requisitosCursosDefaultArgs> = $Result.GetResult<Prisma.$requisitosCursosPayload, S>

  type requisitosCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<requisitosCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequisitosCursosCountAggregateInputType | true
    }

  export interface requisitosCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['requisitosCursos'], meta: { name: 'requisitosCursos' } }
    /**
     * Find zero or one RequisitosCursos that matches the filter.
     * @param {requisitosCursosFindUniqueArgs} args - Arguments to find a RequisitosCursos
     * @example
     * // Get one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends requisitosCursosFindUniqueArgs>(args: SelectSubset<T, requisitosCursosFindUniqueArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequisitosCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {requisitosCursosFindUniqueOrThrowArgs} args - Arguments to find a RequisitosCursos
     * @example
     * // Get one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends requisitosCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, requisitosCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequisitosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosFindFirstArgs} args - Arguments to find a RequisitosCursos
     * @example
     * // Get one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends requisitosCursosFindFirstArgs>(args?: SelectSubset<T, requisitosCursosFindFirstArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequisitosCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosFindFirstOrThrowArgs} args - Arguments to find a RequisitosCursos
     * @example
     * // Get one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends requisitosCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, requisitosCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequisitosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findMany()
     * 
     * // Get first 10 RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requisitosCursosWithIdOnly = await prisma.requisitosCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends requisitosCursosFindManyArgs>(args?: SelectSubset<T, requisitosCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequisitosCursos.
     * @param {requisitosCursosCreateArgs} args - Arguments to create a RequisitosCursos.
     * @example
     * // Create one RequisitosCursos
     * const RequisitosCursos = await prisma.requisitosCursos.create({
     *   data: {
     *     // ... data to create a RequisitosCursos
     *   }
     * })
     * 
     */
    create<T extends requisitosCursosCreateArgs>(args: SelectSubset<T, requisitosCursosCreateArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequisitosCursos.
     * @param {requisitosCursosCreateManyArgs} args - Arguments to create many RequisitosCursos.
     * @example
     * // Create many RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends requisitosCursosCreateManyArgs>(args?: SelectSubset<T, requisitosCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequisitosCursos and returns the data saved in the database.
     * @param {requisitosCursosCreateManyAndReturnArgs} args - Arguments to create many RequisitosCursos.
     * @example
     * // Create many RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequisitosCursos and only return the `id`
     * const requisitosCursosWithIdOnly = await prisma.requisitosCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends requisitosCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, requisitosCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequisitosCursos.
     * @param {requisitosCursosDeleteArgs} args - Arguments to delete one RequisitosCursos.
     * @example
     * // Delete one RequisitosCursos
     * const RequisitosCursos = await prisma.requisitosCursos.delete({
     *   where: {
     *     // ... filter to delete one RequisitosCursos
     *   }
     * })
     * 
     */
    delete<T extends requisitosCursosDeleteArgs>(args: SelectSubset<T, requisitosCursosDeleteArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequisitosCursos.
     * @param {requisitosCursosUpdateArgs} args - Arguments to update one RequisitosCursos.
     * @example
     * // Update one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends requisitosCursosUpdateArgs>(args: SelectSubset<T, requisitosCursosUpdateArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequisitosCursos.
     * @param {requisitosCursosDeleteManyArgs} args - Arguments to filter RequisitosCursos to delete.
     * @example
     * // Delete a few RequisitosCursos
     * const { count } = await prisma.requisitosCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends requisitosCursosDeleteManyArgs>(args?: SelectSubset<T, requisitosCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequisitosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends requisitosCursosUpdateManyArgs>(args: SelectSubset<T, requisitosCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequisitosCursos and returns the data updated in the database.
     * @param {requisitosCursosUpdateManyAndReturnArgs} args - Arguments to update many RequisitosCursos.
     * @example
     * // Update many RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequisitosCursos and only return the `id`
     * const requisitosCursosWithIdOnly = await prisma.requisitosCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends requisitosCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, requisitosCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequisitosCursos.
     * @param {requisitosCursosUpsertArgs} args - Arguments to update or create a RequisitosCursos.
     * @example
     * // Update or create a RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.upsert({
     *   create: {
     *     // ... data to create a RequisitosCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequisitosCursos we want to update
     *   }
     * })
     */
    upsert<T extends requisitosCursosUpsertArgs>(args: SelectSubset<T, requisitosCursosUpsertArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequisitosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosCountArgs} args - Arguments to filter RequisitosCursos to count.
     * @example
     * // Count the number of RequisitosCursos
     * const count = await prisma.requisitosCursos.count({
     *   where: {
     *     // ... the filter for the RequisitosCursos we want to count
     *   }
     * })
    **/
    count<T extends requisitosCursosCountArgs>(
      args?: Subset<T, requisitosCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequisitosCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequisitosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitosCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequisitosCursosAggregateArgs>(args: Subset<T, RequisitosCursosAggregateArgs>): Prisma.PrismaPromise<GetRequisitosCursosAggregateType<T>>

    /**
     * Group by RequisitosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends requisitosCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: requisitosCursosGroupByArgs['orderBy'] }
        : { orderBy?: requisitosCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, requisitosCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequisitosCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the requisitosCursos model
   */
  readonly fields: requisitosCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for requisitosCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__requisitosCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curso<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the requisitosCursos model
   */
  interface requisitosCursosFieldRefs {
    readonly id: FieldRef<"requisitosCursos", 'String'>
    readonly cursoId: FieldRef<"requisitosCursos", 'String'>
    readonly descripcion: FieldRef<"requisitosCursos", 'String'>
    readonly orden: FieldRef<"requisitosCursos", 'Int'>
    readonly creadoEn: FieldRef<"requisitosCursos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * requisitosCursos findUnique
   */
  export type requisitosCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where: requisitosCursosWhereUniqueInput
  }

  /**
   * requisitosCursos findUniqueOrThrow
   */
  export type requisitosCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where: requisitosCursosWhereUniqueInput
  }

  /**
   * requisitosCursos findFirst
   */
  export type requisitosCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where?: requisitosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requisitosCursos to fetch.
     */
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requisitosCursos.
     */
    cursor?: requisitosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requisitosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requisitosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requisitosCursos.
     */
    distinct?: RequisitosCursosScalarFieldEnum | RequisitosCursosScalarFieldEnum[]
  }

  /**
   * requisitosCursos findFirstOrThrow
   */
  export type requisitosCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where?: requisitosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requisitosCursos to fetch.
     */
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requisitosCursos.
     */
    cursor?: requisitosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requisitosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requisitosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requisitosCursos.
     */
    distinct?: RequisitosCursosScalarFieldEnum | RequisitosCursosScalarFieldEnum[]
  }

  /**
   * requisitosCursos findMany
   */
  export type requisitosCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where?: requisitosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requisitosCursos to fetch.
     */
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requisitosCursos.
     */
    cursor?: requisitosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requisitosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requisitosCursos.
     */
    skip?: number
    distinct?: RequisitosCursosScalarFieldEnum | RequisitosCursosScalarFieldEnum[]
  }

  /**
   * requisitosCursos create
   */
  export type requisitosCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a requisitosCursos.
     */
    data: XOR<requisitosCursosCreateInput, requisitosCursosUncheckedCreateInput>
  }

  /**
   * requisitosCursos createMany
   */
  export type requisitosCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many requisitosCursos.
     */
    data: requisitosCursosCreateManyInput | requisitosCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * requisitosCursos createManyAndReturn
   */
  export type requisitosCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * The data used to create many requisitosCursos.
     */
    data: requisitosCursosCreateManyInput | requisitosCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * requisitosCursos update
   */
  export type requisitosCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a requisitosCursos.
     */
    data: XOR<requisitosCursosUpdateInput, requisitosCursosUncheckedUpdateInput>
    /**
     * Choose, which requisitosCursos to update.
     */
    where: requisitosCursosWhereUniqueInput
  }

  /**
   * requisitosCursos updateMany
   */
  export type requisitosCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update requisitosCursos.
     */
    data: XOR<requisitosCursosUpdateManyMutationInput, requisitosCursosUncheckedUpdateManyInput>
    /**
     * Filter which requisitosCursos to update
     */
    where?: requisitosCursosWhereInput
    /**
     * Limit how many requisitosCursos to update.
     */
    limit?: number
  }

  /**
   * requisitosCursos updateManyAndReturn
   */
  export type requisitosCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * The data used to update requisitosCursos.
     */
    data: XOR<requisitosCursosUpdateManyMutationInput, requisitosCursosUncheckedUpdateManyInput>
    /**
     * Filter which requisitosCursos to update
     */
    where?: requisitosCursosWhereInput
    /**
     * Limit how many requisitosCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * requisitosCursos upsert
   */
  export type requisitosCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the requisitosCursos to update in case it exists.
     */
    where: requisitosCursosWhereUniqueInput
    /**
     * In case the requisitosCursos found by the `where` argument doesn't exist, create a new requisitosCursos with this data.
     */
    create: XOR<requisitosCursosCreateInput, requisitosCursosUncheckedCreateInput>
    /**
     * In case the requisitosCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<requisitosCursosUpdateInput, requisitosCursosUncheckedUpdateInput>
  }

  /**
   * requisitosCursos delete
   */
  export type requisitosCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter which requisitosCursos to delete.
     */
    where: requisitosCursosWhereUniqueInput
  }

  /**
   * requisitosCursos deleteMany
   */
  export type requisitosCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requisitosCursos to delete
     */
    where?: requisitosCursosWhereInput
    /**
     * Limit how many requisitosCursos to delete.
     */
    limit?: number
  }

  /**
   * requisitosCursos without action
   */
  export type requisitosCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
  }


  /**
   * Model clases
   */

  export type AggregateClases = {
    _count: ClasesCountAggregateOutputType | null
    _avg: ClasesAvgAggregateOutputType | null
    _sum: ClasesSumAggregateOutputType | null
    _min: ClasesMinAggregateOutputType | null
    _max: ClasesMaxAggregateOutputType | null
  }

  export type ClasesAvgAggregateOutputType = {
    duracion: number | null
    orden: number | null
  }

  export type ClasesSumAggregateOutputType = {
    duracion: number | null
    orden: number | null
  }

  export type ClasesMinAggregateOutputType = {
    id: string | null
    edicionId: string | null
    descripcion: string | null
    duracion: number | null
    fecha: Date | null
    orden: number | null
    titulo: string | null
    urlYoutube: string | null
    creadoEn: Date | null
  }

  export type ClasesMaxAggregateOutputType = {
    id: string | null
    edicionId: string | null
    descripcion: string | null
    duracion: number | null
    fecha: Date | null
    orden: number | null
    titulo: string | null
    urlYoutube: string | null
    creadoEn: Date | null
  }

  export type ClasesCountAggregateOutputType = {
    id: number
    edicionId: number
    descripcion: number
    duracion: number
    fecha: number
    orden: number
    titulo: number
    urlYoutube: number
    creadoEn: number
    _all: number
  }


  export type ClasesAvgAggregateInputType = {
    duracion?: true
    orden?: true
  }

  export type ClasesSumAggregateInputType = {
    duracion?: true
    orden?: true
  }

  export type ClasesMinAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    duracion?: true
    fecha?: true
    orden?: true
    titulo?: true
    urlYoutube?: true
    creadoEn?: true
  }

  export type ClasesMaxAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    duracion?: true
    fecha?: true
    orden?: true
    titulo?: true
    urlYoutube?: true
    creadoEn?: true
  }

  export type ClasesCountAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    duracion?: true
    fecha?: true
    orden?: true
    titulo?: true
    urlYoutube?: true
    creadoEn?: true
    _all?: true
  }

  export type ClasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clases to aggregate.
     */
    where?: clasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clases to fetch.
     */
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clases
    **/
    _count?: true | ClasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClasesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClasesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClasesMaxAggregateInputType
  }

  export type GetClasesAggregateType<T extends ClasesAggregateArgs> = {
        [P in keyof T & keyof AggregateClases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClases[P]>
      : GetScalarType<T[P], AggregateClases[P]>
  }




  export type clasesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clasesWhereInput
    orderBy?: clasesOrderByWithAggregationInput | clasesOrderByWithAggregationInput[]
    by: ClasesScalarFieldEnum[] | ClasesScalarFieldEnum
    having?: clasesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClasesCountAggregateInputType | true
    _avg?: ClasesAvgAggregateInputType
    _sum?: ClasesSumAggregateInputType
    _min?: ClasesMinAggregateInputType
    _max?: ClasesMaxAggregateInputType
  }

  export type ClasesGroupByOutputType = {
    id: string
    edicionId: string
    descripcion: string
    duracion: number | null
    fecha: Date
    orden: number
    titulo: string
    urlYoutube: string | null
    creadoEn: Date
    _count: ClasesCountAggregateOutputType | null
    _avg: ClasesAvgAggregateOutputType | null
    _sum: ClasesSumAggregateOutputType | null
    _min: ClasesMinAggregateOutputType | null
    _max: ClasesMaxAggregateOutputType | null
  }

  type GetClasesGroupByPayload<T extends clasesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClasesGroupByOutputType[P]>
            : GetScalarType<T[P], ClasesGroupByOutputType[P]>
        }
      >
    >


  export type clasesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    duracion?: boolean
    fecha?: boolean
    orden?: boolean
    titulo?: boolean
    urlYoutube?: boolean
    creadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    materiales?: boolean | clases$materialesArgs<ExtArgs>
    grabaciones?: boolean | clases$grabacionesArgs<ExtArgs>
    _count?: boolean | ClasesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clases"]>

  export type clasesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    duracion?: boolean
    fecha?: boolean
    orden?: boolean
    titulo?: boolean
    urlYoutube?: boolean
    creadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clases"]>

  export type clasesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    duracion?: boolean
    fecha?: boolean
    orden?: boolean
    titulo?: boolean
    urlYoutube?: boolean
    creadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clases"]>

  export type clasesSelectScalar = {
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    duracion?: boolean
    fecha?: boolean
    orden?: boolean
    titulo?: boolean
    urlYoutube?: boolean
    creadoEn?: boolean
  }

  export type clasesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "edicionId" | "descripcion" | "duracion" | "fecha" | "orden" | "titulo" | "urlYoutube" | "creadoEn", ExtArgs["result"]["clases"]>
  export type clasesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    materiales?: boolean | clases$materialesArgs<ExtArgs>
    grabaciones?: boolean | clases$grabacionesArgs<ExtArgs>
    _count?: boolean | ClasesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clasesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type clasesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }

  export type $clasesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clases"
    objects: {
      edicion: Prisma.$edicionesCursosPayload<ExtArgs>
      materiales: Prisma.$materialesPayload<ExtArgs>[]
      grabaciones: Prisma.$grabacionesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      edicionId: string
      descripcion: string
      duracion: number | null
      fecha: Date
      orden: number
      titulo: string
      urlYoutube: string | null
      creadoEn: Date
    }, ExtArgs["result"]["clases"]>
    composites: {}
  }

  type clasesGetPayload<S extends boolean | null | undefined | clasesDefaultArgs> = $Result.GetResult<Prisma.$clasesPayload, S>

  type clasesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clasesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClasesCountAggregateInputType | true
    }

  export interface clasesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clases'], meta: { name: 'clases' } }
    /**
     * Find zero or one Clases that matches the filter.
     * @param {clasesFindUniqueArgs} args - Arguments to find a Clases
     * @example
     * // Get one Clases
     * const clases = await prisma.clases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clasesFindUniqueArgs>(args: SelectSubset<T, clasesFindUniqueArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clasesFindUniqueOrThrowArgs} args - Arguments to find a Clases
     * @example
     * // Get one Clases
     * const clases = await prisma.clases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clasesFindUniqueOrThrowArgs>(args: SelectSubset<T, clasesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesFindFirstArgs} args - Arguments to find a Clases
     * @example
     * // Get one Clases
     * const clases = await prisma.clases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clasesFindFirstArgs>(args?: SelectSubset<T, clasesFindFirstArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesFindFirstOrThrowArgs} args - Arguments to find a Clases
     * @example
     * // Get one Clases
     * const clases = await prisma.clases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clasesFindFirstOrThrowArgs>(args?: SelectSubset<T, clasesFindFirstOrThrowArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clases
     * const clases = await prisma.clases.findMany()
     * 
     * // Get first 10 Clases
     * const clases = await prisma.clases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clasesWithIdOnly = await prisma.clases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clasesFindManyArgs>(args?: SelectSubset<T, clasesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clases.
     * @param {clasesCreateArgs} args - Arguments to create a Clases.
     * @example
     * // Create one Clases
     * const Clases = await prisma.clases.create({
     *   data: {
     *     // ... data to create a Clases
     *   }
     * })
     * 
     */
    create<T extends clasesCreateArgs>(args: SelectSubset<T, clasesCreateArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clases.
     * @param {clasesCreateManyArgs} args - Arguments to create many Clases.
     * @example
     * // Create many Clases
     * const clases = await prisma.clases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clasesCreateManyArgs>(args?: SelectSubset<T, clasesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clases and returns the data saved in the database.
     * @param {clasesCreateManyAndReturnArgs} args - Arguments to create many Clases.
     * @example
     * // Create many Clases
     * const clases = await prisma.clases.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clases and only return the `id`
     * const clasesWithIdOnly = await prisma.clases.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clasesCreateManyAndReturnArgs>(args?: SelectSubset<T, clasesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clases.
     * @param {clasesDeleteArgs} args - Arguments to delete one Clases.
     * @example
     * // Delete one Clases
     * const Clases = await prisma.clases.delete({
     *   where: {
     *     // ... filter to delete one Clases
     *   }
     * })
     * 
     */
    delete<T extends clasesDeleteArgs>(args: SelectSubset<T, clasesDeleteArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clases.
     * @param {clasesUpdateArgs} args - Arguments to update one Clases.
     * @example
     * // Update one Clases
     * const clases = await prisma.clases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clasesUpdateArgs>(args: SelectSubset<T, clasesUpdateArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clases.
     * @param {clasesDeleteManyArgs} args - Arguments to filter Clases to delete.
     * @example
     * // Delete a few Clases
     * const { count } = await prisma.clases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clasesDeleteManyArgs>(args?: SelectSubset<T, clasesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clases
     * const clases = await prisma.clases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clasesUpdateManyArgs>(args: SelectSubset<T, clasesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clases and returns the data updated in the database.
     * @param {clasesUpdateManyAndReturnArgs} args - Arguments to update many Clases.
     * @example
     * // Update many Clases
     * const clases = await prisma.clases.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clases and only return the `id`
     * const clasesWithIdOnly = await prisma.clases.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clasesUpdateManyAndReturnArgs>(args: SelectSubset<T, clasesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clases.
     * @param {clasesUpsertArgs} args - Arguments to update or create a Clases.
     * @example
     * // Update or create a Clases
     * const clases = await prisma.clases.upsert({
     *   create: {
     *     // ... data to create a Clases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clases we want to update
     *   }
     * })
     */
    upsert<T extends clasesUpsertArgs>(args: SelectSubset<T, clasesUpsertArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesCountArgs} args - Arguments to filter Clases to count.
     * @example
     * // Count the number of Clases
     * const count = await prisma.clases.count({
     *   where: {
     *     // ... the filter for the Clases we want to count
     *   }
     * })
    **/
    count<T extends clasesCountArgs>(
      args?: Subset<T, clasesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClasesAggregateArgs>(args: Subset<T, ClasesAggregateArgs>): Prisma.PrismaPromise<GetClasesAggregateType<T>>

    /**
     * Group by Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clasesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clasesGroupByArgs['orderBy'] }
        : { orderBy?: clasesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clasesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clases model
   */
  readonly fields: clasesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clasesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicion<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    materiales<T extends clases$materialesArgs<ExtArgs> = {}>(args?: Subset<T, clases$materialesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grabaciones<T extends clases$grabacionesArgs<ExtArgs> = {}>(args?: Subset<T, clases$grabacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clases model
   */
  interface clasesFieldRefs {
    readonly id: FieldRef<"clases", 'String'>
    readonly edicionId: FieldRef<"clases", 'String'>
    readonly descripcion: FieldRef<"clases", 'String'>
    readonly duracion: FieldRef<"clases", 'Int'>
    readonly fecha: FieldRef<"clases", 'DateTime'>
    readonly orden: FieldRef<"clases", 'Int'>
    readonly titulo: FieldRef<"clases", 'String'>
    readonly urlYoutube: FieldRef<"clases", 'String'>
    readonly creadoEn: FieldRef<"clases", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clases findUnique
   */
  export type clasesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where: clasesWhereUniqueInput
  }

  /**
   * clases findUniqueOrThrow
   */
  export type clasesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where: clasesWhereUniqueInput
  }

  /**
   * clases findFirst
   */
  export type clasesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where?: clasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clases to fetch.
     */
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clases.
     */
    cursor?: clasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clases.
     */
    distinct?: ClasesScalarFieldEnum | ClasesScalarFieldEnum[]
  }

  /**
   * clases findFirstOrThrow
   */
  export type clasesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where?: clasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clases to fetch.
     */
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clases.
     */
    cursor?: clasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clases.
     */
    distinct?: ClasesScalarFieldEnum | ClasesScalarFieldEnum[]
  }

  /**
   * clases findMany
   */
  export type clasesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where?: clasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clases to fetch.
     */
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clases.
     */
    cursor?: clasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clases.
     */
    skip?: number
    distinct?: ClasesScalarFieldEnum | ClasesScalarFieldEnum[]
  }

  /**
   * clases create
   */
  export type clasesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * The data needed to create a clases.
     */
    data: XOR<clasesCreateInput, clasesUncheckedCreateInput>
  }

  /**
   * clases createMany
   */
  export type clasesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clases.
     */
    data: clasesCreateManyInput | clasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clases createManyAndReturn
   */
  export type clasesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * The data used to create many clases.
     */
    data: clasesCreateManyInput | clasesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * clases update
   */
  export type clasesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * The data needed to update a clases.
     */
    data: XOR<clasesUpdateInput, clasesUncheckedUpdateInput>
    /**
     * Choose, which clases to update.
     */
    where: clasesWhereUniqueInput
  }

  /**
   * clases updateMany
   */
  export type clasesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clases.
     */
    data: XOR<clasesUpdateManyMutationInput, clasesUncheckedUpdateManyInput>
    /**
     * Filter which clases to update
     */
    where?: clasesWhereInput
    /**
     * Limit how many clases to update.
     */
    limit?: number
  }

  /**
   * clases updateManyAndReturn
   */
  export type clasesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * The data used to update clases.
     */
    data: XOR<clasesUpdateManyMutationInput, clasesUncheckedUpdateManyInput>
    /**
     * Filter which clases to update
     */
    where?: clasesWhereInput
    /**
     * Limit how many clases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * clases upsert
   */
  export type clasesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * The filter to search for the clases to update in case it exists.
     */
    where: clasesWhereUniqueInput
    /**
     * In case the clases found by the `where` argument doesn't exist, create a new clases with this data.
     */
    create: XOR<clasesCreateInput, clasesUncheckedCreateInput>
    /**
     * In case the clases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clasesUpdateInput, clasesUncheckedUpdateInput>
  }

  /**
   * clases delete
   */
  export type clasesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter which clases to delete.
     */
    where: clasesWhereUniqueInput
  }

  /**
   * clases deleteMany
   */
  export type clasesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clases to delete
     */
    where?: clasesWhereInput
    /**
     * Limit how many clases to delete.
     */
    limit?: number
  }

  /**
   * clases.materiales
   */
  export type clases$materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    where?: materialesWhereInput
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    cursor?: materialesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }

  /**
   * clases.grabaciones
   */
  export type clases$grabacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    where?: grabacionesWhereInput
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    cursor?: grabacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * clases without action
   */
  export type clasesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
  }


  /**
   * Model materiales
   */

  export type AggregateMateriales = {
    _count: MaterialesCountAggregateOutputType | null
    _min: MaterialesMinAggregateOutputType | null
    _max: MaterialesMaxAggregateOutputType | null
  }

  export type MaterialesMinAggregateOutputType = {
    id: string | null
    claseId: string | null
    tipo: string | null
    titulo: string | null
    url: string | null
    creadoEn: Date | null
  }

  export type MaterialesMaxAggregateOutputType = {
    id: string | null
    claseId: string | null
    tipo: string | null
    titulo: string | null
    url: string | null
    creadoEn: Date | null
  }

  export type MaterialesCountAggregateOutputType = {
    id: number
    claseId: number
    tipo: number
    titulo: number
    url: number
    creadoEn: number
    _all: number
  }


  export type MaterialesMinAggregateInputType = {
    id?: true
    claseId?: true
    tipo?: true
    titulo?: true
    url?: true
    creadoEn?: true
  }

  export type MaterialesMaxAggregateInputType = {
    id?: true
    claseId?: true
    tipo?: true
    titulo?: true
    url?: true
    creadoEn?: true
  }

  export type MaterialesCountAggregateInputType = {
    id?: true
    claseId?: true
    tipo?: true
    titulo?: true
    url?: true
    creadoEn?: true
    _all?: true
  }

  export type MaterialesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materiales to aggregate.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned materiales
    **/
    _count?: true | MaterialesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialesMaxAggregateInputType
  }

  export type GetMaterialesAggregateType<T extends MaterialesAggregateArgs> = {
        [P in keyof T & keyof AggregateMateriales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateriales[P]>
      : GetScalarType<T[P], AggregateMateriales[P]>
  }




  export type materialesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: materialesWhereInput
    orderBy?: materialesOrderByWithAggregationInput | materialesOrderByWithAggregationInput[]
    by: MaterialesScalarFieldEnum[] | MaterialesScalarFieldEnum
    having?: materialesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialesCountAggregateInputType | true
    _min?: MaterialesMinAggregateInputType
    _max?: MaterialesMaxAggregateInputType
  }

  export type MaterialesGroupByOutputType = {
    id: string
    claseId: string
    tipo: string
    titulo: string
    url: string
    creadoEn: Date
    _count: MaterialesCountAggregateOutputType | null
    _min: MaterialesMinAggregateOutputType | null
    _max: MaterialesMaxAggregateOutputType | null
  }

  type GetMaterialesGroupByPayload<T extends materialesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialesGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialesGroupByOutputType[P]>
        }
      >
    >


  export type materialesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    tipo?: boolean
    titulo?: boolean
    url?: boolean
    creadoEn?: boolean
    clase?: boolean | clasesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materiales"]>

  export type materialesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    tipo?: boolean
    titulo?: boolean
    url?: boolean
    creadoEn?: boolean
    clase?: boolean | clasesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materiales"]>

  export type materialesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    tipo?: boolean
    titulo?: boolean
    url?: boolean
    creadoEn?: boolean
    clase?: boolean | clasesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materiales"]>

  export type materialesSelectScalar = {
    id?: boolean
    claseId?: boolean
    tipo?: boolean
    titulo?: boolean
    url?: boolean
    creadoEn?: boolean
  }

  export type materialesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "claseId" | "tipo" | "titulo" | "url" | "creadoEn", ExtArgs["result"]["materiales"]>
  export type materialesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clase?: boolean | clasesDefaultArgs<ExtArgs>
  }
  export type materialesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clase?: boolean | clasesDefaultArgs<ExtArgs>
  }
  export type materialesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clase?: boolean | clasesDefaultArgs<ExtArgs>
  }

  export type $materialesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "materiales"
    objects: {
      clase: Prisma.$clasesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claseId: string
      tipo: string
      titulo: string
      url: string
      creadoEn: Date
    }, ExtArgs["result"]["materiales"]>
    composites: {}
  }

  type materialesGetPayload<S extends boolean | null | undefined | materialesDefaultArgs> = $Result.GetResult<Prisma.$materialesPayload, S>

  type materialesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<materialesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialesCountAggregateInputType | true
    }

  export interface materialesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['materiales'], meta: { name: 'materiales' } }
    /**
     * Find zero or one Materiales that matches the filter.
     * @param {materialesFindUniqueArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends materialesFindUniqueArgs>(args: SelectSubset<T, materialesFindUniqueArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Materiales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {materialesFindUniqueOrThrowArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends materialesFindUniqueOrThrowArgs>(args: SelectSubset<T, materialesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesFindFirstArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends materialesFindFirstArgs>(args?: SelectSubset<T, materialesFindFirstArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materiales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesFindFirstOrThrowArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends materialesFindFirstOrThrowArgs>(args?: SelectSubset<T, materialesFindFirstOrThrowArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materiales
     * const materiales = await prisma.materiales.findMany()
     * 
     * // Get first 10 Materiales
     * const materiales = await prisma.materiales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialesWithIdOnly = await prisma.materiales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends materialesFindManyArgs>(args?: SelectSubset<T, materialesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Materiales.
     * @param {materialesCreateArgs} args - Arguments to create a Materiales.
     * @example
     * // Create one Materiales
     * const Materiales = await prisma.materiales.create({
     *   data: {
     *     // ... data to create a Materiales
     *   }
     * })
     * 
     */
    create<T extends materialesCreateArgs>(args: SelectSubset<T, materialesCreateArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materiales.
     * @param {materialesCreateManyArgs} args - Arguments to create many Materiales.
     * @example
     * // Create many Materiales
     * const materiales = await prisma.materiales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends materialesCreateManyArgs>(args?: SelectSubset<T, materialesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materiales and returns the data saved in the database.
     * @param {materialesCreateManyAndReturnArgs} args - Arguments to create many Materiales.
     * @example
     * // Create many Materiales
     * const materiales = await prisma.materiales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materiales and only return the `id`
     * const materialesWithIdOnly = await prisma.materiales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends materialesCreateManyAndReturnArgs>(args?: SelectSubset<T, materialesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Materiales.
     * @param {materialesDeleteArgs} args - Arguments to delete one Materiales.
     * @example
     * // Delete one Materiales
     * const Materiales = await prisma.materiales.delete({
     *   where: {
     *     // ... filter to delete one Materiales
     *   }
     * })
     * 
     */
    delete<T extends materialesDeleteArgs>(args: SelectSubset<T, materialesDeleteArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Materiales.
     * @param {materialesUpdateArgs} args - Arguments to update one Materiales.
     * @example
     * // Update one Materiales
     * const materiales = await prisma.materiales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends materialesUpdateArgs>(args: SelectSubset<T, materialesUpdateArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materiales.
     * @param {materialesDeleteManyArgs} args - Arguments to filter Materiales to delete.
     * @example
     * // Delete a few Materiales
     * const { count } = await prisma.materiales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends materialesDeleteManyArgs>(args?: SelectSubset<T, materialesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materiales
     * const materiales = await prisma.materiales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends materialesUpdateManyArgs>(args: SelectSubset<T, materialesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materiales and returns the data updated in the database.
     * @param {materialesUpdateManyAndReturnArgs} args - Arguments to update many Materiales.
     * @example
     * // Update many Materiales
     * const materiales = await prisma.materiales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materiales and only return the `id`
     * const materialesWithIdOnly = await prisma.materiales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends materialesUpdateManyAndReturnArgs>(args: SelectSubset<T, materialesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Materiales.
     * @param {materialesUpsertArgs} args - Arguments to update or create a Materiales.
     * @example
     * // Update or create a Materiales
     * const materiales = await prisma.materiales.upsert({
     *   create: {
     *     // ... data to create a Materiales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materiales we want to update
     *   }
     * })
     */
    upsert<T extends materialesUpsertArgs>(args: SelectSubset<T, materialesUpsertArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesCountArgs} args - Arguments to filter Materiales to count.
     * @example
     * // Count the number of Materiales
     * const count = await prisma.materiales.count({
     *   where: {
     *     // ... the filter for the Materiales we want to count
     *   }
     * })
    **/
    count<T extends materialesCountArgs>(
      args?: Subset<T, materialesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialesAggregateArgs>(args: Subset<T, MaterialesAggregateArgs>): Prisma.PrismaPromise<GetMaterialesAggregateType<T>>

    /**
     * Group by Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends materialesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: materialesGroupByArgs['orderBy'] }
        : { orderBy?: materialesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, materialesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the materiales model
   */
  readonly fields: materialesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for materiales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__materialesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clase<T extends clasesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clasesDefaultArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the materiales model
   */
  interface materialesFieldRefs {
    readonly id: FieldRef<"materiales", 'String'>
    readonly claseId: FieldRef<"materiales", 'String'>
    readonly tipo: FieldRef<"materiales", 'String'>
    readonly titulo: FieldRef<"materiales", 'String'>
    readonly url: FieldRef<"materiales", 'String'>
    readonly creadoEn: FieldRef<"materiales", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * materiales findUnique
   */
  export type materialesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where: materialesWhereUniqueInput
  }

  /**
   * materiales findUniqueOrThrow
   */
  export type materialesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where: materialesWhereUniqueInput
  }

  /**
   * materiales findFirst
   */
  export type materialesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materiales.
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materiales.
     */
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }

  /**
   * materiales findFirstOrThrow
   */
  export type materialesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materiales.
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materiales.
     */
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }

  /**
   * materiales findMany
   */
  export type materialesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing materiales.
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }

  /**
   * materiales create
   */
  export type materialesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * The data needed to create a materiales.
     */
    data: XOR<materialesCreateInput, materialesUncheckedCreateInput>
  }

  /**
   * materiales createMany
   */
  export type materialesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many materiales.
     */
    data: materialesCreateManyInput | materialesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * materiales createManyAndReturn
   */
  export type materialesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * The data used to create many materiales.
     */
    data: materialesCreateManyInput | materialesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * materiales update
   */
  export type materialesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * The data needed to update a materiales.
     */
    data: XOR<materialesUpdateInput, materialesUncheckedUpdateInput>
    /**
     * Choose, which materiales to update.
     */
    where: materialesWhereUniqueInput
  }

  /**
   * materiales updateMany
   */
  export type materialesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update materiales.
     */
    data: XOR<materialesUpdateManyMutationInput, materialesUncheckedUpdateManyInput>
    /**
     * Filter which materiales to update
     */
    where?: materialesWhereInput
    /**
     * Limit how many materiales to update.
     */
    limit?: number
  }

  /**
   * materiales updateManyAndReturn
   */
  export type materialesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * The data used to update materiales.
     */
    data: XOR<materialesUpdateManyMutationInput, materialesUncheckedUpdateManyInput>
    /**
     * Filter which materiales to update
     */
    where?: materialesWhereInput
    /**
     * Limit how many materiales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * materiales upsert
   */
  export type materialesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * The filter to search for the materiales to update in case it exists.
     */
    where: materialesWhereUniqueInput
    /**
     * In case the materiales found by the `where` argument doesn't exist, create a new materiales with this data.
     */
    create: XOR<materialesCreateInput, materialesUncheckedCreateInput>
    /**
     * In case the materiales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<materialesUpdateInput, materialesUncheckedUpdateInput>
  }

  /**
   * materiales delete
   */
  export type materialesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter which materiales to delete.
     */
    where: materialesWhereUniqueInput
  }

  /**
   * materiales deleteMany
   */
  export type materialesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materiales to delete
     */
    where?: materialesWhereInput
    /**
     * Limit how many materiales to delete.
     */
    limit?: number
  }

  /**
   * materiales without action
   */
  export type materialesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
  }


  /**
   * Model examenes
   */

  export type AggregateExamenes = {
    _count: ExamenesCountAggregateOutputType | null
    _avg: ExamenesAvgAggregateOutputType | null
    _sum: ExamenesSumAggregateOutputType | null
    _min: ExamenesMinAggregateOutputType | null
    _max: ExamenesMaxAggregateOutputType | null
  }

  export type ExamenesAvgAggregateOutputType = {
    notaMaxima: number | null
    notaMinima: number | null
  }

  export type ExamenesSumAggregateOutputType = {
    notaMaxima: number | null
    notaMinima: number | null
  }

  export type ExamenesMinAggregateOutputType = {
    id: string | null
    edicionId: string | null
    descripcion: string | null
    fechaDisponible: Date | null
    fechaLimite: Date | null
    notaMaxima: number | null
    notaMinima: number | null
    titulo: string | null
    creadoEn: Date | null
  }

  export type ExamenesMaxAggregateOutputType = {
    id: string | null
    edicionId: string | null
    descripcion: string | null
    fechaDisponible: Date | null
    fechaLimite: Date | null
    notaMaxima: number | null
    notaMinima: number | null
    titulo: string | null
    creadoEn: Date | null
  }

  export type ExamenesCountAggregateOutputType = {
    id: number
    edicionId: number
    descripcion: number
    fechaDisponible: number
    fechaLimite: number
    notaMaxima: number
    notaMinima: number
    titulo: number
    creadoEn: number
    _all: number
  }


  export type ExamenesAvgAggregateInputType = {
    notaMaxima?: true
    notaMinima?: true
  }

  export type ExamenesSumAggregateInputType = {
    notaMaxima?: true
    notaMinima?: true
  }

  export type ExamenesMinAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    fechaDisponible?: true
    fechaLimite?: true
    notaMaxima?: true
    notaMinima?: true
    titulo?: true
    creadoEn?: true
  }

  export type ExamenesMaxAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    fechaDisponible?: true
    fechaLimite?: true
    notaMaxima?: true
    notaMinima?: true
    titulo?: true
    creadoEn?: true
  }

  export type ExamenesCountAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    fechaDisponible?: true
    fechaLimite?: true
    notaMaxima?: true
    notaMinima?: true
    titulo?: true
    creadoEn?: true
    _all?: true
  }

  export type ExamenesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which examenes to aggregate.
     */
    where?: examenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examenes to fetch.
     */
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: examenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned examenes
    **/
    _count?: true | ExamenesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamenesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamenesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamenesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamenesMaxAggregateInputType
  }

  export type GetExamenesAggregateType<T extends ExamenesAggregateArgs> = {
        [P in keyof T & keyof AggregateExamenes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamenes[P]>
      : GetScalarType<T[P], AggregateExamenes[P]>
  }




  export type examenesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examenesWhereInput
    orderBy?: examenesOrderByWithAggregationInput | examenesOrderByWithAggregationInput[]
    by: ExamenesScalarFieldEnum[] | ExamenesScalarFieldEnum
    having?: examenesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamenesCountAggregateInputType | true
    _avg?: ExamenesAvgAggregateInputType
    _sum?: ExamenesSumAggregateInputType
    _min?: ExamenesMinAggregateInputType
    _max?: ExamenesMaxAggregateInputType
  }

  export type ExamenesGroupByOutputType = {
    id: string
    edicionId: string
    descripcion: string | null
    fechaDisponible: Date
    fechaLimite: Date
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn: Date
    _count: ExamenesCountAggregateOutputType | null
    _avg: ExamenesAvgAggregateOutputType | null
    _sum: ExamenesSumAggregateOutputType | null
    _min: ExamenesMinAggregateOutputType | null
    _max: ExamenesMaxAggregateOutputType | null
  }

  type GetExamenesGroupByPayload<T extends examenesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamenesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamenesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamenesGroupByOutputType[P]>
            : GetScalarType<T[P], ExamenesGroupByOutputType[P]>
        }
      >
    >


  export type examenesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    fechaDisponible?: boolean
    fechaLimite?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    titulo?: boolean
    creadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    calificaciones?: boolean | examenes$calificacionesArgs<ExtArgs>
    _count?: boolean | ExamenesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examenes"]>

  export type examenesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    fechaDisponible?: boolean
    fechaLimite?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    titulo?: boolean
    creadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examenes"]>

  export type examenesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    fechaDisponible?: boolean
    fechaLimite?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    titulo?: boolean
    creadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examenes"]>

  export type examenesSelectScalar = {
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    fechaDisponible?: boolean
    fechaLimite?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    titulo?: boolean
    creadoEn?: boolean
  }

  export type examenesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "edicionId" | "descripcion" | "fechaDisponible" | "fechaLimite" | "notaMaxima" | "notaMinima" | "titulo" | "creadoEn", ExtArgs["result"]["examenes"]>
  export type examenesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    calificaciones?: boolean | examenes$calificacionesArgs<ExtArgs>
    _count?: boolean | ExamenesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type examenesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type examenesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }

  export type $examenesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "examenes"
    objects: {
      edicion: Prisma.$edicionesCursosPayload<ExtArgs>
      calificaciones: Prisma.$calificacionesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      edicionId: string
      descripcion: string | null
      fechaDisponible: Date
      fechaLimite: Date
      notaMaxima: number
      notaMinima: number
      titulo: string
      creadoEn: Date
    }, ExtArgs["result"]["examenes"]>
    composites: {}
  }

  type examenesGetPayload<S extends boolean | null | undefined | examenesDefaultArgs> = $Result.GetResult<Prisma.$examenesPayload, S>

  type examenesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<examenesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamenesCountAggregateInputType | true
    }

  export interface examenesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['examenes'], meta: { name: 'examenes' } }
    /**
     * Find zero or one Examenes that matches the filter.
     * @param {examenesFindUniqueArgs} args - Arguments to find a Examenes
     * @example
     * // Get one Examenes
     * const examenes = await prisma.examenes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends examenesFindUniqueArgs>(args: SelectSubset<T, examenesFindUniqueArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Examenes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {examenesFindUniqueOrThrowArgs} args - Arguments to find a Examenes
     * @example
     * // Get one Examenes
     * const examenes = await prisma.examenes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends examenesFindUniqueOrThrowArgs>(args: SelectSubset<T, examenesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Examenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesFindFirstArgs} args - Arguments to find a Examenes
     * @example
     * // Get one Examenes
     * const examenes = await prisma.examenes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends examenesFindFirstArgs>(args?: SelectSubset<T, examenesFindFirstArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Examenes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesFindFirstOrThrowArgs} args - Arguments to find a Examenes
     * @example
     * // Get one Examenes
     * const examenes = await prisma.examenes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends examenesFindFirstOrThrowArgs>(args?: SelectSubset<T, examenesFindFirstOrThrowArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Examenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Examenes
     * const examenes = await prisma.examenes.findMany()
     * 
     * // Get first 10 Examenes
     * const examenes = await prisma.examenes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examenesWithIdOnly = await prisma.examenes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends examenesFindManyArgs>(args?: SelectSubset<T, examenesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Examenes.
     * @param {examenesCreateArgs} args - Arguments to create a Examenes.
     * @example
     * // Create one Examenes
     * const Examenes = await prisma.examenes.create({
     *   data: {
     *     // ... data to create a Examenes
     *   }
     * })
     * 
     */
    create<T extends examenesCreateArgs>(args: SelectSubset<T, examenesCreateArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Examenes.
     * @param {examenesCreateManyArgs} args - Arguments to create many Examenes.
     * @example
     * // Create many Examenes
     * const examenes = await prisma.examenes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends examenesCreateManyArgs>(args?: SelectSubset<T, examenesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Examenes and returns the data saved in the database.
     * @param {examenesCreateManyAndReturnArgs} args - Arguments to create many Examenes.
     * @example
     * // Create many Examenes
     * const examenes = await prisma.examenes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Examenes and only return the `id`
     * const examenesWithIdOnly = await prisma.examenes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends examenesCreateManyAndReturnArgs>(args?: SelectSubset<T, examenesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Examenes.
     * @param {examenesDeleteArgs} args - Arguments to delete one Examenes.
     * @example
     * // Delete one Examenes
     * const Examenes = await prisma.examenes.delete({
     *   where: {
     *     // ... filter to delete one Examenes
     *   }
     * })
     * 
     */
    delete<T extends examenesDeleteArgs>(args: SelectSubset<T, examenesDeleteArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Examenes.
     * @param {examenesUpdateArgs} args - Arguments to update one Examenes.
     * @example
     * // Update one Examenes
     * const examenes = await prisma.examenes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends examenesUpdateArgs>(args: SelectSubset<T, examenesUpdateArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Examenes.
     * @param {examenesDeleteManyArgs} args - Arguments to filter Examenes to delete.
     * @example
     * // Delete a few Examenes
     * const { count } = await prisma.examenes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends examenesDeleteManyArgs>(args?: SelectSubset<T, examenesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Examenes
     * const examenes = await prisma.examenes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends examenesUpdateManyArgs>(args: SelectSubset<T, examenesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examenes and returns the data updated in the database.
     * @param {examenesUpdateManyAndReturnArgs} args - Arguments to update many Examenes.
     * @example
     * // Update many Examenes
     * const examenes = await prisma.examenes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Examenes and only return the `id`
     * const examenesWithIdOnly = await prisma.examenes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends examenesUpdateManyAndReturnArgs>(args: SelectSubset<T, examenesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Examenes.
     * @param {examenesUpsertArgs} args - Arguments to update or create a Examenes.
     * @example
     * // Update or create a Examenes
     * const examenes = await prisma.examenes.upsert({
     *   create: {
     *     // ... data to create a Examenes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Examenes we want to update
     *   }
     * })
     */
    upsert<T extends examenesUpsertArgs>(args: SelectSubset<T, examenesUpsertArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Examenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesCountArgs} args - Arguments to filter Examenes to count.
     * @example
     * // Count the number of Examenes
     * const count = await prisma.examenes.count({
     *   where: {
     *     // ... the filter for the Examenes we want to count
     *   }
     * })
    **/
    count<T extends examenesCountArgs>(
      args?: Subset<T, examenesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamenesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Examenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamenesAggregateArgs>(args: Subset<T, ExamenesAggregateArgs>): Prisma.PrismaPromise<GetExamenesAggregateType<T>>

    /**
     * Group by Examenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends examenesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: examenesGroupByArgs['orderBy'] }
        : { orderBy?: examenesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, examenesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamenesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the examenes model
   */
  readonly fields: examenesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for examenes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__examenesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicion<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    calificaciones<T extends examenes$calificacionesArgs<ExtArgs> = {}>(args?: Subset<T, examenes$calificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the examenes model
   */
  interface examenesFieldRefs {
    readonly id: FieldRef<"examenes", 'String'>
    readonly edicionId: FieldRef<"examenes", 'String'>
    readonly descripcion: FieldRef<"examenes", 'String'>
    readonly fechaDisponible: FieldRef<"examenes", 'DateTime'>
    readonly fechaLimite: FieldRef<"examenes", 'DateTime'>
    readonly notaMaxima: FieldRef<"examenes", 'Float'>
    readonly notaMinima: FieldRef<"examenes", 'Float'>
    readonly titulo: FieldRef<"examenes", 'String'>
    readonly creadoEn: FieldRef<"examenes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * examenes findUnique
   */
  export type examenesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where: examenesWhereUniqueInput
  }

  /**
   * examenes findUniqueOrThrow
   */
  export type examenesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where: examenesWhereUniqueInput
  }

  /**
   * examenes findFirst
   */
  export type examenesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where?: examenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examenes to fetch.
     */
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examenes.
     */
    cursor?: examenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examenes.
     */
    distinct?: ExamenesScalarFieldEnum | ExamenesScalarFieldEnum[]
  }

  /**
   * examenes findFirstOrThrow
   */
  export type examenesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where?: examenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examenes to fetch.
     */
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examenes.
     */
    cursor?: examenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examenes.
     */
    distinct?: ExamenesScalarFieldEnum | ExamenesScalarFieldEnum[]
  }

  /**
   * examenes findMany
   */
  export type examenesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where?: examenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examenes to fetch.
     */
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing examenes.
     */
    cursor?: examenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examenes.
     */
    skip?: number
    distinct?: ExamenesScalarFieldEnum | ExamenesScalarFieldEnum[]
  }

  /**
   * examenes create
   */
  export type examenesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * The data needed to create a examenes.
     */
    data: XOR<examenesCreateInput, examenesUncheckedCreateInput>
  }

  /**
   * examenes createMany
   */
  export type examenesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many examenes.
     */
    data: examenesCreateManyInput | examenesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * examenes createManyAndReturn
   */
  export type examenesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * The data used to create many examenes.
     */
    data: examenesCreateManyInput | examenesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * examenes update
   */
  export type examenesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * The data needed to update a examenes.
     */
    data: XOR<examenesUpdateInput, examenesUncheckedUpdateInput>
    /**
     * Choose, which examenes to update.
     */
    where: examenesWhereUniqueInput
  }

  /**
   * examenes updateMany
   */
  export type examenesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update examenes.
     */
    data: XOR<examenesUpdateManyMutationInput, examenesUncheckedUpdateManyInput>
    /**
     * Filter which examenes to update
     */
    where?: examenesWhereInput
    /**
     * Limit how many examenes to update.
     */
    limit?: number
  }

  /**
   * examenes updateManyAndReturn
   */
  export type examenesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * The data used to update examenes.
     */
    data: XOR<examenesUpdateManyMutationInput, examenesUncheckedUpdateManyInput>
    /**
     * Filter which examenes to update
     */
    where?: examenesWhereInput
    /**
     * Limit how many examenes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * examenes upsert
   */
  export type examenesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * The filter to search for the examenes to update in case it exists.
     */
    where: examenesWhereUniqueInput
    /**
     * In case the examenes found by the `where` argument doesn't exist, create a new examenes with this data.
     */
    create: XOR<examenesCreateInput, examenesUncheckedCreateInput>
    /**
     * In case the examenes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<examenesUpdateInput, examenesUncheckedUpdateInput>
  }

  /**
   * examenes delete
   */
  export type examenesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter which examenes to delete.
     */
    where: examenesWhereUniqueInput
  }

  /**
   * examenes deleteMany
   */
  export type examenesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which examenes to delete
     */
    where?: examenesWhereInput
    /**
     * Limit how many examenes to delete.
     */
    limit?: number
  }

  /**
   * examenes.calificaciones
   */
  export type examenes$calificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    where?: calificacionesWhereInput
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    cursor?: calificacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * examenes without action
   */
  export type examenesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
  }


  /**
   * Model calificaciones
   */

  export type AggregateCalificaciones = {
    _count: CalificacionesCountAggregateOutputType | null
    _avg: CalificacionesAvgAggregateOutputType | null
    _sum: CalificacionesSumAggregateOutputType | null
    _min: CalificacionesMinAggregateOutputType | null
    _max: CalificacionesMaxAggregateOutputType | null
  }

  export type CalificacionesAvgAggregateOutputType = {
    nota: number | null
  }

  export type CalificacionesSumAggregateOutputType = {
    nota: number | null
  }

  export type CalificacionesMinAggregateOutputType = {
    id: string | null
    aprobado: boolean | null
    comentarios: string | null
    estudianteId: string | null
    examenId: string | null
    nota: number | null
    creadoEn: Date | null
  }

  export type CalificacionesMaxAggregateOutputType = {
    id: string | null
    aprobado: boolean | null
    comentarios: string | null
    estudianteId: string | null
    examenId: string | null
    nota: number | null
    creadoEn: Date | null
  }

  export type CalificacionesCountAggregateOutputType = {
    id: number
    aprobado: number
    comentarios: number
    estudianteId: number
    examenId: number
    nota: number
    creadoEn: number
    _all: number
  }


  export type CalificacionesAvgAggregateInputType = {
    nota?: true
  }

  export type CalificacionesSumAggregateInputType = {
    nota?: true
  }

  export type CalificacionesMinAggregateInputType = {
    id?: true
    aprobado?: true
    comentarios?: true
    estudianteId?: true
    examenId?: true
    nota?: true
    creadoEn?: true
  }

  export type CalificacionesMaxAggregateInputType = {
    id?: true
    aprobado?: true
    comentarios?: true
    estudianteId?: true
    examenId?: true
    nota?: true
    creadoEn?: true
  }

  export type CalificacionesCountAggregateInputType = {
    id?: true
    aprobado?: true
    comentarios?: true
    estudianteId?: true
    examenId?: true
    nota?: true
    creadoEn?: true
    _all?: true
  }

  export type CalificacionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which calificaciones to aggregate.
     */
    where?: calificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calificaciones to fetch.
     */
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: calificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned calificaciones
    **/
    _count?: true | CalificacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalificacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalificacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalificacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalificacionesMaxAggregateInputType
  }

  export type GetCalificacionesAggregateType<T extends CalificacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateCalificaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalificaciones[P]>
      : GetScalarType<T[P], AggregateCalificaciones[P]>
  }




  export type calificacionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: calificacionesWhereInput
    orderBy?: calificacionesOrderByWithAggregationInput | calificacionesOrderByWithAggregationInput[]
    by: CalificacionesScalarFieldEnum[] | CalificacionesScalarFieldEnum
    having?: calificacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalificacionesCountAggregateInputType | true
    _avg?: CalificacionesAvgAggregateInputType
    _sum?: CalificacionesSumAggregateInputType
    _min?: CalificacionesMinAggregateInputType
    _max?: CalificacionesMaxAggregateInputType
  }

  export type CalificacionesGroupByOutputType = {
    id: string
    aprobado: boolean
    comentarios: string | null
    estudianteId: string
    examenId: string
    nota: number
    creadoEn: Date
    _count: CalificacionesCountAggregateOutputType | null
    _avg: CalificacionesAvgAggregateOutputType | null
    _sum: CalificacionesSumAggregateOutputType | null
    _min: CalificacionesMinAggregateOutputType | null
    _max: CalificacionesMaxAggregateOutputType | null
  }

  type GetCalificacionesGroupByPayload<T extends calificacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalificacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalificacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalificacionesGroupByOutputType[P]>
            : GetScalarType<T[P], CalificacionesGroupByOutputType[P]>
        }
      >
    >


  export type calificacionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aprobado?: boolean
    comentarios?: boolean
    estudianteId?: boolean
    examenId?: boolean
    nota?: boolean
    creadoEn?: boolean
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    examen?: boolean | examenesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificaciones"]>

  export type calificacionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aprobado?: boolean
    comentarios?: boolean
    estudianteId?: boolean
    examenId?: boolean
    nota?: boolean
    creadoEn?: boolean
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    examen?: boolean | examenesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificaciones"]>

  export type calificacionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aprobado?: boolean
    comentarios?: boolean
    estudianteId?: boolean
    examenId?: boolean
    nota?: boolean
    creadoEn?: boolean
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    examen?: boolean | examenesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificaciones"]>

  export type calificacionesSelectScalar = {
    id?: boolean
    aprobado?: boolean
    comentarios?: boolean
    estudianteId?: boolean
    examenId?: boolean
    nota?: boolean
    creadoEn?: boolean
  }

  export type calificacionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "aprobado" | "comentarios" | "estudianteId" | "examenId" | "nota" | "creadoEn", ExtArgs["result"]["calificaciones"]>
  export type calificacionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    examen?: boolean | examenesDefaultArgs<ExtArgs>
  }
  export type calificacionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    examen?: boolean | examenesDefaultArgs<ExtArgs>
  }
  export type calificacionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    examen?: boolean | examenesDefaultArgs<ExtArgs>
  }

  export type $calificacionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "calificaciones"
    objects: {
      estudiante: Prisma.$estudiantesPayload<ExtArgs>
      examen: Prisma.$examenesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      aprobado: boolean
      comentarios: string | null
      estudianteId: string
      examenId: string
      nota: number
      creadoEn: Date
    }, ExtArgs["result"]["calificaciones"]>
    composites: {}
  }

  type calificacionesGetPayload<S extends boolean | null | undefined | calificacionesDefaultArgs> = $Result.GetResult<Prisma.$calificacionesPayload, S>

  type calificacionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<calificacionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalificacionesCountAggregateInputType | true
    }

  export interface calificacionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['calificaciones'], meta: { name: 'calificaciones' } }
    /**
     * Find zero or one Calificaciones that matches the filter.
     * @param {calificacionesFindUniqueArgs} args - Arguments to find a Calificaciones
     * @example
     * // Get one Calificaciones
     * const calificaciones = await prisma.calificaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends calificacionesFindUniqueArgs>(args: SelectSubset<T, calificacionesFindUniqueArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Calificaciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {calificacionesFindUniqueOrThrowArgs} args - Arguments to find a Calificaciones
     * @example
     * // Get one Calificaciones
     * const calificaciones = await prisma.calificaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends calificacionesFindUniqueOrThrowArgs>(args: SelectSubset<T, calificacionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesFindFirstArgs} args - Arguments to find a Calificaciones
     * @example
     * // Get one Calificaciones
     * const calificaciones = await prisma.calificaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends calificacionesFindFirstArgs>(args?: SelectSubset<T, calificacionesFindFirstArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calificaciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesFindFirstOrThrowArgs} args - Arguments to find a Calificaciones
     * @example
     * // Get one Calificaciones
     * const calificaciones = await prisma.calificaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends calificacionesFindFirstOrThrowArgs>(args?: SelectSubset<T, calificacionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calificaciones
     * const calificaciones = await prisma.calificaciones.findMany()
     * 
     * // Get first 10 Calificaciones
     * const calificaciones = await prisma.calificaciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calificacionesWithIdOnly = await prisma.calificaciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends calificacionesFindManyArgs>(args?: SelectSubset<T, calificacionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Calificaciones.
     * @param {calificacionesCreateArgs} args - Arguments to create a Calificaciones.
     * @example
     * // Create one Calificaciones
     * const Calificaciones = await prisma.calificaciones.create({
     *   data: {
     *     // ... data to create a Calificaciones
     *   }
     * })
     * 
     */
    create<T extends calificacionesCreateArgs>(args: SelectSubset<T, calificacionesCreateArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calificaciones.
     * @param {calificacionesCreateManyArgs} args - Arguments to create many Calificaciones.
     * @example
     * // Create many Calificaciones
     * const calificaciones = await prisma.calificaciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends calificacionesCreateManyArgs>(args?: SelectSubset<T, calificacionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calificaciones and returns the data saved in the database.
     * @param {calificacionesCreateManyAndReturnArgs} args - Arguments to create many Calificaciones.
     * @example
     * // Create many Calificaciones
     * const calificaciones = await prisma.calificaciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calificaciones and only return the `id`
     * const calificacionesWithIdOnly = await prisma.calificaciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends calificacionesCreateManyAndReturnArgs>(args?: SelectSubset<T, calificacionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Calificaciones.
     * @param {calificacionesDeleteArgs} args - Arguments to delete one Calificaciones.
     * @example
     * // Delete one Calificaciones
     * const Calificaciones = await prisma.calificaciones.delete({
     *   where: {
     *     // ... filter to delete one Calificaciones
     *   }
     * })
     * 
     */
    delete<T extends calificacionesDeleteArgs>(args: SelectSubset<T, calificacionesDeleteArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Calificaciones.
     * @param {calificacionesUpdateArgs} args - Arguments to update one Calificaciones.
     * @example
     * // Update one Calificaciones
     * const calificaciones = await prisma.calificaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends calificacionesUpdateArgs>(args: SelectSubset<T, calificacionesUpdateArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calificaciones.
     * @param {calificacionesDeleteManyArgs} args - Arguments to filter Calificaciones to delete.
     * @example
     * // Delete a few Calificaciones
     * const { count } = await prisma.calificaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends calificacionesDeleteManyArgs>(args?: SelectSubset<T, calificacionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calificaciones
     * const calificaciones = await prisma.calificaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends calificacionesUpdateManyArgs>(args: SelectSubset<T, calificacionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calificaciones and returns the data updated in the database.
     * @param {calificacionesUpdateManyAndReturnArgs} args - Arguments to update many Calificaciones.
     * @example
     * // Update many Calificaciones
     * const calificaciones = await prisma.calificaciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Calificaciones and only return the `id`
     * const calificacionesWithIdOnly = await prisma.calificaciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends calificacionesUpdateManyAndReturnArgs>(args: SelectSubset<T, calificacionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Calificaciones.
     * @param {calificacionesUpsertArgs} args - Arguments to update or create a Calificaciones.
     * @example
     * // Update or create a Calificaciones
     * const calificaciones = await prisma.calificaciones.upsert({
     *   create: {
     *     // ... data to create a Calificaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calificaciones we want to update
     *   }
     * })
     */
    upsert<T extends calificacionesUpsertArgs>(args: SelectSubset<T, calificacionesUpsertArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesCountArgs} args - Arguments to filter Calificaciones to count.
     * @example
     * // Count the number of Calificaciones
     * const count = await prisma.calificaciones.count({
     *   where: {
     *     // ... the filter for the Calificaciones we want to count
     *   }
     * })
    **/
    count<T extends calificacionesCountArgs>(
      args?: Subset<T, calificacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalificacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalificacionesAggregateArgs>(args: Subset<T, CalificacionesAggregateArgs>): Prisma.PrismaPromise<GetCalificacionesAggregateType<T>>

    /**
     * Group by Calificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends calificacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: calificacionesGroupByArgs['orderBy'] }
        : { orderBy?: calificacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, calificacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalificacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the calificaciones model
   */
  readonly fields: calificacionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for calificaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__calificacionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends estudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estudiantesDefaultArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    examen<T extends examenesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, examenesDefaultArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the calificaciones model
   */
  interface calificacionesFieldRefs {
    readonly id: FieldRef<"calificaciones", 'String'>
    readonly aprobado: FieldRef<"calificaciones", 'Boolean'>
    readonly comentarios: FieldRef<"calificaciones", 'String'>
    readonly estudianteId: FieldRef<"calificaciones", 'String'>
    readonly examenId: FieldRef<"calificaciones", 'String'>
    readonly nota: FieldRef<"calificaciones", 'Float'>
    readonly creadoEn: FieldRef<"calificaciones", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * calificaciones findUnique
   */
  export type calificacionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where: calificacionesWhereUniqueInput
  }

  /**
   * calificaciones findUniqueOrThrow
   */
  export type calificacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where: calificacionesWhereUniqueInput
  }

  /**
   * calificaciones findFirst
   */
  export type calificacionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where?: calificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calificaciones to fetch.
     */
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calificaciones.
     */
    cursor?: calificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calificaciones.
     */
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * calificaciones findFirstOrThrow
   */
  export type calificacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where?: calificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calificaciones to fetch.
     */
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calificaciones.
     */
    cursor?: calificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calificaciones.
     */
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * calificaciones findMany
   */
  export type calificacionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where?: calificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calificaciones to fetch.
     */
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing calificaciones.
     */
    cursor?: calificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calificaciones.
     */
    skip?: number
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * calificaciones create
   */
  export type calificacionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * The data needed to create a calificaciones.
     */
    data: XOR<calificacionesCreateInput, calificacionesUncheckedCreateInput>
  }

  /**
   * calificaciones createMany
   */
  export type calificacionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many calificaciones.
     */
    data: calificacionesCreateManyInput | calificacionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * calificaciones createManyAndReturn
   */
  export type calificacionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * The data used to create many calificaciones.
     */
    data: calificacionesCreateManyInput | calificacionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * calificaciones update
   */
  export type calificacionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * The data needed to update a calificaciones.
     */
    data: XOR<calificacionesUpdateInput, calificacionesUncheckedUpdateInput>
    /**
     * Choose, which calificaciones to update.
     */
    where: calificacionesWhereUniqueInput
  }

  /**
   * calificaciones updateMany
   */
  export type calificacionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update calificaciones.
     */
    data: XOR<calificacionesUpdateManyMutationInput, calificacionesUncheckedUpdateManyInput>
    /**
     * Filter which calificaciones to update
     */
    where?: calificacionesWhereInput
    /**
     * Limit how many calificaciones to update.
     */
    limit?: number
  }

  /**
   * calificaciones updateManyAndReturn
   */
  export type calificacionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * The data used to update calificaciones.
     */
    data: XOR<calificacionesUpdateManyMutationInput, calificacionesUncheckedUpdateManyInput>
    /**
     * Filter which calificaciones to update
     */
    where?: calificacionesWhereInput
    /**
     * Limit how many calificaciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * calificaciones upsert
   */
  export type calificacionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * The filter to search for the calificaciones to update in case it exists.
     */
    where: calificacionesWhereUniqueInput
    /**
     * In case the calificaciones found by the `where` argument doesn't exist, create a new calificaciones with this data.
     */
    create: XOR<calificacionesCreateInput, calificacionesUncheckedCreateInput>
    /**
     * In case the calificaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<calificacionesUpdateInput, calificacionesUncheckedUpdateInput>
  }

  /**
   * calificaciones delete
   */
  export type calificacionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter which calificaciones to delete.
     */
    where: calificacionesWhereUniqueInput
  }

  /**
   * calificaciones deleteMany
   */
  export type calificacionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which calificaciones to delete
     */
    where?: calificacionesWhereInput
    /**
     * Limit how many calificaciones to delete.
     */
    limit?: number
  }

  /**
   * calificaciones without action
   */
  export type calificacionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
  }


  /**
   * Model inscripciones
   */

  export type AggregateInscripciones = {
    _count: InscripcionesCountAggregateOutputType | null
    _min: InscripcionesMinAggregateOutputType | null
    _max: InscripcionesMaxAggregateOutputType | null
  }

  export type InscripcionesMinAggregateOutputType = {
    id: string | null
    edicionId: string | null
    estado: boolean | null
    estudianteId: string | null
    inscritoEn: Date | null
    actualizadoEn: Date | null
    compraId: string | null
  }

  export type InscripcionesMaxAggregateOutputType = {
    id: string | null
    edicionId: string | null
    estado: boolean | null
    estudianteId: string | null
    inscritoEn: Date | null
    actualizadoEn: Date | null
    compraId: string | null
  }

  export type InscripcionesCountAggregateOutputType = {
    id: number
    edicionId: number
    estado: number
    estudianteId: number
    inscritoEn: number
    actualizadoEn: number
    compraId: number
    _all: number
  }


  export type InscripcionesMinAggregateInputType = {
    id?: true
    edicionId?: true
    estado?: true
    estudianteId?: true
    inscritoEn?: true
    actualizadoEn?: true
    compraId?: true
  }

  export type InscripcionesMaxAggregateInputType = {
    id?: true
    edicionId?: true
    estado?: true
    estudianteId?: true
    inscritoEn?: true
    actualizadoEn?: true
    compraId?: true
  }

  export type InscripcionesCountAggregateInputType = {
    id?: true
    edicionId?: true
    estado?: true
    estudianteId?: true
    inscritoEn?: true
    actualizadoEn?: true
    compraId?: true
    _all?: true
  }

  export type InscripcionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inscripciones to aggregate.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inscripciones
    **/
    _count?: true | InscripcionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InscripcionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InscripcionesMaxAggregateInputType
  }

  export type GetInscripcionesAggregateType<T extends InscripcionesAggregateArgs> = {
        [P in keyof T & keyof AggregateInscripciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInscripciones[P]>
      : GetScalarType<T[P], AggregateInscripciones[P]>
  }




  export type inscripcionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inscripcionesWhereInput
    orderBy?: inscripcionesOrderByWithAggregationInput | inscripcionesOrderByWithAggregationInput[]
    by: InscripcionesScalarFieldEnum[] | InscripcionesScalarFieldEnum
    having?: inscripcionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InscripcionesCountAggregateInputType | true
    _min?: InscripcionesMinAggregateInputType
    _max?: InscripcionesMaxAggregateInputType
  }

  export type InscripcionesGroupByOutputType = {
    id: string
    edicionId: string
    estado: boolean
    estudianteId: string
    inscritoEn: Date
    actualizadoEn: Date
    compraId: string | null
    _count: InscripcionesCountAggregateOutputType | null
    _min: InscripcionesMinAggregateOutputType | null
    _max: InscripcionesMaxAggregateOutputType | null
  }

  type GetInscripcionesGroupByPayload<T extends inscripcionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InscripcionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InscripcionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InscripcionesGroupByOutputType[P]>
            : GetScalarType<T[P], InscripcionesGroupByOutputType[P]>
        }
      >
    >


  export type inscripcionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    estado?: boolean
    estudianteId?: boolean
    inscritoEn?: boolean
    actualizadoEn?: boolean
    compraId?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    compra?: boolean | inscripciones$compraArgs<ExtArgs>
  }, ExtArgs["result"]["inscripciones"]>

  export type inscripcionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    estado?: boolean
    estudianteId?: boolean
    inscritoEn?: boolean
    actualizadoEn?: boolean
    compraId?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    compra?: boolean | inscripciones$compraArgs<ExtArgs>
  }, ExtArgs["result"]["inscripciones"]>

  export type inscripcionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    estado?: boolean
    estudianteId?: boolean
    inscritoEn?: boolean
    actualizadoEn?: boolean
    compraId?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    compra?: boolean | inscripciones$compraArgs<ExtArgs>
  }, ExtArgs["result"]["inscripciones"]>

  export type inscripcionesSelectScalar = {
    id?: boolean
    edicionId?: boolean
    estado?: boolean
    estudianteId?: boolean
    inscritoEn?: boolean
    actualizadoEn?: boolean
    compraId?: boolean
  }

  export type inscripcionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "edicionId" | "estado" | "estudianteId" | "inscritoEn" | "actualizadoEn" | "compraId", ExtArgs["result"]["inscripciones"]>
  export type inscripcionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    compra?: boolean | inscripciones$compraArgs<ExtArgs>
  }
  export type inscripcionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    compra?: boolean | inscripciones$compraArgs<ExtArgs>
  }
  export type inscripcionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
    compra?: boolean | inscripciones$compraArgs<ExtArgs>
  }

  export type $inscripcionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inscripciones"
    objects: {
      edicion: Prisma.$edicionesCursosPayload<ExtArgs>
      estudiante: Prisma.$estudiantesPayload<ExtArgs>
      compra: Prisma.$comprasPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      edicionId: string
      estado: boolean
      estudianteId: string
      inscritoEn: Date
      actualizadoEn: Date
      compraId: string | null
    }, ExtArgs["result"]["inscripciones"]>
    composites: {}
  }

  type inscripcionesGetPayload<S extends boolean | null | undefined | inscripcionesDefaultArgs> = $Result.GetResult<Prisma.$inscripcionesPayload, S>

  type inscripcionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inscripcionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InscripcionesCountAggregateInputType | true
    }

  export interface inscripcionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inscripciones'], meta: { name: 'inscripciones' } }
    /**
     * Find zero or one Inscripciones that matches the filter.
     * @param {inscripcionesFindUniqueArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inscripcionesFindUniqueArgs>(args: SelectSubset<T, inscripcionesFindUniqueArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inscripciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inscripcionesFindUniqueOrThrowArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inscripcionesFindUniqueOrThrowArgs>(args: SelectSubset<T, inscripcionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesFindFirstArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inscripcionesFindFirstArgs>(args?: SelectSubset<T, inscripcionesFindFirstArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesFindFirstOrThrowArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inscripcionesFindFirstOrThrowArgs>(args?: SelectSubset<T, inscripcionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inscripciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inscripciones
     * const inscripciones = await prisma.inscripciones.findMany()
     * 
     * // Get first 10 Inscripciones
     * const inscripciones = await prisma.inscripciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inscripcionesWithIdOnly = await prisma.inscripciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inscripcionesFindManyArgs>(args?: SelectSubset<T, inscripcionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inscripciones.
     * @param {inscripcionesCreateArgs} args - Arguments to create a Inscripciones.
     * @example
     * // Create one Inscripciones
     * const Inscripciones = await prisma.inscripciones.create({
     *   data: {
     *     // ... data to create a Inscripciones
     *   }
     * })
     * 
     */
    create<T extends inscripcionesCreateArgs>(args: SelectSubset<T, inscripcionesCreateArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inscripciones.
     * @param {inscripcionesCreateManyArgs} args - Arguments to create many Inscripciones.
     * @example
     * // Create many Inscripciones
     * const inscripciones = await prisma.inscripciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inscripcionesCreateManyArgs>(args?: SelectSubset<T, inscripcionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inscripciones and returns the data saved in the database.
     * @param {inscripcionesCreateManyAndReturnArgs} args - Arguments to create many Inscripciones.
     * @example
     * // Create many Inscripciones
     * const inscripciones = await prisma.inscripciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inscripciones and only return the `id`
     * const inscripcionesWithIdOnly = await prisma.inscripciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inscripcionesCreateManyAndReturnArgs>(args?: SelectSubset<T, inscripcionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inscripciones.
     * @param {inscripcionesDeleteArgs} args - Arguments to delete one Inscripciones.
     * @example
     * // Delete one Inscripciones
     * const Inscripciones = await prisma.inscripciones.delete({
     *   where: {
     *     // ... filter to delete one Inscripciones
     *   }
     * })
     * 
     */
    delete<T extends inscripcionesDeleteArgs>(args: SelectSubset<T, inscripcionesDeleteArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inscripciones.
     * @param {inscripcionesUpdateArgs} args - Arguments to update one Inscripciones.
     * @example
     * // Update one Inscripciones
     * const inscripciones = await prisma.inscripciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inscripcionesUpdateArgs>(args: SelectSubset<T, inscripcionesUpdateArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inscripciones.
     * @param {inscripcionesDeleteManyArgs} args - Arguments to filter Inscripciones to delete.
     * @example
     * // Delete a few Inscripciones
     * const { count } = await prisma.inscripciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inscripcionesDeleteManyArgs>(args?: SelectSubset<T, inscripcionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inscripciones
     * const inscripciones = await prisma.inscripciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inscripcionesUpdateManyArgs>(args: SelectSubset<T, inscripcionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripciones and returns the data updated in the database.
     * @param {inscripcionesUpdateManyAndReturnArgs} args - Arguments to update many Inscripciones.
     * @example
     * // Update many Inscripciones
     * const inscripciones = await prisma.inscripciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inscripciones and only return the `id`
     * const inscripcionesWithIdOnly = await prisma.inscripciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends inscripcionesUpdateManyAndReturnArgs>(args: SelectSubset<T, inscripcionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inscripciones.
     * @param {inscripcionesUpsertArgs} args - Arguments to update or create a Inscripciones.
     * @example
     * // Update or create a Inscripciones
     * const inscripciones = await prisma.inscripciones.upsert({
     *   create: {
     *     // ... data to create a Inscripciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inscripciones we want to update
     *   }
     * })
     */
    upsert<T extends inscripcionesUpsertArgs>(args: SelectSubset<T, inscripcionesUpsertArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesCountArgs} args - Arguments to filter Inscripciones to count.
     * @example
     * // Count the number of Inscripciones
     * const count = await prisma.inscripciones.count({
     *   where: {
     *     // ... the filter for the Inscripciones we want to count
     *   }
     * })
    **/
    count<T extends inscripcionesCountArgs>(
      args?: Subset<T, inscripcionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InscripcionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InscripcionesAggregateArgs>(args: Subset<T, InscripcionesAggregateArgs>): Prisma.PrismaPromise<GetInscripcionesAggregateType<T>>

    /**
     * Group by Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inscripcionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inscripcionesGroupByArgs['orderBy'] }
        : { orderBy?: inscripcionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inscripcionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInscripcionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inscripciones model
   */
  readonly fields: inscripcionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inscripciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inscripcionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicion<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    estudiante<T extends estudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estudiantesDefaultArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    compra<T extends inscripciones$compraArgs<ExtArgs> = {}>(args?: Subset<T, inscripciones$compraArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inscripciones model
   */
  interface inscripcionesFieldRefs {
    readonly id: FieldRef<"inscripciones", 'String'>
    readonly edicionId: FieldRef<"inscripciones", 'String'>
    readonly estado: FieldRef<"inscripciones", 'Boolean'>
    readonly estudianteId: FieldRef<"inscripciones", 'String'>
    readonly inscritoEn: FieldRef<"inscripciones", 'DateTime'>
    readonly actualizadoEn: FieldRef<"inscripciones", 'DateTime'>
    readonly compraId: FieldRef<"inscripciones", 'String'>
  }
    

  // Custom InputTypes
  /**
   * inscripciones findUnique
   */
  export type inscripcionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where: inscripcionesWhereUniqueInput
  }

  /**
   * inscripciones findUniqueOrThrow
   */
  export type inscripcionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where: inscripcionesWhereUniqueInput
  }

  /**
   * inscripciones findFirst
   */
  export type inscripcionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inscripciones.
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inscripciones.
     */
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * inscripciones findFirstOrThrow
   */
  export type inscripcionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inscripciones.
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inscripciones.
     */
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * inscripciones findMany
   */
  export type inscripcionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inscripciones.
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * inscripciones create
   */
  export type inscripcionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * The data needed to create a inscripciones.
     */
    data: XOR<inscripcionesCreateInput, inscripcionesUncheckedCreateInput>
  }

  /**
   * inscripciones createMany
   */
  export type inscripcionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inscripciones.
     */
    data: inscripcionesCreateManyInput | inscripcionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inscripciones createManyAndReturn
   */
  export type inscripcionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * The data used to create many inscripciones.
     */
    data: inscripcionesCreateManyInput | inscripcionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * inscripciones update
   */
  export type inscripcionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * The data needed to update a inscripciones.
     */
    data: XOR<inscripcionesUpdateInput, inscripcionesUncheckedUpdateInput>
    /**
     * Choose, which inscripciones to update.
     */
    where: inscripcionesWhereUniqueInput
  }

  /**
   * inscripciones updateMany
   */
  export type inscripcionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inscripciones.
     */
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyInput>
    /**
     * Filter which inscripciones to update
     */
    where?: inscripcionesWhereInput
    /**
     * Limit how many inscripciones to update.
     */
    limit?: number
  }

  /**
   * inscripciones updateManyAndReturn
   */
  export type inscripcionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * The data used to update inscripciones.
     */
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyInput>
    /**
     * Filter which inscripciones to update
     */
    where?: inscripcionesWhereInput
    /**
     * Limit how many inscripciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * inscripciones upsert
   */
  export type inscripcionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * The filter to search for the inscripciones to update in case it exists.
     */
    where: inscripcionesWhereUniqueInput
    /**
     * In case the inscripciones found by the `where` argument doesn't exist, create a new inscripciones with this data.
     */
    create: XOR<inscripcionesCreateInput, inscripcionesUncheckedCreateInput>
    /**
     * In case the inscripciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inscripcionesUpdateInput, inscripcionesUncheckedUpdateInput>
  }

  /**
   * inscripciones delete
   */
  export type inscripcionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter which inscripciones to delete.
     */
    where: inscripcionesWhereUniqueInput
  }

  /**
   * inscripciones deleteMany
   */
  export type inscripcionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inscripciones to delete
     */
    where?: inscripcionesWhereInput
    /**
     * Limit how many inscripciones to delete.
     */
    limit?: number
  }

  /**
   * inscripciones.compra
   */
  export type inscripciones$compraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    where?: comprasWhereInput
  }

  /**
   * inscripciones without action
   */
  export type inscripcionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
  }


  /**
   * Model certificados
   */

  export type AggregateCertificados = {
    _count: CertificadosCountAggregateOutputType | null
    _avg: CertificadosAvgAggregateOutputType | null
    _sum: CertificadosSumAggregateOutputType | null
    _min: CertificadosMinAggregateOutputType | null
    _max: CertificadosMaxAggregateOutputType | null
  }

  export type CertificadosAvgAggregateOutputType = {
    notaFinal: number | null
  }

  export type CertificadosSumAggregateOutputType = {
    notaFinal: number | null
  }

  export type CertificadosMinAggregateOutputType = {
    id: string | null
    codigoUnico: string | null
    edicionId: string | null
    estudianteId: string | null
    fechaEmision: Date | null
    notaFinal: number | null
    urlCertificado: string | null
    creadoEn: Date | null
  }

  export type CertificadosMaxAggregateOutputType = {
    id: string | null
    codigoUnico: string | null
    edicionId: string | null
    estudianteId: string | null
    fechaEmision: Date | null
    notaFinal: number | null
    urlCertificado: string | null
    creadoEn: Date | null
  }

  export type CertificadosCountAggregateOutputType = {
    id: number
    codigoUnico: number
    edicionId: number
    estudianteId: number
    fechaEmision: number
    notaFinal: number
    urlCertificado: number
    creadoEn: number
    _all: number
  }


  export type CertificadosAvgAggregateInputType = {
    notaFinal?: true
  }

  export type CertificadosSumAggregateInputType = {
    notaFinal?: true
  }

  export type CertificadosMinAggregateInputType = {
    id?: true
    codigoUnico?: true
    edicionId?: true
    estudianteId?: true
    fechaEmision?: true
    notaFinal?: true
    urlCertificado?: true
    creadoEn?: true
  }

  export type CertificadosMaxAggregateInputType = {
    id?: true
    codigoUnico?: true
    edicionId?: true
    estudianteId?: true
    fechaEmision?: true
    notaFinal?: true
    urlCertificado?: true
    creadoEn?: true
  }

  export type CertificadosCountAggregateInputType = {
    id?: true
    codigoUnico?: true
    edicionId?: true
    estudianteId?: true
    fechaEmision?: true
    notaFinal?: true
    urlCertificado?: true
    creadoEn?: true
    _all?: true
  }

  export type CertificadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificados to aggregate.
     */
    where?: certificadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificados to fetch.
     */
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certificadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certificados
    **/
    _count?: true | CertificadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificadosMaxAggregateInputType
  }

  export type GetCertificadosAggregateType<T extends CertificadosAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificados[P]>
      : GetScalarType<T[P], AggregateCertificados[P]>
  }




  export type certificadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificadosWhereInput
    orderBy?: certificadosOrderByWithAggregationInput | certificadosOrderByWithAggregationInput[]
    by: CertificadosScalarFieldEnum[] | CertificadosScalarFieldEnum
    having?: certificadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificadosCountAggregateInputType | true
    _avg?: CertificadosAvgAggregateInputType
    _sum?: CertificadosSumAggregateInputType
    _min?: CertificadosMinAggregateInputType
    _max?: CertificadosMaxAggregateInputType
  }

  export type CertificadosGroupByOutputType = {
    id: string
    codigoUnico: string
    edicionId: string
    estudianteId: string
    fechaEmision: Date
    notaFinal: number | null
    urlCertificado: string | null
    creadoEn: Date
    _count: CertificadosCountAggregateOutputType | null
    _avg: CertificadosAvgAggregateOutputType | null
    _sum: CertificadosSumAggregateOutputType | null
    _min: CertificadosMinAggregateOutputType | null
    _max: CertificadosMaxAggregateOutputType | null
  }

  type GetCertificadosGroupByPayload<T extends certificadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificadosGroupByOutputType[P]>
            : GetScalarType<T[P], CertificadosGroupByOutputType[P]>
        }
      >
    >


  export type certificadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoUnico?: boolean
    edicionId?: boolean
    estudianteId?: boolean
    fechaEmision?: boolean
    notaFinal?: boolean
    urlCertificado?: boolean
    creadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificados"]>

  export type certificadosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoUnico?: boolean
    edicionId?: boolean
    estudianteId?: boolean
    fechaEmision?: boolean
    notaFinal?: boolean
    urlCertificado?: boolean
    creadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificados"]>

  export type certificadosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoUnico?: boolean
    edicionId?: boolean
    estudianteId?: boolean
    fechaEmision?: boolean
    notaFinal?: boolean
    urlCertificado?: boolean
    creadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificados"]>

  export type certificadosSelectScalar = {
    id?: boolean
    codigoUnico?: boolean
    edicionId?: boolean
    estudianteId?: boolean
    fechaEmision?: boolean
    notaFinal?: boolean
    urlCertificado?: boolean
    creadoEn?: boolean
  }

  export type certificadosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigoUnico" | "edicionId" | "estudianteId" | "fechaEmision" | "notaFinal" | "urlCertificado" | "creadoEn", ExtArgs["result"]["certificados"]>
  export type certificadosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
  }
  export type certificadosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
  }
  export type certificadosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiante?: boolean | estudiantesDefaultArgs<ExtArgs>
  }

  export type $certificadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "certificados"
    objects: {
      edicion: Prisma.$edicionesCursosPayload<ExtArgs>
      estudiante: Prisma.$estudiantesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigoUnico: string
      edicionId: string
      estudianteId: string
      fechaEmision: Date
      notaFinal: number | null
      urlCertificado: string | null
      creadoEn: Date
    }, ExtArgs["result"]["certificados"]>
    composites: {}
  }

  type certificadosGetPayload<S extends boolean | null | undefined | certificadosDefaultArgs> = $Result.GetResult<Prisma.$certificadosPayload, S>

  type certificadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<certificadosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificadosCountAggregateInputType | true
    }

  export interface certificadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certificados'], meta: { name: 'certificados' } }
    /**
     * Find zero or one Certificados that matches the filter.
     * @param {certificadosFindUniqueArgs} args - Arguments to find a Certificados
     * @example
     * // Get one Certificados
     * const certificados = await prisma.certificados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends certificadosFindUniqueArgs>(args: SelectSubset<T, certificadosFindUniqueArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificados that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {certificadosFindUniqueOrThrowArgs} args - Arguments to find a Certificados
     * @example
     * // Get one Certificados
     * const certificados = await prisma.certificados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends certificadosFindUniqueOrThrowArgs>(args: SelectSubset<T, certificadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosFindFirstArgs} args - Arguments to find a Certificados
     * @example
     * // Get one Certificados
     * const certificados = await prisma.certificados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends certificadosFindFirstArgs>(args?: SelectSubset<T, certificadosFindFirstArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosFindFirstOrThrowArgs} args - Arguments to find a Certificados
     * @example
     * // Get one Certificados
     * const certificados = await prisma.certificados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends certificadosFindFirstOrThrowArgs>(args?: SelectSubset<T, certificadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificados
     * const certificados = await prisma.certificados.findMany()
     * 
     * // Get first 10 Certificados
     * const certificados = await prisma.certificados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificadosWithIdOnly = await prisma.certificados.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends certificadosFindManyArgs>(args?: SelectSubset<T, certificadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificados.
     * @param {certificadosCreateArgs} args - Arguments to create a Certificados.
     * @example
     * // Create one Certificados
     * const Certificados = await prisma.certificados.create({
     *   data: {
     *     // ... data to create a Certificados
     *   }
     * })
     * 
     */
    create<T extends certificadosCreateArgs>(args: SelectSubset<T, certificadosCreateArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificados.
     * @param {certificadosCreateManyArgs} args - Arguments to create many Certificados.
     * @example
     * // Create many Certificados
     * const certificados = await prisma.certificados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends certificadosCreateManyArgs>(args?: SelectSubset<T, certificadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificados and returns the data saved in the database.
     * @param {certificadosCreateManyAndReturnArgs} args - Arguments to create many Certificados.
     * @example
     * // Create many Certificados
     * const certificados = await prisma.certificados.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificados and only return the `id`
     * const certificadosWithIdOnly = await prisma.certificados.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends certificadosCreateManyAndReturnArgs>(args?: SelectSubset<T, certificadosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificados.
     * @param {certificadosDeleteArgs} args - Arguments to delete one Certificados.
     * @example
     * // Delete one Certificados
     * const Certificados = await prisma.certificados.delete({
     *   where: {
     *     // ... filter to delete one Certificados
     *   }
     * })
     * 
     */
    delete<T extends certificadosDeleteArgs>(args: SelectSubset<T, certificadosDeleteArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificados.
     * @param {certificadosUpdateArgs} args - Arguments to update one Certificados.
     * @example
     * // Update one Certificados
     * const certificados = await prisma.certificados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends certificadosUpdateArgs>(args: SelectSubset<T, certificadosUpdateArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificados.
     * @param {certificadosDeleteManyArgs} args - Arguments to filter Certificados to delete.
     * @example
     * // Delete a few Certificados
     * const { count } = await prisma.certificados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends certificadosDeleteManyArgs>(args?: SelectSubset<T, certificadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificados
     * const certificados = await prisma.certificados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends certificadosUpdateManyArgs>(args: SelectSubset<T, certificadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificados and returns the data updated in the database.
     * @param {certificadosUpdateManyAndReturnArgs} args - Arguments to update many Certificados.
     * @example
     * // Update many Certificados
     * const certificados = await prisma.certificados.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificados and only return the `id`
     * const certificadosWithIdOnly = await prisma.certificados.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends certificadosUpdateManyAndReturnArgs>(args: SelectSubset<T, certificadosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificados.
     * @param {certificadosUpsertArgs} args - Arguments to update or create a Certificados.
     * @example
     * // Update or create a Certificados
     * const certificados = await prisma.certificados.upsert({
     *   create: {
     *     // ... data to create a Certificados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificados we want to update
     *   }
     * })
     */
    upsert<T extends certificadosUpsertArgs>(args: SelectSubset<T, certificadosUpsertArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosCountArgs} args - Arguments to filter Certificados to count.
     * @example
     * // Count the number of Certificados
     * const count = await prisma.certificados.count({
     *   where: {
     *     // ... the filter for the Certificados we want to count
     *   }
     * })
    **/
    count<T extends certificadosCountArgs>(
      args?: Subset<T, certificadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificadosAggregateArgs>(args: Subset<T, CertificadosAggregateArgs>): Prisma.PrismaPromise<GetCertificadosAggregateType<T>>

    /**
     * Group by Certificados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certificadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certificadosGroupByArgs['orderBy'] }
        : { orderBy?: certificadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certificadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the certificados model
   */
  readonly fields: certificadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for certificados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__certificadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicion<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    estudiante<T extends estudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estudiantesDefaultArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the certificados model
   */
  interface certificadosFieldRefs {
    readonly id: FieldRef<"certificados", 'String'>
    readonly codigoUnico: FieldRef<"certificados", 'String'>
    readonly edicionId: FieldRef<"certificados", 'String'>
    readonly estudianteId: FieldRef<"certificados", 'String'>
    readonly fechaEmision: FieldRef<"certificados", 'DateTime'>
    readonly notaFinal: FieldRef<"certificados", 'Float'>
    readonly urlCertificado: FieldRef<"certificados", 'String'>
    readonly creadoEn: FieldRef<"certificados", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * certificados findUnique
   */
  export type certificadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where: certificadosWhereUniqueInput
  }

  /**
   * certificados findUniqueOrThrow
   */
  export type certificadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where: certificadosWhereUniqueInput
  }

  /**
   * certificados findFirst
   */
  export type certificadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where?: certificadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificados to fetch.
     */
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificados.
     */
    cursor?: certificadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificados.
     */
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * certificados findFirstOrThrow
   */
  export type certificadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where?: certificadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificados to fetch.
     */
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificados.
     */
    cursor?: certificadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificados.
     */
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * certificados findMany
   */
  export type certificadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where?: certificadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificados to fetch.
     */
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certificados.
     */
    cursor?: certificadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificados.
     */
    skip?: number
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * certificados create
   */
  export type certificadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * The data needed to create a certificados.
     */
    data: XOR<certificadosCreateInput, certificadosUncheckedCreateInput>
  }

  /**
   * certificados createMany
   */
  export type certificadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certificados.
     */
    data: certificadosCreateManyInput | certificadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * certificados createManyAndReturn
   */
  export type certificadosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * The data used to create many certificados.
     */
    data: certificadosCreateManyInput | certificadosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * certificados update
   */
  export type certificadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * The data needed to update a certificados.
     */
    data: XOR<certificadosUpdateInput, certificadosUncheckedUpdateInput>
    /**
     * Choose, which certificados to update.
     */
    where: certificadosWhereUniqueInput
  }

  /**
   * certificados updateMany
   */
  export type certificadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certificados.
     */
    data: XOR<certificadosUpdateManyMutationInput, certificadosUncheckedUpdateManyInput>
    /**
     * Filter which certificados to update
     */
    where?: certificadosWhereInput
    /**
     * Limit how many certificados to update.
     */
    limit?: number
  }

  /**
   * certificados updateManyAndReturn
   */
  export type certificadosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * The data used to update certificados.
     */
    data: XOR<certificadosUpdateManyMutationInput, certificadosUncheckedUpdateManyInput>
    /**
     * Filter which certificados to update
     */
    where?: certificadosWhereInput
    /**
     * Limit how many certificados to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * certificados upsert
   */
  export type certificadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * The filter to search for the certificados to update in case it exists.
     */
    where: certificadosWhereUniqueInput
    /**
     * In case the certificados found by the `where` argument doesn't exist, create a new certificados with this data.
     */
    create: XOR<certificadosCreateInput, certificadosUncheckedCreateInput>
    /**
     * In case the certificados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certificadosUpdateInput, certificadosUncheckedUpdateInput>
  }

  /**
   * certificados delete
   */
  export type certificadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter which certificados to delete.
     */
    where: certificadosWhereUniqueInput
  }

  /**
   * certificados deleteMany
   */
  export type certificadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificados to delete
     */
    where?: certificadosWhereInput
    /**
     * Limit how many certificados to delete.
     */
    limit?: number
  }

  /**
   * certificados without action
   */
  export type certificadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
  }


  /**
   * Model preciosCursos
   */

  export type AggregatePreciosCursos = {
    _count: PreciosCursosCountAggregateOutputType | null
    _avg: PreciosCursosAvgAggregateOutputType | null
    _sum: PreciosCursosSumAggregateOutputType | null
    _min: PreciosCursosMinAggregateOutputType | null
    _max: PreciosCursosMaxAggregateOutputType | null
  }

  export type PreciosCursosAvgAggregateOutputType = {
    porcentajeDescuento: number | null
    precio: number | null
    precioOriginal: number | null
  }

  export type PreciosCursosSumAggregateOutputType = {
    porcentajeDescuento: number | null
    precio: number | null
    precioOriginal: number | null
  }

  export type PreciosCursosMinAggregateOutputType = {
    id: string | null
    edicionId: string | null
    esDescuento: boolean | null
    esPrecioDefault: boolean | null
    fechaFin: Date | null
    fechaInicio: Date | null
    moneda: string | null
    nombre: string | null
    porcentajeDescuento: number | null
    precio: number | null
    precioOriginal: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PreciosCursosMaxAggregateOutputType = {
    id: string | null
    edicionId: string | null
    esDescuento: boolean | null
    esPrecioDefault: boolean | null
    fechaFin: Date | null
    fechaInicio: Date | null
    moneda: string | null
    nombre: string | null
    porcentajeDescuento: number | null
    precio: number | null
    precioOriginal: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PreciosCursosCountAggregateOutputType = {
    id: number
    edicionId: number
    esDescuento: number
    esPrecioDefault: number
    fechaFin: number
    fechaInicio: number
    moneda: number
    nombre: number
    porcentajeDescuento: number
    precio: number
    precioOriginal: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type PreciosCursosAvgAggregateInputType = {
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
  }

  export type PreciosCursosSumAggregateInputType = {
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
  }

  export type PreciosCursosMinAggregateInputType = {
    id?: true
    edicionId?: true
    esDescuento?: true
    esPrecioDefault?: true
    fechaFin?: true
    fechaInicio?: true
    moneda?: true
    nombre?: true
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PreciosCursosMaxAggregateInputType = {
    id?: true
    edicionId?: true
    esDescuento?: true
    esPrecioDefault?: true
    fechaFin?: true
    fechaInicio?: true
    moneda?: true
    nombre?: true
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PreciosCursosCountAggregateInputType = {
    id?: true
    edicionId?: true
    esDescuento?: true
    esPrecioDefault?: true
    fechaFin?: true
    fechaInicio?: true
    moneda?: true
    nombre?: true
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type PreciosCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preciosCursos to aggregate.
     */
    where?: preciosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preciosCursos to fetch.
     */
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: preciosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preciosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preciosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned preciosCursos
    **/
    _count?: true | PreciosCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreciosCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreciosCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreciosCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreciosCursosMaxAggregateInputType
  }

  export type GetPreciosCursosAggregateType<T extends PreciosCursosAggregateArgs> = {
        [P in keyof T & keyof AggregatePreciosCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreciosCursos[P]>
      : GetScalarType<T[P], AggregatePreciosCursos[P]>
  }




  export type preciosCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preciosCursosWhereInput
    orderBy?: preciosCursosOrderByWithAggregationInput | preciosCursosOrderByWithAggregationInput[]
    by: PreciosCursosScalarFieldEnum[] | PreciosCursosScalarFieldEnum
    having?: preciosCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreciosCursosCountAggregateInputType | true
    _avg?: PreciosCursosAvgAggregateInputType
    _sum?: PreciosCursosSumAggregateInputType
    _min?: PreciosCursosMinAggregateInputType
    _max?: PreciosCursosMaxAggregateInputType
  }

  export type PreciosCursosGroupByOutputType = {
    id: string
    edicionId: string
    esDescuento: boolean
    esPrecioDefault: boolean
    fechaFin: Date | null
    fechaInicio: Date | null
    moneda: string
    nombre: string
    porcentajeDescuento: number | null
    precio: number
    precioOriginal: number | null
    creadoEn: Date
    actualizadoEn: Date
    _count: PreciosCursosCountAggregateOutputType | null
    _avg: PreciosCursosAvgAggregateOutputType | null
    _sum: PreciosCursosSumAggregateOutputType | null
    _min: PreciosCursosMinAggregateOutputType | null
    _max: PreciosCursosMaxAggregateOutputType | null
  }

  type GetPreciosCursosGroupByPayload<T extends preciosCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreciosCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreciosCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreciosCursosGroupByOutputType[P]>
            : GetScalarType<T[P], PreciosCursosGroupByOutputType[P]>
        }
      >
    >


  export type preciosCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    moneda?: boolean
    nombre?: boolean
    porcentajeDescuento?: boolean
    precio?: boolean
    precioOriginal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preciosCursos"]>

  export type preciosCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    moneda?: boolean
    nombre?: boolean
    porcentajeDescuento?: boolean
    precio?: boolean
    precioOriginal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preciosCursos"]>

  export type preciosCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    moneda?: boolean
    nombre?: boolean
    porcentajeDescuento?: boolean
    precio?: boolean
    precioOriginal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preciosCursos"]>

  export type preciosCursosSelectScalar = {
    id?: boolean
    edicionId?: boolean
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    moneda?: boolean
    nombre?: boolean
    porcentajeDescuento?: boolean
    precio?: boolean
    precioOriginal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type preciosCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "edicionId" | "esDescuento" | "esPrecioDefault" | "fechaFin" | "fechaInicio" | "moneda" | "nombre" | "porcentajeDescuento" | "precio" | "precioOriginal" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["preciosCursos"]>
  export type preciosCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type preciosCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type preciosCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }

  export type $preciosCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "preciosCursos"
    objects: {
      edicion: Prisma.$edicionesCursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      edicionId: string
      esDescuento: boolean
      esPrecioDefault: boolean
      fechaFin: Date | null
      fechaInicio: Date | null
      moneda: string
      nombre: string
      porcentajeDescuento: number | null
      precio: number
      precioOriginal: number | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["preciosCursos"]>
    composites: {}
  }

  type preciosCursosGetPayload<S extends boolean | null | undefined | preciosCursosDefaultArgs> = $Result.GetResult<Prisma.$preciosCursosPayload, S>

  type preciosCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<preciosCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreciosCursosCountAggregateInputType | true
    }

  export interface preciosCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['preciosCursos'], meta: { name: 'preciosCursos' } }
    /**
     * Find zero or one PreciosCursos that matches the filter.
     * @param {preciosCursosFindUniqueArgs} args - Arguments to find a PreciosCursos
     * @example
     * // Get one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends preciosCursosFindUniqueArgs>(args: SelectSubset<T, preciosCursosFindUniqueArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PreciosCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {preciosCursosFindUniqueOrThrowArgs} args - Arguments to find a PreciosCursos
     * @example
     * // Get one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends preciosCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, preciosCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreciosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosFindFirstArgs} args - Arguments to find a PreciosCursos
     * @example
     * // Get one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends preciosCursosFindFirstArgs>(args?: SelectSubset<T, preciosCursosFindFirstArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreciosCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosFindFirstOrThrowArgs} args - Arguments to find a PreciosCursos
     * @example
     * // Get one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends preciosCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, preciosCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PreciosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findMany()
     * 
     * // Get first 10 PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preciosCursosWithIdOnly = await prisma.preciosCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends preciosCursosFindManyArgs>(args?: SelectSubset<T, preciosCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PreciosCursos.
     * @param {preciosCursosCreateArgs} args - Arguments to create a PreciosCursos.
     * @example
     * // Create one PreciosCursos
     * const PreciosCursos = await prisma.preciosCursos.create({
     *   data: {
     *     // ... data to create a PreciosCursos
     *   }
     * })
     * 
     */
    create<T extends preciosCursosCreateArgs>(args: SelectSubset<T, preciosCursosCreateArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PreciosCursos.
     * @param {preciosCursosCreateManyArgs} args - Arguments to create many PreciosCursos.
     * @example
     * // Create many PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends preciosCursosCreateManyArgs>(args?: SelectSubset<T, preciosCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreciosCursos and returns the data saved in the database.
     * @param {preciosCursosCreateManyAndReturnArgs} args - Arguments to create many PreciosCursos.
     * @example
     * // Create many PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreciosCursos and only return the `id`
     * const preciosCursosWithIdOnly = await prisma.preciosCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends preciosCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, preciosCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PreciosCursos.
     * @param {preciosCursosDeleteArgs} args - Arguments to delete one PreciosCursos.
     * @example
     * // Delete one PreciosCursos
     * const PreciosCursos = await prisma.preciosCursos.delete({
     *   where: {
     *     // ... filter to delete one PreciosCursos
     *   }
     * })
     * 
     */
    delete<T extends preciosCursosDeleteArgs>(args: SelectSubset<T, preciosCursosDeleteArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PreciosCursos.
     * @param {preciosCursosUpdateArgs} args - Arguments to update one PreciosCursos.
     * @example
     * // Update one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends preciosCursosUpdateArgs>(args: SelectSubset<T, preciosCursosUpdateArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PreciosCursos.
     * @param {preciosCursosDeleteManyArgs} args - Arguments to filter PreciosCursos to delete.
     * @example
     * // Delete a few PreciosCursos
     * const { count } = await prisma.preciosCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends preciosCursosDeleteManyArgs>(args?: SelectSubset<T, preciosCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreciosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends preciosCursosUpdateManyArgs>(args: SelectSubset<T, preciosCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreciosCursos and returns the data updated in the database.
     * @param {preciosCursosUpdateManyAndReturnArgs} args - Arguments to update many PreciosCursos.
     * @example
     * // Update many PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreciosCursos and only return the `id`
     * const preciosCursosWithIdOnly = await prisma.preciosCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends preciosCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, preciosCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PreciosCursos.
     * @param {preciosCursosUpsertArgs} args - Arguments to update or create a PreciosCursos.
     * @example
     * // Update or create a PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.upsert({
     *   create: {
     *     // ... data to create a PreciosCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreciosCursos we want to update
     *   }
     * })
     */
    upsert<T extends preciosCursosUpsertArgs>(args: SelectSubset<T, preciosCursosUpsertArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PreciosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosCountArgs} args - Arguments to filter PreciosCursos to count.
     * @example
     * // Count the number of PreciosCursos
     * const count = await prisma.preciosCursos.count({
     *   where: {
     *     // ... the filter for the PreciosCursos we want to count
     *   }
     * })
    **/
    count<T extends preciosCursosCountArgs>(
      args?: Subset<T, preciosCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreciosCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreciosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreciosCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreciosCursosAggregateArgs>(args: Subset<T, PreciosCursosAggregateArgs>): Prisma.PrismaPromise<GetPreciosCursosAggregateType<T>>

    /**
     * Group by PreciosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends preciosCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: preciosCursosGroupByArgs['orderBy'] }
        : { orderBy?: preciosCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, preciosCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreciosCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the preciosCursos model
   */
  readonly fields: preciosCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for preciosCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__preciosCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicion<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the preciosCursos model
   */
  interface preciosCursosFieldRefs {
    readonly id: FieldRef<"preciosCursos", 'String'>
    readonly edicionId: FieldRef<"preciosCursos", 'String'>
    readonly esDescuento: FieldRef<"preciosCursos", 'Boolean'>
    readonly esPrecioDefault: FieldRef<"preciosCursos", 'Boolean'>
    readonly fechaFin: FieldRef<"preciosCursos", 'DateTime'>
    readonly fechaInicio: FieldRef<"preciosCursos", 'DateTime'>
    readonly moneda: FieldRef<"preciosCursos", 'String'>
    readonly nombre: FieldRef<"preciosCursos", 'String'>
    readonly porcentajeDescuento: FieldRef<"preciosCursos", 'Float'>
    readonly precio: FieldRef<"preciosCursos", 'Float'>
    readonly precioOriginal: FieldRef<"preciosCursos", 'Float'>
    readonly creadoEn: FieldRef<"preciosCursos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"preciosCursos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * preciosCursos findUnique
   */
  export type preciosCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where: preciosCursosWhereUniqueInput
  }

  /**
   * preciosCursos findUniqueOrThrow
   */
  export type preciosCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where: preciosCursosWhereUniqueInput
  }

  /**
   * preciosCursos findFirst
   */
  export type preciosCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where?: preciosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preciosCursos to fetch.
     */
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preciosCursos.
     */
    cursor?: preciosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preciosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preciosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preciosCursos.
     */
    distinct?: PreciosCursosScalarFieldEnum | PreciosCursosScalarFieldEnum[]
  }

  /**
   * preciosCursos findFirstOrThrow
   */
  export type preciosCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where?: preciosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preciosCursos to fetch.
     */
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preciosCursos.
     */
    cursor?: preciosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preciosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preciosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preciosCursos.
     */
    distinct?: PreciosCursosScalarFieldEnum | PreciosCursosScalarFieldEnum[]
  }

  /**
   * preciosCursos findMany
   */
  export type preciosCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where?: preciosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preciosCursos to fetch.
     */
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing preciosCursos.
     */
    cursor?: preciosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preciosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preciosCursos.
     */
    skip?: number
    distinct?: PreciosCursosScalarFieldEnum | PreciosCursosScalarFieldEnum[]
  }

  /**
   * preciosCursos create
   */
  export type preciosCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a preciosCursos.
     */
    data: XOR<preciosCursosCreateInput, preciosCursosUncheckedCreateInput>
  }

  /**
   * preciosCursos createMany
   */
  export type preciosCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many preciosCursos.
     */
    data: preciosCursosCreateManyInput | preciosCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * preciosCursos createManyAndReturn
   */
  export type preciosCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * The data used to create many preciosCursos.
     */
    data: preciosCursosCreateManyInput | preciosCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * preciosCursos update
   */
  export type preciosCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a preciosCursos.
     */
    data: XOR<preciosCursosUpdateInput, preciosCursosUncheckedUpdateInput>
    /**
     * Choose, which preciosCursos to update.
     */
    where: preciosCursosWhereUniqueInput
  }

  /**
   * preciosCursos updateMany
   */
  export type preciosCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update preciosCursos.
     */
    data: XOR<preciosCursosUpdateManyMutationInput, preciosCursosUncheckedUpdateManyInput>
    /**
     * Filter which preciosCursos to update
     */
    where?: preciosCursosWhereInput
    /**
     * Limit how many preciosCursos to update.
     */
    limit?: number
  }

  /**
   * preciosCursos updateManyAndReturn
   */
  export type preciosCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * The data used to update preciosCursos.
     */
    data: XOR<preciosCursosUpdateManyMutationInput, preciosCursosUncheckedUpdateManyInput>
    /**
     * Filter which preciosCursos to update
     */
    where?: preciosCursosWhereInput
    /**
     * Limit how many preciosCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * preciosCursos upsert
   */
  export type preciosCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the preciosCursos to update in case it exists.
     */
    where: preciosCursosWhereUniqueInput
    /**
     * In case the preciosCursos found by the `where` argument doesn't exist, create a new preciosCursos with this data.
     */
    create: XOR<preciosCursosCreateInput, preciosCursosUncheckedCreateInput>
    /**
     * In case the preciosCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<preciosCursosUpdateInput, preciosCursosUncheckedUpdateInput>
  }

  /**
   * preciosCursos delete
   */
  export type preciosCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter which preciosCursos to delete.
     */
    where: preciosCursosWhereUniqueInput
  }

  /**
   * preciosCursos deleteMany
   */
  export type preciosCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preciosCursos to delete
     */
    where?: preciosCursosWhereInput
    /**
     * Limit how many preciosCursos to delete.
     */
    limit?: number
  }

  /**
   * preciosCursos without action
   */
  export type preciosCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
  }


  /**
   * Model compras
   */

  export type AggregateCompras = {
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  export type ComprasAvgAggregateOutputType = {
    monto: number | null
  }

  export type ComprasSumAggregateOutputType = {
    monto: number | null
  }

  export type ComprasMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    edicionId: string | null
    monto: number | null
    moneda: string | null
    providerId: string | null
    comprobado: boolean | null
    fechaCompra: Date | null
    metodo: string | null
    usuariosEstudiantesId: string | null
  }

  export type ComprasMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    edicionId: string | null
    monto: number | null
    moneda: string | null
    providerId: string | null
    comprobado: boolean | null
    fechaCompra: Date | null
    metodo: string | null
    usuariosEstudiantesId: string | null
  }

  export type ComprasCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    edicionId: number
    monto: number
    moneda: number
    providerId: number
    comprobado: number
    fechaCompra: number
    metodo: number
    usuariosEstudiantesId: number
    _all: number
  }


  export type ComprasAvgAggregateInputType = {
    monto?: true
  }

  export type ComprasSumAggregateInputType = {
    monto?: true
  }

  export type ComprasMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    edicionId?: true
    monto?: true
    moneda?: true
    providerId?: true
    comprobado?: true
    fechaCompra?: true
    metodo?: true
    usuariosEstudiantesId?: true
  }

  export type ComprasMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    edicionId?: true
    monto?: true
    moneda?: true
    providerId?: true
    comprobado?: true
    fechaCompra?: true
    metodo?: true
    usuariosEstudiantesId?: true
  }

  export type ComprasCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    edicionId?: true
    monto?: true
    moneda?: true
    providerId?: true
    comprobado?: true
    fechaCompra?: true
    metodo?: true
    usuariosEstudiantesId?: true
    _all?: true
  }

  export type ComprasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compras to aggregate.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned compras
    **/
    _count?: true | ComprasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComprasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComprasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComprasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComprasMaxAggregateInputType
  }

  export type GetComprasAggregateType<T extends ComprasAggregateArgs> = {
        [P in keyof T & keyof AggregateCompras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompras[P]>
      : GetScalarType<T[P], AggregateCompras[P]>
  }




  export type comprasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprasWhereInput
    orderBy?: comprasOrderByWithAggregationInput | comprasOrderByWithAggregationInput[]
    by: ComprasScalarFieldEnum[] | ComprasScalarFieldEnum
    having?: comprasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComprasCountAggregateInputType | true
    _avg?: ComprasAvgAggregateInputType
    _sum?: ComprasSumAggregateInputType
    _min?: ComprasMinAggregateInputType
    _max?: ComprasMaxAggregateInputType
  }

  export type ComprasGroupByOutputType = {
    id: string
    nombre: string
    apellido: string
    edicionId: string
    monto: number
    moneda: string
    providerId: string
    comprobado: boolean
    fechaCompra: Date
    metodo: string | null
    usuariosEstudiantesId: string | null
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  type GetComprasGroupByPayload<T extends comprasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComprasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComprasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComprasGroupByOutputType[P]>
            : GetScalarType<T[P], ComprasGroupByOutputType[P]>
        }
      >
    >


  export type comprasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    edicionId?: boolean
    monto?: boolean
    moneda?: boolean
    providerId?: boolean
    comprobado?: boolean
    fechaCompra?: boolean
    metodo?: boolean
    usuariosEstudiantesId?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    inscripcion?: boolean | compras$inscripcionArgs<ExtArgs>
    usuario?: boolean | compras$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["compras"]>

  export type comprasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    edicionId?: boolean
    monto?: boolean
    moneda?: boolean
    providerId?: boolean
    comprobado?: boolean
    fechaCompra?: boolean
    metodo?: boolean
    usuariosEstudiantesId?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuario?: boolean | compras$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["compras"]>

  export type comprasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    edicionId?: boolean
    monto?: boolean
    moneda?: boolean
    providerId?: boolean
    comprobado?: boolean
    fechaCompra?: boolean
    metodo?: boolean
    usuariosEstudiantesId?: boolean
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuario?: boolean | compras$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["compras"]>

  export type comprasSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    edicionId?: boolean
    monto?: boolean
    moneda?: boolean
    providerId?: boolean
    comprobado?: boolean
    fechaCompra?: boolean
    metodo?: boolean
    usuariosEstudiantesId?: boolean
  }

  export type comprasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellido" | "edicionId" | "monto" | "moneda" | "providerId" | "comprobado" | "fechaCompra" | "metodo" | "usuariosEstudiantesId", ExtArgs["result"]["compras"]>
  export type comprasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    inscripcion?: boolean | compras$inscripcionArgs<ExtArgs>
    usuario?: boolean | compras$usuarioArgs<ExtArgs>
  }
  export type comprasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuario?: boolean | compras$usuarioArgs<ExtArgs>
  }
  export type comprasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicion?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuario?: boolean | compras$usuarioArgs<ExtArgs>
  }

  export type $comprasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "compras"
    objects: {
      edicion: Prisma.$edicionesCursosPayload<ExtArgs>
      inscripcion: Prisma.$inscripcionesPayload<ExtArgs> | null
      usuario: Prisma.$usuariosEstudiantesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      apellido: string
      edicionId: string
      monto: number
      moneda: string
      providerId: string
      comprobado: boolean
      fechaCompra: Date
      metodo: string | null
      usuariosEstudiantesId: string | null
    }, ExtArgs["result"]["compras"]>
    composites: {}
  }

  type comprasGetPayload<S extends boolean | null | undefined | comprasDefaultArgs> = $Result.GetResult<Prisma.$comprasPayload, S>

  type comprasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<comprasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComprasCountAggregateInputType | true
    }

  export interface comprasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['compras'], meta: { name: 'compras' } }
    /**
     * Find zero or one Compras that matches the filter.
     * @param {comprasFindUniqueArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comprasFindUniqueArgs>(args: SelectSubset<T, comprasFindUniqueArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Compras that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {comprasFindUniqueOrThrowArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comprasFindUniqueOrThrowArgs>(args: SelectSubset<T, comprasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasFindFirstArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comprasFindFirstArgs>(args?: SelectSubset<T, comprasFindFirstArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compras that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasFindFirstOrThrowArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comprasFindFirstOrThrowArgs>(args?: SelectSubset<T, comprasFindFirstOrThrowArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Compras
     * const compras = await prisma.compras.findMany()
     * 
     * // Get first 10 Compras
     * const compras = await prisma.compras.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comprasWithIdOnly = await prisma.compras.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends comprasFindManyArgs>(args?: SelectSubset<T, comprasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Compras.
     * @param {comprasCreateArgs} args - Arguments to create a Compras.
     * @example
     * // Create one Compras
     * const Compras = await prisma.compras.create({
     *   data: {
     *     // ... data to create a Compras
     *   }
     * })
     * 
     */
    create<T extends comprasCreateArgs>(args: SelectSubset<T, comprasCreateArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Compras.
     * @param {comprasCreateManyArgs} args - Arguments to create many Compras.
     * @example
     * // Create many Compras
     * const compras = await prisma.compras.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comprasCreateManyArgs>(args?: SelectSubset<T, comprasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Compras and returns the data saved in the database.
     * @param {comprasCreateManyAndReturnArgs} args - Arguments to create many Compras.
     * @example
     * // Create many Compras
     * const compras = await prisma.compras.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Compras and only return the `id`
     * const comprasWithIdOnly = await prisma.compras.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends comprasCreateManyAndReturnArgs>(args?: SelectSubset<T, comprasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Compras.
     * @param {comprasDeleteArgs} args - Arguments to delete one Compras.
     * @example
     * // Delete one Compras
     * const Compras = await prisma.compras.delete({
     *   where: {
     *     // ... filter to delete one Compras
     *   }
     * })
     * 
     */
    delete<T extends comprasDeleteArgs>(args: SelectSubset<T, comprasDeleteArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Compras.
     * @param {comprasUpdateArgs} args - Arguments to update one Compras.
     * @example
     * // Update one Compras
     * const compras = await prisma.compras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comprasUpdateArgs>(args: SelectSubset<T, comprasUpdateArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Compras.
     * @param {comprasDeleteManyArgs} args - Arguments to filter Compras to delete.
     * @example
     * // Delete a few Compras
     * const { count } = await prisma.compras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comprasDeleteManyArgs>(args?: SelectSubset<T, comprasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Compras
     * const compras = await prisma.compras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comprasUpdateManyArgs>(args: SelectSubset<T, comprasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compras and returns the data updated in the database.
     * @param {comprasUpdateManyAndReturnArgs} args - Arguments to update many Compras.
     * @example
     * // Update many Compras
     * const compras = await prisma.compras.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Compras and only return the `id`
     * const comprasWithIdOnly = await prisma.compras.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends comprasUpdateManyAndReturnArgs>(args: SelectSubset<T, comprasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Compras.
     * @param {comprasUpsertArgs} args - Arguments to update or create a Compras.
     * @example
     * // Update or create a Compras
     * const compras = await prisma.compras.upsert({
     *   create: {
     *     // ... data to create a Compras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compras we want to update
     *   }
     * })
     */
    upsert<T extends comprasUpsertArgs>(args: SelectSubset<T, comprasUpsertArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasCountArgs} args - Arguments to filter Compras to count.
     * @example
     * // Count the number of Compras
     * const count = await prisma.compras.count({
     *   where: {
     *     // ... the filter for the Compras we want to count
     *   }
     * })
    **/
    count<T extends comprasCountArgs>(
      args?: Subset<T, comprasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComprasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComprasAggregateArgs>(args: Subset<T, ComprasAggregateArgs>): Prisma.PrismaPromise<GetComprasAggregateType<T>>

    /**
     * Group by Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comprasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comprasGroupByArgs['orderBy'] }
        : { orderBy?: comprasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comprasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComprasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the compras model
   */
  readonly fields: comprasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for compras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comprasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicion<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inscripcion<T extends compras$inscripcionArgs<ExtArgs> = {}>(args?: Subset<T, compras$inscripcionArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usuario<T extends compras$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, compras$usuarioArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the compras model
   */
  interface comprasFieldRefs {
    readonly id: FieldRef<"compras", 'String'>
    readonly nombre: FieldRef<"compras", 'String'>
    readonly apellido: FieldRef<"compras", 'String'>
    readonly edicionId: FieldRef<"compras", 'String'>
    readonly monto: FieldRef<"compras", 'Float'>
    readonly moneda: FieldRef<"compras", 'String'>
    readonly providerId: FieldRef<"compras", 'String'>
    readonly comprobado: FieldRef<"compras", 'Boolean'>
    readonly fechaCompra: FieldRef<"compras", 'DateTime'>
    readonly metodo: FieldRef<"compras", 'String'>
    readonly usuariosEstudiantesId: FieldRef<"compras", 'String'>
  }
    

  // Custom InputTypes
  /**
   * compras findUnique
   */
  export type comprasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where: comprasWhereUniqueInput
  }

  /**
   * compras findUniqueOrThrow
   */
  export type comprasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where: comprasWhereUniqueInput
  }

  /**
   * compras findFirst
   */
  export type comprasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compras.
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compras.
     */
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * compras findFirstOrThrow
   */
  export type comprasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compras.
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compras.
     */
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * compras findMany
   */
  export type comprasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing compras.
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * compras create
   */
  export type comprasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * The data needed to create a compras.
     */
    data: XOR<comprasCreateInput, comprasUncheckedCreateInput>
  }

  /**
   * compras createMany
   */
  export type comprasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many compras.
     */
    data: comprasCreateManyInput | comprasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * compras createManyAndReturn
   */
  export type comprasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * The data used to create many compras.
     */
    data: comprasCreateManyInput | comprasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * compras update
   */
  export type comprasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * The data needed to update a compras.
     */
    data: XOR<comprasUpdateInput, comprasUncheckedUpdateInput>
    /**
     * Choose, which compras to update.
     */
    where: comprasWhereUniqueInput
  }

  /**
   * compras updateMany
   */
  export type comprasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update compras.
     */
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyInput>
    /**
     * Filter which compras to update
     */
    where?: comprasWhereInput
    /**
     * Limit how many compras to update.
     */
    limit?: number
  }

  /**
   * compras updateManyAndReturn
   */
  export type comprasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * The data used to update compras.
     */
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyInput>
    /**
     * Filter which compras to update
     */
    where?: comprasWhereInput
    /**
     * Limit how many compras to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * compras upsert
   */
  export type comprasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * The filter to search for the compras to update in case it exists.
     */
    where: comprasWhereUniqueInput
    /**
     * In case the compras found by the `where` argument doesn't exist, create a new compras with this data.
     */
    create: XOR<comprasCreateInput, comprasUncheckedCreateInput>
    /**
     * In case the compras was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comprasUpdateInput, comprasUncheckedUpdateInput>
  }

  /**
   * compras delete
   */
  export type comprasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter which compras to delete.
     */
    where: comprasWhereUniqueInput
  }

  /**
   * compras deleteMany
   */
  export type comprasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compras to delete
     */
    where?: comprasWhereInput
    /**
     * Limit how many compras to delete.
     */
    limit?: number
  }

  /**
   * compras.inscripcion
   */
  export type compras$inscripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    where?: inscripcionesWhereInput
  }

  /**
   * compras.usuario
   */
  export type compras$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    where?: usuariosEstudiantesWhereInput
  }

  /**
   * compras without action
   */
  export type comprasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
  }


  /**
   * Model grabaciones
   */

  export type AggregateGrabaciones = {
    _count: GrabacionesCountAggregateOutputType | null
    _avg: GrabacionesAvgAggregateOutputType | null
    _sum: GrabacionesSumAggregateOutputType | null
    _min: GrabacionesMinAggregateOutputType | null
    _max: GrabacionesMaxAggregateOutputType | null
  }

  export type GrabacionesAvgAggregateOutputType = {
    duracionSegundos: number | null
  }

  export type GrabacionesSumAggregateOutputType = {
    duracionSegundos: number | null
  }

  export type GrabacionesMinAggregateOutputType = {
    id: string | null
    claseId: string | null
    usuarioId: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    duracionSegundos: number | null
    completada: boolean | null
  }

  export type GrabacionesMaxAggregateOutputType = {
    id: string | null
    claseId: string | null
    usuarioId: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    duracionSegundos: number | null
    completada: boolean | null
  }

  export type GrabacionesCountAggregateOutputType = {
    id: number
    claseId: number
    usuarioId: number
    fechaInicio: number
    fechaFin: number
    duracionSegundos: number
    completada: number
    _all: number
  }


  export type GrabacionesAvgAggregateInputType = {
    duracionSegundos?: true
  }

  export type GrabacionesSumAggregateInputType = {
    duracionSegundos?: true
  }

  export type GrabacionesMinAggregateInputType = {
    id?: true
    claseId?: true
    usuarioId?: true
    fechaInicio?: true
    fechaFin?: true
    duracionSegundos?: true
    completada?: true
  }

  export type GrabacionesMaxAggregateInputType = {
    id?: true
    claseId?: true
    usuarioId?: true
    fechaInicio?: true
    fechaFin?: true
    duracionSegundos?: true
    completada?: true
  }

  export type GrabacionesCountAggregateInputType = {
    id?: true
    claseId?: true
    usuarioId?: true
    fechaInicio?: true
    fechaFin?: true
    duracionSegundos?: true
    completada?: true
    _all?: true
  }

  export type GrabacionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grabaciones to aggregate.
     */
    where?: grabacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grabaciones to fetch.
     */
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: grabacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grabaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grabaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grabaciones
    **/
    _count?: true | GrabacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GrabacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GrabacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrabacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrabacionesMaxAggregateInputType
  }

  export type GetGrabacionesAggregateType<T extends GrabacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateGrabaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrabaciones[P]>
      : GetScalarType<T[P], AggregateGrabaciones[P]>
  }




  export type grabacionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grabacionesWhereInput
    orderBy?: grabacionesOrderByWithAggregationInput | grabacionesOrderByWithAggregationInput[]
    by: GrabacionesScalarFieldEnum[] | GrabacionesScalarFieldEnum
    having?: grabacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrabacionesCountAggregateInputType | true
    _avg?: GrabacionesAvgAggregateInputType
    _sum?: GrabacionesSumAggregateInputType
    _min?: GrabacionesMinAggregateInputType
    _max?: GrabacionesMaxAggregateInputType
  }

  export type GrabacionesGroupByOutputType = {
    id: string
    claseId: string
    usuarioId: string
    fechaInicio: Date
    fechaFin: Date | null
    duracionSegundos: number | null
    completada: boolean
    _count: GrabacionesCountAggregateOutputType | null
    _avg: GrabacionesAvgAggregateOutputType | null
    _sum: GrabacionesSumAggregateOutputType | null
    _min: GrabacionesMinAggregateOutputType | null
    _max: GrabacionesMaxAggregateOutputType | null
  }

  type GetGrabacionesGroupByPayload<T extends grabacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GrabacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrabacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrabacionesGroupByOutputType[P]>
            : GetScalarType<T[P], GrabacionesGroupByOutputType[P]>
        }
      >
    >


  export type grabacionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    duracionSegundos?: boolean
    completada?: boolean
    clase?: boolean | clasesDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grabaciones"]>

  export type grabacionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    duracionSegundos?: boolean
    completada?: boolean
    clase?: boolean | clasesDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grabaciones"]>

  export type grabacionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    duracionSegundos?: boolean
    completada?: boolean
    clase?: boolean | clasesDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grabaciones"]>

  export type grabacionesSelectScalar = {
    id?: boolean
    claseId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    duracionSegundos?: boolean
    completada?: boolean
  }

  export type grabacionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "claseId" | "usuarioId" | "fechaInicio" | "fechaFin" | "duracionSegundos" | "completada", ExtArgs["result"]["grabaciones"]>
  export type grabacionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clase?: boolean | clasesDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }
  export type grabacionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clase?: boolean | clasesDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }
  export type grabacionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clase?: boolean | clasesDefaultArgs<ExtArgs>
    usuario?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }

  export type $grabacionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grabaciones"
    objects: {
      clase: Prisma.$clasesPayload<ExtArgs>
      usuario: Prisma.$usuariosAdministradoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claseId: string
      usuarioId: string
      fechaInicio: Date
      fechaFin: Date | null
      duracionSegundos: number | null
      completada: boolean
    }, ExtArgs["result"]["grabaciones"]>
    composites: {}
  }

  type grabacionesGetPayload<S extends boolean | null | undefined | grabacionesDefaultArgs> = $Result.GetResult<Prisma.$grabacionesPayload, S>

  type grabacionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<grabacionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GrabacionesCountAggregateInputType | true
    }

  export interface grabacionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grabaciones'], meta: { name: 'grabaciones' } }
    /**
     * Find zero or one Grabaciones that matches the filter.
     * @param {grabacionesFindUniqueArgs} args - Arguments to find a Grabaciones
     * @example
     * // Get one Grabaciones
     * const grabaciones = await prisma.grabaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends grabacionesFindUniqueArgs>(args: SelectSubset<T, grabacionesFindUniqueArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grabaciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {grabacionesFindUniqueOrThrowArgs} args - Arguments to find a Grabaciones
     * @example
     * // Get one Grabaciones
     * const grabaciones = await prisma.grabaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends grabacionesFindUniqueOrThrowArgs>(args: SelectSubset<T, grabacionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grabaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesFindFirstArgs} args - Arguments to find a Grabaciones
     * @example
     * // Get one Grabaciones
     * const grabaciones = await prisma.grabaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends grabacionesFindFirstArgs>(args?: SelectSubset<T, grabacionesFindFirstArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grabaciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesFindFirstOrThrowArgs} args - Arguments to find a Grabaciones
     * @example
     * // Get one Grabaciones
     * const grabaciones = await prisma.grabaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends grabacionesFindFirstOrThrowArgs>(args?: SelectSubset<T, grabacionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grabaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grabaciones
     * const grabaciones = await prisma.grabaciones.findMany()
     * 
     * // Get first 10 Grabaciones
     * const grabaciones = await prisma.grabaciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grabacionesWithIdOnly = await prisma.grabaciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends grabacionesFindManyArgs>(args?: SelectSubset<T, grabacionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grabaciones.
     * @param {grabacionesCreateArgs} args - Arguments to create a Grabaciones.
     * @example
     * // Create one Grabaciones
     * const Grabaciones = await prisma.grabaciones.create({
     *   data: {
     *     // ... data to create a Grabaciones
     *   }
     * })
     * 
     */
    create<T extends grabacionesCreateArgs>(args: SelectSubset<T, grabacionesCreateArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grabaciones.
     * @param {grabacionesCreateManyArgs} args - Arguments to create many Grabaciones.
     * @example
     * // Create many Grabaciones
     * const grabaciones = await prisma.grabaciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends grabacionesCreateManyArgs>(args?: SelectSubset<T, grabacionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grabaciones and returns the data saved in the database.
     * @param {grabacionesCreateManyAndReturnArgs} args - Arguments to create many Grabaciones.
     * @example
     * // Create many Grabaciones
     * const grabaciones = await prisma.grabaciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grabaciones and only return the `id`
     * const grabacionesWithIdOnly = await prisma.grabaciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends grabacionesCreateManyAndReturnArgs>(args?: SelectSubset<T, grabacionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grabaciones.
     * @param {grabacionesDeleteArgs} args - Arguments to delete one Grabaciones.
     * @example
     * // Delete one Grabaciones
     * const Grabaciones = await prisma.grabaciones.delete({
     *   where: {
     *     // ... filter to delete one Grabaciones
     *   }
     * })
     * 
     */
    delete<T extends grabacionesDeleteArgs>(args: SelectSubset<T, grabacionesDeleteArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grabaciones.
     * @param {grabacionesUpdateArgs} args - Arguments to update one Grabaciones.
     * @example
     * // Update one Grabaciones
     * const grabaciones = await prisma.grabaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends grabacionesUpdateArgs>(args: SelectSubset<T, grabacionesUpdateArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grabaciones.
     * @param {grabacionesDeleteManyArgs} args - Arguments to filter Grabaciones to delete.
     * @example
     * // Delete a few Grabaciones
     * const { count } = await prisma.grabaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends grabacionesDeleteManyArgs>(args?: SelectSubset<T, grabacionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grabaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grabaciones
     * const grabaciones = await prisma.grabaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends grabacionesUpdateManyArgs>(args: SelectSubset<T, grabacionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grabaciones and returns the data updated in the database.
     * @param {grabacionesUpdateManyAndReturnArgs} args - Arguments to update many Grabaciones.
     * @example
     * // Update many Grabaciones
     * const grabaciones = await prisma.grabaciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grabaciones and only return the `id`
     * const grabacionesWithIdOnly = await prisma.grabaciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends grabacionesUpdateManyAndReturnArgs>(args: SelectSubset<T, grabacionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grabaciones.
     * @param {grabacionesUpsertArgs} args - Arguments to update or create a Grabaciones.
     * @example
     * // Update or create a Grabaciones
     * const grabaciones = await prisma.grabaciones.upsert({
     *   create: {
     *     // ... data to create a Grabaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grabaciones we want to update
     *   }
     * })
     */
    upsert<T extends grabacionesUpsertArgs>(args: SelectSubset<T, grabacionesUpsertArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grabaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesCountArgs} args - Arguments to filter Grabaciones to count.
     * @example
     * // Count the number of Grabaciones
     * const count = await prisma.grabaciones.count({
     *   where: {
     *     // ... the filter for the Grabaciones we want to count
     *   }
     * })
    **/
    count<T extends grabacionesCountArgs>(
      args?: Subset<T, grabacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrabacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grabaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrabacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrabacionesAggregateArgs>(args: Subset<T, GrabacionesAggregateArgs>): Prisma.PrismaPromise<GetGrabacionesAggregateType<T>>

    /**
     * Group by Grabaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends grabacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grabacionesGroupByArgs['orderBy'] }
        : { orderBy?: grabacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, grabacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrabacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grabaciones model
   */
  readonly fields: grabacionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grabaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grabacionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clase<T extends clasesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clasesDefaultArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends usuariosAdministradoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradoresDefaultArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the grabaciones model
   */
  interface grabacionesFieldRefs {
    readonly id: FieldRef<"grabaciones", 'String'>
    readonly claseId: FieldRef<"grabaciones", 'String'>
    readonly usuarioId: FieldRef<"grabaciones", 'String'>
    readonly fechaInicio: FieldRef<"grabaciones", 'DateTime'>
    readonly fechaFin: FieldRef<"grabaciones", 'DateTime'>
    readonly duracionSegundos: FieldRef<"grabaciones", 'Int'>
    readonly completada: FieldRef<"grabaciones", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * grabaciones findUnique
   */
  export type grabacionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where: grabacionesWhereUniqueInput
  }

  /**
   * grabaciones findUniqueOrThrow
   */
  export type grabacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where: grabacionesWhereUniqueInput
  }

  /**
   * grabaciones findFirst
   */
  export type grabacionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where?: grabacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grabaciones to fetch.
     */
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grabaciones.
     */
    cursor?: grabacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grabaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grabaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grabaciones.
     */
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * grabaciones findFirstOrThrow
   */
  export type grabacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where?: grabacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grabaciones to fetch.
     */
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grabaciones.
     */
    cursor?: grabacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grabaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grabaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grabaciones.
     */
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * grabaciones findMany
   */
  export type grabacionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where?: grabacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grabaciones to fetch.
     */
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grabaciones.
     */
    cursor?: grabacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grabaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grabaciones.
     */
    skip?: number
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * grabaciones create
   */
  export type grabacionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * The data needed to create a grabaciones.
     */
    data: XOR<grabacionesCreateInput, grabacionesUncheckedCreateInput>
  }

  /**
   * grabaciones createMany
   */
  export type grabacionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grabaciones.
     */
    data: grabacionesCreateManyInput | grabacionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grabaciones createManyAndReturn
   */
  export type grabacionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * The data used to create many grabaciones.
     */
    data: grabacionesCreateManyInput | grabacionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * grabaciones update
   */
  export type grabacionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * The data needed to update a grabaciones.
     */
    data: XOR<grabacionesUpdateInput, grabacionesUncheckedUpdateInput>
    /**
     * Choose, which grabaciones to update.
     */
    where: grabacionesWhereUniqueInput
  }

  /**
   * grabaciones updateMany
   */
  export type grabacionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grabaciones.
     */
    data: XOR<grabacionesUpdateManyMutationInput, grabacionesUncheckedUpdateManyInput>
    /**
     * Filter which grabaciones to update
     */
    where?: grabacionesWhereInput
    /**
     * Limit how many grabaciones to update.
     */
    limit?: number
  }

  /**
   * grabaciones updateManyAndReturn
   */
  export type grabacionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * The data used to update grabaciones.
     */
    data: XOR<grabacionesUpdateManyMutationInput, grabacionesUncheckedUpdateManyInput>
    /**
     * Filter which grabaciones to update
     */
    where?: grabacionesWhereInput
    /**
     * Limit how many grabaciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * grabaciones upsert
   */
  export type grabacionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * The filter to search for the grabaciones to update in case it exists.
     */
    where: grabacionesWhereUniqueInput
    /**
     * In case the grabaciones found by the `where` argument doesn't exist, create a new grabaciones with this data.
     */
    create: XOR<grabacionesCreateInput, grabacionesUncheckedCreateInput>
    /**
     * In case the grabaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grabacionesUpdateInput, grabacionesUncheckedUpdateInput>
  }

  /**
   * grabaciones delete
   */
  export type grabacionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter which grabaciones to delete.
     */
    where: grabacionesWhereUniqueInput
  }

  /**
   * grabaciones deleteMany
   */
  export type grabacionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grabaciones to delete
     */
    where?: grabacionesWhereInput
    /**
     * Limit how many grabaciones to delete.
     */
    limit?: number
  }

  /**
   * grabaciones without action
   */
  export type grabacionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuditoriaScalarFieldEnum: {
    id: 'id',
    tabla: 'tabla',
    registroId: 'registroId',
    accion: 'accion',
    detalles: 'detalles',
    usuarioId: 'usuarioId',
    creadoEn: 'creadoEn'
  };

  export type AuditoriaScalarFieldEnum = (typeof AuditoriaScalarFieldEnum)[keyof typeof AuditoriaScalarFieldEnum]


  export const CategoriasScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type CategoriasScalarFieldEnum = (typeof CategoriasScalarFieldEnum)[keyof typeof CategoriasScalarFieldEnum]


  export const UsuariosEstudiantesScalarFieldEnum: {
    id: 'id',
    correo: 'correo',
    contrasena: 'contrasena',
    usuario: 'usuario',
    estado: 'estado',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    avatar: 'avatar',
    estudianteId: 'estudianteId',
    registrado: 'registrado'
  };

  export type UsuariosEstudiantesScalarFieldEnum = (typeof UsuariosEstudiantesScalarFieldEnum)[keyof typeof UsuariosEstudiantesScalarFieldEnum]


  export const EstudiantesScalarFieldEnum: {
    id: 'id',
    apellido: 'apellido',
    celular: 'celular',
    pais: 'pais',
    genero: 'genero',
    fechaNacimiento: 'fechaNacimiento',
    nombre: 'nombre',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type EstudiantesScalarFieldEnum = (typeof EstudiantesScalarFieldEnum)[keyof typeof EstudiantesScalarFieldEnum]


  export const UsuariosAdministradoresScalarFieldEnum: {
    id: 'id',
    correo: 'correo',
    contrasena: 'contrasena',
    encargado: 'encargado',
    estado: 'estado',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    tipo: 'tipo'
  };

  export type UsuariosAdministradoresScalarFieldEnum = (typeof UsuariosAdministradoresScalarFieldEnum)[keyof typeof UsuariosAdministradoresScalarFieldEnum]


  export const DocenteScalarFieldEnum: {
    id: 'id',
    nombre_completo: 'nombre_completo',
    celular: 'celular',
    especialidad: 'especialidad',
    experiencia: 'experiencia',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    usuarioId: 'usuarioId'
  };

  export type DocenteScalarFieldEnum = (typeof DocenteScalarFieldEnum)[keyof typeof DocenteScalarFieldEnum]


  export const CursosScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion',
    titulo: 'titulo',
    urlMiniatura: 'urlMiniatura',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    descripcionCorta: 'descripcionCorta',
    enVivo: 'enVivo',
    urlCurso: 'urlCurso'
  };

  export type CursosScalarFieldEnum = (typeof CursosScalarFieldEnum)[keyof typeof CursosScalarFieldEnum]


  export const CategoriasCursosScalarFieldEnum: {
    id: 'id',
    categoriaId: 'categoriaId',
    cursoId: 'cursoId'
  };

  export type CategoriasCursosScalarFieldEnum = (typeof CategoriasCursosScalarFieldEnum)[keyof typeof CategoriasCursosScalarFieldEnum]


  export const ReviewsCursosScalarFieldEnum: {
    id: 'id',
    cursoId: 'cursoId',
    rating: 'rating',
    comentario: 'comentario',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    usuariosEstudiantesId: 'usuariosEstudiantesId'
  };

  export type ReviewsCursosScalarFieldEnum = (typeof ReviewsCursosScalarFieldEnum)[keyof typeof ReviewsCursosScalarFieldEnum]


  export const EdicionesCursosScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    cursoId: 'cursoId',
    descripcion: 'descripcion',
    estado: 'estado',
    fechaFin: 'fechaFin',
    fechaInicio: 'fechaInicio',
    notaMaxima: 'notaMaxima',
    notaMinima: 'notaMinima',
    urlWhatsapp: 'urlWhatsapp',
    vigente: 'vigente',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    docenteId: 'docenteId'
  };

  export type EdicionesCursosScalarFieldEnum = (typeof EdicionesCursosScalarFieldEnum)[keyof typeof EdicionesCursosScalarFieldEnum]


  export const BeneficiosCursosScalarFieldEnum: {
    id: 'id',
    cursoId: 'cursoId',
    descripcion: 'descripcion',
    orden: 'orden',
    creadoEn: 'creadoEn'
  };

  export type BeneficiosCursosScalarFieldEnum = (typeof BeneficiosCursosScalarFieldEnum)[keyof typeof BeneficiosCursosScalarFieldEnum]


  export const ObjetivosCursosScalarFieldEnum: {
    id: 'id',
    cursoId: 'cursoId',
    descripcion: 'descripcion',
    orden: 'orden',
    creadoEn: 'creadoEn'
  };

  export type ObjetivosCursosScalarFieldEnum = (typeof ObjetivosCursosScalarFieldEnum)[keyof typeof ObjetivosCursosScalarFieldEnum]


  export const RequisitosCursosScalarFieldEnum: {
    id: 'id',
    cursoId: 'cursoId',
    descripcion: 'descripcion',
    orden: 'orden',
    creadoEn: 'creadoEn'
  };

  export type RequisitosCursosScalarFieldEnum = (typeof RequisitosCursosScalarFieldEnum)[keyof typeof RequisitosCursosScalarFieldEnum]


  export const ClasesScalarFieldEnum: {
    id: 'id',
    edicionId: 'edicionId',
    descripcion: 'descripcion',
    duracion: 'duracion',
    fecha: 'fecha',
    orden: 'orden',
    titulo: 'titulo',
    urlYoutube: 'urlYoutube',
    creadoEn: 'creadoEn'
  };

  export type ClasesScalarFieldEnum = (typeof ClasesScalarFieldEnum)[keyof typeof ClasesScalarFieldEnum]


  export const MaterialesScalarFieldEnum: {
    id: 'id',
    claseId: 'claseId',
    tipo: 'tipo',
    titulo: 'titulo',
    url: 'url',
    creadoEn: 'creadoEn'
  };

  export type MaterialesScalarFieldEnum = (typeof MaterialesScalarFieldEnum)[keyof typeof MaterialesScalarFieldEnum]


  export const ExamenesScalarFieldEnum: {
    id: 'id',
    edicionId: 'edicionId',
    descripcion: 'descripcion',
    fechaDisponible: 'fechaDisponible',
    fechaLimite: 'fechaLimite',
    notaMaxima: 'notaMaxima',
    notaMinima: 'notaMinima',
    titulo: 'titulo',
    creadoEn: 'creadoEn'
  };

  export type ExamenesScalarFieldEnum = (typeof ExamenesScalarFieldEnum)[keyof typeof ExamenesScalarFieldEnum]


  export const CalificacionesScalarFieldEnum: {
    id: 'id',
    aprobado: 'aprobado',
    comentarios: 'comentarios',
    estudianteId: 'estudianteId',
    examenId: 'examenId',
    nota: 'nota',
    creadoEn: 'creadoEn'
  };

  export type CalificacionesScalarFieldEnum = (typeof CalificacionesScalarFieldEnum)[keyof typeof CalificacionesScalarFieldEnum]


  export const InscripcionesScalarFieldEnum: {
    id: 'id',
    edicionId: 'edicionId',
    estado: 'estado',
    estudianteId: 'estudianteId',
    inscritoEn: 'inscritoEn',
    actualizadoEn: 'actualizadoEn',
    compraId: 'compraId'
  };

  export type InscripcionesScalarFieldEnum = (typeof InscripcionesScalarFieldEnum)[keyof typeof InscripcionesScalarFieldEnum]


  export const CertificadosScalarFieldEnum: {
    id: 'id',
    codigoUnico: 'codigoUnico',
    edicionId: 'edicionId',
    estudianteId: 'estudianteId',
    fechaEmision: 'fechaEmision',
    notaFinal: 'notaFinal',
    urlCertificado: 'urlCertificado',
    creadoEn: 'creadoEn'
  };

  export type CertificadosScalarFieldEnum = (typeof CertificadosScalarFieldEnum)[keyof typeof CertificadosScalarFieldEnum]


  export const PreciosCursosScalarFieldEnum: {
    id: 'id',
    edicionId: 'edicionId',
    esDescuento: 'esDescuento',
    esPrecioDefault: 'esPrecioDefault',
    fechaFin: 'fechaFin',
    fechaInicio: 'fechaInicio',
    moneda: 'moneda',
    nombre: 'nombre',
    porcentajeDescuento: 'porcentajeDescuento',
    precio: 'precio',
    precioOriginal: 'precioOriginal',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type PreciosCursosScalarFieldEnum = (typeof PreciosCursosScalarFieldEnum)[keyof typeof PreciosCursosScalarFieldEnum]


  export const ComprasScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    edicionId: 'edicionId',
    monto: 'monto',
    moneda: 'moneda',
    providerId: 'providerId',
    comprobado: 'comprobado',
    fechaCompra: 'fechaCompra',
    metodo: 'metodo',
    usuariosEstudiantesId: 'usuariosEstudiantesId'
  };

  export type ComprasScalarFieldEnum = (typeof ComprasScalarFieldEnum)[keyof typeof ComprasScalarFieldEnum]


  export const GrabacionesScalarFieldEnum: {
    id: 'id',
    claseId: 'claseId',
    usuarioId: 'usuarioId',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    duracionSegundos: 'duracionSegundos',
    completada: 'completada'
  };

  export type GrabacionesScalarFieldEnum = (typeof GrabacionesScalarFieldEnum)[keyof typeof GrabacionesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AccionAuditoria'
   */
  export type EnumAccionAuditoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionAuditoria'>
    


  /**
   * Reference to a field of type 'AccionAuditoria[]'
   */
  export type ListEnumAccionAuditoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionAuditoria[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TipoGenero'
   */
  export type EnumTipoGeneroFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoGenero'>
    


  /**
   * Reference to a field of type 'TipoGenero[]'
   */
  export type ListEnumTipoGeneroFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoGenero[]'>
    


  /**
   * Reference to a field of type 'TipoCuenta'
   */
  export type EnumTipoCuentaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoCuenta'>
    


  /**
   * Reference to a field of type 'TipoCuenta[]'
   */
  export type ListEnumTipoCuentaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoCuenta[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'EdicionEstado'
   */
  export type EnumEdicionEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EdicionEstado'>
    


  /**
   * Reference to a field of type 'EdicionEstado[]'
   */
  export type ListEnumEdicionEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EdicionEstado[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type auditoriaWhereInput = {
    AND?: auditoriaWhereInput | auditoriaWhereInput[]
    OR?: auditoriaWhereInput[]
    NOT?: auditoriaWhereInput | auditoriaWhereInput[]
    id?: StringFilter<"auditoria"> | string
    tabla?: StringFilter<"auditoria"> | string
    registroId?: StringNullableFilter<"auditoria"> | string | null
    accion?: EnumAccionAuditoriaFilter<"auditoria"> | $Enums.AccionAuditoria
    detalles?: JsonNullableFilter<"auditoria">
    usuarioId?: StringNullableFilter<"auditoria"> | string | null
    creadoEn?: DateTimeFilter<"auditoria"> | Date | string
    usuario?: XOR<UsuariosAdministradoresNullableScalarRelationFilter, usuariosAdministradoresWhereInput> | null
  }

  export type auditoriaOrderByWithRelationInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrderInput | SortOrder
    accion?: SortOrder
    detalles?: SortOrderInput | SortOrder
    usuarioId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    usuario?: usuariosAdministradoresOrderByWithRelationInput
  }

  export type auditoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: auditoriaWhereInput | auditoriaWhereInput[]
    OR?: auditoriaWhereInput[]
    NOT?: auditoriaWhereInput | auditoriaWhereInput[]
    tabla?: StringFilter<"auditoria"> | string
    registroId?: StringNullableFilter<"auditoria"> | string | null
    accion?: EnumAccionAuditoriaFilter<"auditoria"> | $Enums.AccionAuditoria
    detalles?: JsonNullableFilter<"auditoria">
    usuarioId?: StringNullableFilter<"auditoria"> | string | null
    creadoEn?: DateTimeFilter<"auditoria"> | Date | string
    usuario?: XOR<UsuariosAdministradoresNullableScalarRelationFilter, usuariosAdministradoresWhereInput> | null
  }, "id">

  export type auditoriaOrderByWithAggregationInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrderInput | SortOrder
    accion?: SortOrder
    detalles?: SortOrderInput | SortOrder
    usuarioId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    _count?: auditoriaCountOrderByAggregateInput
    _max?: auditoriaMaxOrderByAggregateInput
    _min?: auditoriaMinOrderByAggregateInput
  }

  export type auditoriaScalarWhereWithAggregatesInput = {
    AND?: auditoriaScalarWhereWithAggregatesInput | auditoriaScalarWhereWithAggregatesInput[]
    OR?: auditoriaScalarWhereWithAggregatesInput[]
    NOT?: auditoriaScalarWhereWithAggregatesInput | auditoriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"auditoria"> | string
    tabla?: StringWithAggregatesFilter<"auditoria"> | string
    registroId?: StringNullableWithAggregatesFilter<"auditoria"> | string | null
    accion?: EnumAccionAuditoriaWithAggregatesFilter<"auditoria"> | $Enums.AccionAuditoria
    detalles?: JsonNullableWithAggregatesFilter<"auditoria">
    usuarioId?: StringNullableWithAggregatesFilter<"auditoria"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"auditoria"> | Date | string
  }

  export type categoriasWhereInput = {
    AND?: categoriasWhereInput | categoriasWhereInput[]
    OR?: categoriasWhereInput[]
    NOT?: categoriasWhereInput | categoriasWhereInput[]
    id?: StringFilter<"categorias"> | string
    nombre?: StringFilter<"categorias"> | string
    descripcion?: StringNullableFilter<"categorias"> | string | null
    creadoEn?: DateTimeFilter<"categorias"> | Date | string
    actualizadoEn?: DateTimeFilter<"categorias"> | Date | string
    categoriasCursos?: CategoriasCursosListRelationFilter
  }

  export type categoriasOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    categoriasCursos?: categoriasCursosOrderByRelationAggregateInput
  }

  export type categoriasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nombre?: string
    AND?: categoriasWhereInput | categoriasWhereInput[]
    OR?: categoriasWhereInput[]
    NOT?: categoriasWhereInput | categoriasWhereInput[]
    descripcion?: StringNullableFilter<"categorias"> | string | null
    creadoEn?: DateTimeFilter<"categorias"> | Date | string
    actualizadoEn?: DateTimeFilter<"categorias"> | Date | string
    categoriasCursos?: CategoriasCursosListRelationFilter
  }, "id" | "nombre">

  export type categoriasOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: categoriasCountOrderByAggregateInput
    _max?: categoriasMaxOrderByAggregateInput
    _min?: categoriasMinOrderByAggregateInput
  }

  export type categoriasScalarWhereWithAggregatesInput = {
    AND?: categoriasScalarWhereWithAggregatesInput | categoriasScalarWhereWithAggregatesInput[]
    OR?: categoriasScalarWhereWithAggregatesInput[]
    NOT?: categoriasScalarWhereWithAggregatesInput | categoriasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"categorias"> | string
    nombre?: StringWithAggregatesFilter<"categorias"> | string
    descripcion?: StringNullableWithAggregatesFilter<"categorias"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"categorias"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"categorias"> | Date | string
  }

  export type usuariosEstudiantesWhereInput = {
    AND?: usuariosEstudiantesWhereInput | usuariosEstudiantesWhereInput[]
    OR?: usuariosEstudiantesWhereInput[]
    NOT?: usuariosEstudiantesWhereInput | usuariosEstudiantesWhereInput[]
    id?: StringFilter<"usuariosEstudiantes"> | string
    correo?: StringFilter<"usuariosEstudiantes"> | string
    contrasena?: StringFilter<"usuariosEstudiantes"> | string
    usuario?: StringFilter<"usuariosEstudiantes"> | string
    estado?: BoolFilter<"usuariosEstudiantes"> | boolean
    creadoEn?: DateTimeFilter<"usuariosEstudiantes"> | Date | string
    actualizadoEn?: DateTimeFilter<"usuariosEstudiantes"> | Date | string
    avatar?: StringNullableFilter<"usuariosEstudiantes"> | string | null
    estudianteId?: StringNullableFilter<"usuariosEstudiantes"> | string | null
    registrado?: BoolFilter<"usuariosEstudiantes"> | boolean
    estudiante?: XOR<EstudiantesNullableScalarRelationFilter, estudiantesWhereInput> | null
    reviews?: ReviewsCursosListRelationFilter
    compras?: ComprasListRelationFilter
  }

  export type usuariosEstudiantesOrderByWithRelationInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrderInput | SortOrder
    estudianteId?: SortOrderInput | SortOrder
    registrado?: SortOrder
    estudiante?: estudiantesOrderByWithRelationInput
    reviews?: reviewsCursosOrderByRelationAggregateInput
    compras?: comprasOrderByRelationAggregateInput
  }

  export type usuariosEstudiantesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    correo?: string
    usuario?: string
    estudianteId?: string
    AND?: usuariosEstudiantesWhereInput | usuariosEstudiantesWhereInput[]
    OR?: usuariosEstudiantesWhereInput[]
    NOT?: usuariosEstudiantesWhereInput | usuariosEstudiantesWhereInput[]
    contrasena?: StringFilter<"usuariosEstudiantes"> | string
    estado?: BoolFilter<"usuariosEstudiantes"> | boolean
    creadoEn?: DateTimeFilter<"usuariosEstudiantes"> | Date | string
    actualizadoEn?: DateTimeFilter<"usuariosEstudiantes"> | Date | string
    avatar?: StringNullableFilter<"usuariosEstudiantes"> | string | null
    registrado?: BoolFilter<"usuariosEstudiantes"> | boolean
    estudiante?: XOR<EstudiantesNullableScalarRelationFilter, estudiantesWhereInput> | null
    reviews?: ReviewsCursosListRelationFilter
    compras?: ComprasListRelationFilter
  }, "id" | "correo" | "usuario" | "estudianteId">

  export type usuariosEstudiantesOrderByWithAggregationInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrderInput | SortOrder
    estudianteId?: SortOrderInput | SortOrder
    registrado?: SortOrder
    _count?: usuariosEstudiantesCountOrderByAggregateInput
    _max?: usuariosEstudiantesMaxOrderByAggregateInput
    _min?: usuariosEstudiantesMinOrderByAggregateInput
  }

  export type usuariosEstudiantesScalarWhereWithAggregatesInput = {
    AND?: usuariosEstudiantesScalarWhereWithAggregatesInput | usuariosEstudiantesScalarWhereWithAggregatesInput[]
    OR?: usuariosEstudiantesScalarWhereWithAggregatesInput[]
    NOT?: usuariosEstudiantesScalarWhereWithAggregatesInput | usuariosEstudiantesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"usuariosEstudiantes"> | string
    correo?: StringWithAggregatesFilter<"usuariosEstudiantes"> | string
    contrasena?: StringWithAggregatesFilter<"usuariosEstudiantes"> | string
    usuario?: StringWithAggregatesFilter<"usuariosEstudiantes"> | string
    estado?: BoolWithAggregatesFilter<"usuariosEstudiantes"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"usuariosEstudiantes"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"usuariosEstudiantes"> | Date | string
    avatar?: StringNullableWithAggregatesFilter<"usuariosEstudiantes"> | string | null
    estudianteId?: StringNullableWithAggregatesFilter<"usuariosEstudiantes"> | string | null
    registrado?: BoolWithAggregatesFilter<"usuariosEstudiantes"> | boolean
  }

  export type estudiantesWhereInput = {
    AND?: estudiantesWhereInput | estudiantesWhereInput[]
    OR?: estudiantesWhereInput[]
    NOT?: estudiantesWhereInput | estudiantesWhereInput[]
    id?: StringFilter<"estudiantes"> | string
    apellido?: StringNullableFilter<"estudiantes"> | string | null
    celular?: StringNullableFilter<"estudiantes"> | string | null
    pais?: StringNullableFilter<"estudiantes"> | string | null
    genero?: EnumTipoGeneroNullableFilter<"estudiantes"> | $Enums.TipoGenero | null
    fechaNacimiento?: DateTimeNullableFilter<"estudiantes"> | Date | string | null
    nombre?: StringFilter<"estudiantes"> | string
    creadoEn?: DateTimeFilter<"estudiantes"> | Date | string
    actualizadoEn?: DateTimeFilter<"estudiantes"> | Date | string
    usuario?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
    calificaciones?: CalificacionesListRelationFilter
    certificados?: CertificadosListRelationFilter
    inscripciones?: InscripcionesListRelationFilter
  }

  export type estudiantesOrderByWithRelationInput = {
    id?: SortOrder
    apellido?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    genero?: SortOrderInput | SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuario?: usuariosEstudiantesOrderByWithRelationInput
    calificaciones?: calificacionesOrderByRelationAggregateInput
    certificados?: certificadosOrderByRelationAggregateInput
    inscripciones?: inscripcionesOrderByRelationAggregateInput
  }

  export type estudiantesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: estudiantesWhereInput | estudiantesWhereInput[]
    OR?: estudiantesWhereInput[]
    NOT?: estudiantesWhereInput | estudiantesWhereInput[]
    apellido?: StringNullableFilter<"estudiantes"> | string | null
    celular?: StringNullableFilter<"estudiantes"> | string | null
    pais?: StringNullableFilter<"estudiantes"> | string | null
    genero?: EnumTipoGeneroNullableFilter<"estudiantes"> | $Enums.TipoGenero | null
    fechaNacimiento?: DateTimeNullableFilter<"estudiantes"> | Date | string | null
    nombre?: StringFilter<"estudiantes"> | string
    creadoEn?: DateTimeFilter<"estudiantes"> | Date | string
    actualizadoEn?: DateTimeFilter<"estudiantes"> | Date | string
    usuario?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
    calificaciones?: CalificacionesListRelationFilter
    certificados?: CertificadosListRelationFilter
    inscripciones?: InscripcionesListRelationFilter
  }, "id">

  export type estudiantesOrderByWithAggregationInput = {
    id?: SortOrder
    apellido?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    genero?: SortOrderInput | SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: estudiantesCountOrderByAggregateInput
    _max?: estudiantesMaxOrderByAggregateInput
    _min?: estudiantesMinOrderByAggregateInput
  }

  export type estudiantesScalarWhereWithAggregatesInput = {
    AND?: estudiantesScalarWhereWithAggregatesInput | estudiantesScalarWhereWithAggregatesInput[]
    OR?: estudiantesScalarWhereWithAggregatesInput[]
    NOT?: estudiantesScalarWhereWithAggregatesInput | estudiantesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"estudiantes"> | string
    apellido?: StringNullableWithAggregatesFilter<"estudiantes"> | string | null
    celular?: StringNullableWithAggregatesFilter<"estudiantes"> | string | null
    pais?: StringNullableWithAggregatesFilter<"estudiantes"> | string | null
    genero?: EnumTipoGeneroNullableWithAggregatesFilter<"estudiantes"> | $Enums.TipoGenero | null
    fechaNacimiento?: DateTimeNullableWithAggregatesFilter<"estudiantes"> | Date | string | null
    nombre?: StringWithAggregatesFilter<"estudiantes"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"estudiantes"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"estudiantes"> | Date | string
  }

  export type usuariosAdministradoresWhereInput = {
    AND?: usuariosAdministradoresWhereInput | usuariosAdministradoresWhereInput[]
    OR?: usuariosAdministradoresWhereInput[]
    NOT?: usuariosAdministradoresWhereInput | usuariosAdministradoresWhereInput[]
    id?: StringFilter<"usuariosAdministradores"> | string
    correo?: StringFilter<"usuariosAdministradores"> | string
    contrasena?: StringFilter<"usuariosAdministradores"> | string
    encargado?: StringNullableFilter<"usuariosAdministradores"> | string | null
    estado?: BoolFilter<"usuariosAdministradores"> | boolean
    creadoEn?: DateTimeFilter<"usuariosAdministradores"> | Date | string
    actualizadoEn?: DateTimeFilter<"usuariosAdministradores"> | Date | string
    tipo?: EnumTipoCuentaFilter<"usuariosAdministradores"> | $Enums.TipoCuenta
    docente?: XOR<DocenteNullableScalarRelationFilter, docenteWhereInput> | null
    auditorias?: AuditoriaListRelationFilter
    grabaciones?: GrabacionesListRelationFilter
  }

  export type usuariosAdministradoresOrderByWithRelationInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrderInput | SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
    docente?: docenteOrderByWithRelationInput
    auditorias?: auditoriaOrderByRelationAggregateInput
    grabaciones?: grabacionesOrderByRelationAggregateInput
  }

  export type usuariosAdministradoresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    correo?: string
    AND?: usuariosAdministradoresWhereInput | usuariosAdministradoresWhereInput[]
    OR?: usuariosAdministradoresWhereInput[]
    NOT?: usuariosAdministradoresWhereInput | usuariosAdministradoresWhereInput[]
    contrasena?: StringFilter<"usuariosAdministradores"> | string
    encargado?: StringNullableFilter<"usuariosAdministradores"> | string | null
    estado?: BoolFilter<"usuariosAdministradores"> | boolean
    creadoEn?: DateTimeFilter<"usuariosAdministradores"> | Date | string
    actualizadoEn?: DateTimeFilter<"usuariosAdministradores"> | Date | string
    tipo?: EnumTipoCuentaFilter<"usuariosAdministradores"> | $Enums.TipoCuenta
    docente?: XOR<DocenteNullableScalarRelationFilter, docenteWhereInput> | null
    auditorias?: AuditoriaListRelationFilter
    grabaciones?: GrabacionesListRelationFilter
  }, "id" | "correo">

  export type usuariosAdministradoresOrderByWithAggregationInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrderInput | SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
    _count?: usuariosAdministradoresCountOrderByAggregateInput
    _max?: usuariosAdministradoresMaxOrderByAggregateInput
    _min?: usuariosAdministradoresMinOrderByAggregateInput
  }

  export type usuariosAdministradoresScalarWhereWithAggregatesInput = {
    AND?: usuariosAdministradoresScalarWhereWithAggregatesInput | usuariosAdministradoresScalarWhereWithAggregatesInput[]
    OR?: usuariosAdministradoresScalarWhereWithAggregatesInput[]
    NOT?: usuariosAdministradoresScalarWhereWithAggregatesInput | usuariosAdministradoresScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"usuariosAdministradores"> | string
    correo?: StringWithAggregatesFilter<"usuariosAdministradores"> | string
    contrasena?: StringWithAggregatesFilter<"usuariosAdministradores"> | string
    encargado?: StringNullableWithAggregatesFilter<"usuariosAdministradores"> | string | null
    estado?: BoolWithAggregatesFilter<"usuariosAdministradores"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"usuariosAdministradores"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"usuariosAdministradores"> | Date | string
    tipo?: EnumTipoCuentaWithAggregatesFilter<"usuariosAdministradores"> | $Enums.TipoCuenta
  }

  export type docenteWhereInput = {
    AND?: docenteWhereInput | docenteWhereInput[]
    OR?: docenteWhereInput[]
    NOT?: docenteWhereInput | docenteWhereInput[]
    id?: StringFilter<"docente"> | string
    nombre_completo?: StringFilter<"docente"> | string
    celular?: StringNullableFilter<"docente"> | string | null
    especialidad?: StringFilter<"docente"> | string
    experiencia?: IntFilter<"docente"> | number
    creadoEn?: DateTimeFilter<"docente"> | Date | string
    actualizadoEn?: DateTimeFilter<"docente"> | Date | string
    usuarioId?: StringFilter<"docente"> | string
    usuario?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
    ediciones?: EdicionesCursosListRelationFilter
  }

  export type docenteOrderByWithRelationInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrderInput | SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
    usuario?: usuariosAdministradoresOrderByWithRelationInput
    ediciones?: edicionesCursosOrderByRelationAggregateInput
  }

  export type docenteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    usuarioId?: string
    AND?: docenteWhereInput | docenteWhereInput[]
    OR?: docenteWhereInput[]
    NOT?: docenteWhereInput | docenteWhereInput[]
    nombre_completo?: StringFilter<"docente"> | string
    celular?: StringNullableFilter<"docente"> | string | null
    especialidad?: StringFilter<"docente"> | string
    experiencia?: IntFilter<"docente"> | number
    creadoEn?: DateTimeFilter<"docente"> | Date | string
    actualizadoEn?: DateTimeFilter<"docente"> | Date | string
    usuario?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
    ediciones?: EdicionesCursosListRelationFilter
  }, "id" | "usuarioId">

  export type docenteOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrderInput | SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
    _count?: docenteCountOrderByAggregateInput
    _avg?: docenteAvgOrderByAggregateInput
    _max?: docenteMaxOrderByAggregateInput
    _min?: docenteMinOrderByAggregateInput
    _sum?: docenteSumOrderByAggregateInput
  }

  export type docenteScalarWhereWithAggregatesInput = {
    AND?: docenteScalarWhereWithAggregatesInput | docenteScalarWhereWithAggregatesInput[]
    OR?: docenteScalarWhereWithAggregatesInput[]
    NOT?: docenteScalarWhereWithAggregatesInput | docenteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"docente"> | string
    nombre_completo?: StringWithAggregatesFilter<"docente"> | string
    celular?: StringNullableWithAggregatesFilter<"docente"> | string | null
    especialidad?: StringWithAggregatesFilter<"docente"> | string
    experiencia?: IntWithAggregatesFilter<"docente"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"docente"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"docente"> | Date | string
    usuarioId?: StringWithAggregatesFilter<"docente"> | string
  }

  export type cursosWhereInput = {
    AND?: cursosWhereInput | cursosWhereInput[]
    OR?: cursosWhereInput[]
    NOT?: cursosWhereInput | cursosWhereInput[]
    id?: StringFilter<"cursos"> | string
    descripcion?: StringFilter<"cursos"> | string
    titulo?: StringFilter<"cursos"> | string
    urlMiniatura?: StringNullableFilter<"cursos"> | string | null
    creadoEn?: DateTimeFilter<"cursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"cursos"> | Date | string
    descripcionCorta?: StringNullableFilter<"cursos"> | string | null
    enVivo?: BoolFilter<"cursos"> | boolean
    urlCurso?: StringNullableFilter<"cursos"> | string | null
    ediciones?: EdicionesCursosListRelationFilter
    beneficios?: BeneficiosCursosListRelationFilter
    objetivos?: ObjetivosCursosListRelationFilter
    requisitos?: RequisitosCursosListRelationFilter
    categorias?: CategoriasCursosListRelationFilter
    reviews?: ReviewsCursosListRelationFilter
  }

  export type cursosOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrderInput | SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrderInput | SortOrder
    ediciones?: edicionesCursosOrderByRelationAggregateInput
    beneficios?: beneficiosCursosOrderByRelationAggregateInput
    objetivos?: objetivosCursosOrderByRelationAggregateInput
    requisitos?: requisitosCursosOrderByRelationAggregateInput
    categorias?: categoriasCursosOrderByRelationAggregateInput
    reviews?: reviewsCursosOrderByRelationAggregateInput
  }

  export type cursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cursosWhereInput | cursosWhereInput[]
    OR?: cursosWhereInput[]
    NOT?: cursosWhereInput | cursosWhereInput[]
    descripcion?: StringFilter<"cursos"> | string
    titulo?: StringFilter<"cursos"> | string
    urlMiniatura?: StringNullableFilter<"cursos"> | string | null
    creadoEn?: DateTimeFilter<"cursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"cursos"> | Date | string
    descripcionCorta?: StringNullableFilter<"cursos"> | string | null
    enVivo?: BoolFilter<"cursos"> | boolean
    urlCurso?: StringNullableFilter<"cursos"> | string | null
    ediciones?: EdicionesCursosListRelationFilter
    beneficios?: BeneficiosCursosListRelationFilter
    objetivos?: ObjetivosCursosListRelationFilter
    requisitos?: RequisitosCursosListRelationFilter
    categorias?: CategoriasCursosListRelationFilter
    reviews?: ReviewsCursosListRelationFilter
  }, "id">

  export type cursosOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrderInput | SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrderInput | SortOrder
    _count?: cursosCountOrderByAggregateInput
    _max?: cursosMaxOrderByAggregateInput
    _min?: cursosMinOrderByAggregateInput
  }

  export type cursosScalarWhereWithAggregatesInput = {
    AND?: cursosScalarWhereWithAggregatesInput | cursosScalarWhereWithAggregatesInput[]
    OR?: cursosScalarWhereWithAggregatesInput[]
    NOT?: cursosScalarWhereWithAggregatesInput | cursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cursos"> | string
    descripcion?: StringWithAggregatesFilter<"cursos"> | string
    titulo?: StringWithAggregatesFilter<"cursos"> | string
    urlMiniatura?: StringNullableWithAggregatesFilter<"cursos"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"cursos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"cursos"> | Date | string
    descripcionCorta?: StringNullableWithAggregatesFilter<"cursos"> | string | null
    enVivo?: BoolWithAggregatesFilter<"cursos"> | boolean
    urlCurso?: StringNullableWithAggregatesFilter<"cursos"> | string | null
  }

  export type categoriasCursosWhereInput = {
    AND?: categoriasCursosWhereInput | categoriasCursosWhereInput[]
    OR?: categoriasCursosWhereInput[]
    NOT?: categoriasCursosWhereInput | categoriasCursosWhereInput[]
    id?: StringFilter<"categoriasCursos"> | string
    categoriaId?: StringFilter<"categoriasCursos"> | string
    cursoId?: StringFilter<"categoriasCursos"> | string
    categoria?: XOR<CategoriasScalarRelationFilter, categoriasWhereInput>
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }

  export type categoriasCursosOrderByWithRelationInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
    categoria?: categoriasOrderByWithRelationInput
    curso?: cursosOrderByWithRelationInput
  }

  export type categoriasCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cursoId_categoriaId?: categoriasCursosCursoIdCategoriaIdCompoundUniqueInput
    AND?: categoriasCursosWhereInput | categoriasCursosWhereInput[]
    OR?: categoriasCursosWhereInput[]
    NOT?: categoriasCursosWhereInput | categoriasCursosWhereInput[]
    categoriaId?: StringFilter<"categoriasCursos"> | string
    cursoId?: StringFilter<"categoriasCursos"> | string
    categoria?: XOR<CategoriasScalarRelationFilter, categoriasWhereInput>
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }, "id" | "cursoId_categoriaId">

  export type categoriasCursosOrderByWithAggregationInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
    _count?: categoriasCursosCountOrderByAggregateInput
    _max?: categoriasCursosMaxOrderByAggregateInput
    _min?: categoriasCursosMinOrderByAggregateInput
  }

  export type categoriasCursosScalarWhereWithAggregatesInput = {
    AND?: categoriasCursosScalarWhereWithAggregatesInput | categoriasCursosScalarWhereWithAggregatesInput[]
    OR?: categoriasCursosScalarWhereWithAggregatesInput[]
    NOT?: categoriasCursosScalarWhereWithAggregatesInput | categoriasCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"categoriasCursos"> | string
    categoriaId?: StringWithAggregatesFilter<"categoriasCursos"> | string
    cursoId?: StringWithAggregatesFilter<"categoriasCursos"> | string
  }

  export type reviewsCursosWhereInput = {
    AND?: reviewsCursosWhereInput | reviewsCursosWhereInput[]
    OR?: reviewsCursosWhereInput[]
    NOT?: reviewsCursosWhereInput | reviewsCursosWhereInput[]
    id?: StringFilter<"reviewsCursos"> | string
    cursoId?: StringFilter<"reviewsCursos"> | string
    rating?: IntFilter<"reviewsCursos"> | number
    comentario?: StringNullableFilter<"reviewsCursos"> | string | null
    creadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    usuariosEstudiantesId?: StringFilter<"reviewsCursos"> | string
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
    usuario?: XOR<UsuariosEstudiantesScalarRelationFilter, usuariosEstudiantesWhereInput>
  }

  export type reviewsCursosOrderByWithRelationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrder
    curso?: cursosOrderByWithRelationInput
    usuario?: usuariosEstudiantesOrderByWithRelationInput
  }

  export type reviewsCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reviewsCursosWhereInput | reviewsCursosWhereInput[]
    OR?: reviewsCursosWhereInput[]
    NOT?: reviewsCursosWhereInput | reviewsCursosWhereInput[]
    cursoId?: StringFilter<"reviewsCursos"> | string
    rating?: IntFilter<"reviewsCursos"> | number
    comentario?: StringNullableFilter<"reviewsCursos"> | string | null
    creadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    usuariosEstudiantesId?: StringFilter<"reviewsCursos"> | string
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
    usuario?: XOR<UsuariosEstudiantesScalarRelationFilter, usuariosEstudiantesWhereInput>
  }, "id">

  export type reviewsCursosOrderByWithAggregationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrder
    _count?: reviewsCursosCountOrderByAggregateInput
    _avg?: reviewsCursosAvgOrderByAggregateInput
    _max?: reviewsCursosMaxOrderByAggregateInput
    _min?: reviewsCursosMinOrderByAggregateInput
    _sum?: reviewsCursosSumOrderByAggregateInput
  }

  export type reviewsCursosScalarWhereWithAggregatesInput = {
    AND?: reviewsCursosScalarWhereWithAggregatesInput | reviewsCursosScalarWhereWithAggregatesInput[]
    OR?: reviewsCursosScalarWhereWithAggregatesInput[]
    NOT?: reviewsCursosScalarWhereWithAggregatesInput | reviewsCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reviewsCursos"> | string
    cursoId?: StringWithAggregatesFilter<"reviewsCursos"> | string
    rating?: IntWithAggregatesFilter<"reviewsCursos"> | number
    comentario?: StringNullableWithAggregatesFilter<"reviewsCursos"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"reviewsCursos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"reviewsCursos"> | Date | string
    usuariosEstudiantesId?: StringWithAggregatesFilter<"reviewsCursos"> | string
  }

  export type edicionesCursosWhereInput = {
    AND?: edicionesCursosWhereInput | edicionesCursosWhereInput[]
    OR?: edicionesCursosWhereInput[]
    NOT?: edicionesCursosWhereInput | edicionesCursosWhereInput[]
    id?: StringFilter<"edicionesCursos"> | string
    codigo?: StringFilter<"edicionesCursos"> | string
    cursoId?: StringFilter<"edicionesCursos"> | string
    descripcion?: StringNullableFilter<"edicionesCursos"> | string | null
    estado?: EnumEdicionEstadoFilter<"edicionesCursos"> | $Enums.EdicionEstado
    fechaFin?: DateTimeFilter<"edicionesCursos"> | Date | string
    fechaInicio?: DateTimeFilter<"edicionesCursos"> | Date | string
    notaMaxima?: FloatFilter<"edicionesCursos"> | number
    notaMinima?: FloatFilter<"edicionesCursos"> | number
    urlWhatsapp?: StringNullableFilter<"edicionesCursos"> | string | null
    vigente?: BoolFilter<"edicionesCursos"> | boolean
    creadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    docenteId?: StringFilter<"edicionesCursos"> | string
    docente?: XOR<DocenteScalarRelationFilter, docenteWhereInput>
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
    compras?: ComprasListRelationFilter
    certificados?: CertificadosListRelationFilter
    clases?: ClasesListRelationFilter
    examenes?: ExamenesListRelationFilter
    inscripciones?: InscripcionesListRelationFilter
    precios?: PreciosCursosListRelationFilter
  }

  export type edicionesCursosOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrderInput | SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrder
    docente?: docenteOrderByWithRelationInput
    curso?: cursosOrderByWithRelationInput
    compras?: comprasOrderByRelationAggregateInput
    certificados?: certificadosOrderByRelationAggregateInput
    clases?: clasesOrderByRelationAggregateInput
    examenes?: examenesOrderByRelationAggregateInput
    inscripciones?: inscripcionesOrderByRelationAggregateInput
    precios?: preciosCursosOrderByRelationAggregateInput
  }

  export type edicionesCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cursoId_codigo_docenteId?: edicionesCursosCursoIdCodigoDocenteIdCompoundUniqueInput
    AND?: edicionesCursosWhereInput | edicionesCursosWhereInput[]
    OR?: edicionesCursosWhereInput[]
    NOT?: edicionesCursosWhereInput | edicionesCursosWhereInput[]
    codigo?: StringFilter<"edicionesCursos"> | string
    cursoId?: StringFilter<"edicionesCursos"> | string
    descripcion?: StringNullableFilter<"edicionesCursos"> | string | null
    estado?: EnumEdicionEstadoFilter<"edicionesCursos"> | $Enums.EdicionEstado
    fechaFin?: DateTimeFilter<"edicionesCursos"> | Date | string
    fechaInicio?: DateTimeFilter<"edicionesCursos"> | Date | string
    notaMaxima?: FloatFilter<"edicionesCursos"> | number
    notaMinima?: FloatFilter<"edicionesCursos"> | number
    urlWhatsapp?: StringNullableFilter<"edicionesCursos"> | string | null
    vigente?: BoolFilter<"edicionesCursos"> | boolean
    creadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    docenteId?: StringFilter<"edicionesCursos"> | string
    docente?: XOR<DocenteScalarRelationFilter, docenteWhereInput>
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
    compras?: ComprasListRelationFilter
    certificados?: CertificadosListRelationFilter
    clases?: ClasesListRelationFilter
    examenes?: ExamenesListRelationFilter
    inscripciones?: InscripcionesListRelationFilter
    precios?: PreciosCursosListRelationFilter
  }, "id" | "cursoId_codigo_docenteId">

  export type edicionesCursosOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrderInput | SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrder
    _count?: edicionesCursosCountOrderByAggregateInput
    _avg?: edicionesCursosAvgOrderByAggregateInput
    _max?: edicionesCursosMaxOrderByAggregateInput
    _min?: edicionesCursosMinOrderByAggregateInput
    _sum?: edicionesCursosSumOrderByAggregateInput
  }

  export type edicionesCursosScalarWhereWithAggregatesInput = {
    AND?: edicionesCursosScalarWhereWithAggregatesInput | edicionesCursosScalarWhereWithAggregatesInput[]
    OR?: edicionesCursosScalarWhereWithAggregatesInput[]
    NOT?: edicionesCursosScalarWhereWithAggregatesInput | edicionesCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"edicionesCursos"> | string
    codigo?: StringWithAggregatesFilter<"edicionesCursos"> | string
    cursoId?: StringWithAggregatesFilter<"edicionesCursos"> | string
    descripcion?: StringNullableWithAggregatesFilter<"edicionesCursos"> | string | null
    estado?: EnumEdicionEstadoWithAggregatesFilter<"edicionesCursos"> | $Enums.EdicionEstado
    fechaFin?: DateTimeWithAggregatesFilter<"edicionesCursos"> | Date | string
    fechaInicio?: DateTimeWithAggregatesFilter<"edicionesCursos"> | Date | string
    notaMaxima?: FloatWithAggregatesFilter<"edicionesCursos"> | number
    notaMinima?: FloatWithAggregatesFilter<"edicionesCursos"> | number
    urlWhatsapp?: StringNullableWithAggregatesFilter<"edicionesCursos"> | string | null
    vigente?: BoolWithAggregatesFilter<"edicionesCursos"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"edicionesCursos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"edicionesCursos"> | Date | string
    docenteId?: StringWithAggregatesFilter<"edicionesCursos"> | string
  }

  export type beneficiosCursosWhereInput = {
    AND?: beneficiosCursosWhereInput | beneficiosCursosWhereInput[]
    OR?: beneficiosCursosWhereInput[]
    NOT?: beneficiosCursosWhereInput | beneficiosCursosWhereInput[]
    id?: StringFilter<"beneficiosCursos"> | string
    cursoId?: StringFilter<"beneficiosCursos"> | string
    descripcion?: StringFilter<"beneficiosCursos"> | string
    orden?: IntFilter<"beneficiosCursos"> | number
    creadoEn?: DateTimeFilter<"beneficiosCursos"> | Date | string
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }

  export type beneficiosCursosOrderByWithRelationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    curso?: cursosOrderByWithRelationInput
  }

  export type beneficiosCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: beneficiosCursosWhereInput | beneficiosCursosWhereInput[]
    OR?: beneficiosCursosWhereInput[]
    NOT?: beneficiosCursosWhereInput | beneficiosCursosWhereInput[]
    cursoId?: StringFilter<"beneficiosCursos"> | string
    descripcion?: StringFilter<"beneficiosCursos"> | string
    orden?: IntFilter<"beneficiosCursos"> | number
    creadoEn?: DateTimeFilter<"beneficiosCursos"> | Date | string
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }, "id">

  export type beneficiosCursosOrderByWithAggregationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    _count?: beneficiosCursosCountOrderByAggregateInput
    _avg?: beneficiosCursosAvgOrderByAggregateInput
    _max?: beneficiosCursosMaxOrderByAggregateInput
    _min?: beneficiosCursosMinOrderByAggregateInput
    _sum?: beneficiosCursosSumOrderByAggregateInput
  }

  export type beneficiosCursosScalarWhereWithAggregatesInput = {
    AND?: beneficiosCursosScalarWhereWithAggregatesInput | beneficiosCursosScalarWhereWithAggregatesInput[]
    OR?: beneficiosCursosScalarWhereWithAggregatesInput[]
    NOT?: beneficiosCursosScalarWhereWithAggregatesInput | beneficiosCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"beneficiosCursos"> | string
    cursoId?: StringWithAggregatesFilter<"beneficiosCursos"> | string
    descripcion?: StringWithAggregatesFilter<"beneficiosCursos"> | string
    orden?: IntWithAggregatesFilter<"beneficiosCursos"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"beneficiosCursos"> | Date | string
  }

  export type objetivosCursosWhereInput = {
    AND?: objetivosCursosWhereInput | objetivosCursosWhereInput[]
    OR?: objetivosCursosWhereInput[]
    NOT?: objetivosCursosWhereInput | objetivosCursosWhereInput[]
    id?: StringFilter<"objetivosCursos"> | string
    cursoId?: StringFilter<"objetivosCursos"> | string
    descripcion?: StringFilter<"objetivosCursos"> | string
    orden?: IntFilter<"objetivosCursos"> | number
    creadoEn?: DateTimeFilter<"objetivosCursos"> | Date | string
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }

  export type objetivosCursosOrderByWithRelationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    curso?: cursosOrderByWithRelationInput
  }

  export type objetivosCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: objetivosCursosWhereInput | objetivosCursosWhereInput[]
    OR?: objetivosCursosWhereInput[]
    NOT?: objetivosCursosWhereInput | objetivosCursosWhereInput[]
    cursoId?: StringFilter<"objetivosCursos"> | string
    descripcion?: StringFilter<"objetivosCursos"> | string
    orden?: IntFilter<"objetivosCursos"> | number
    creadoEn?: DateTimeFilter<"objetivosCursos"> | Date | string
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }, "id">

  export type objetivosCursosOrderByWithAggregationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    _count?: objetivosCursosCountOrderByAggregateInput
    _avg?: objetivosCursosAvgOrderByAggregateInput
    _max?: objetivosCursosMaxOrderByAggregateInput
    _min?: objetivosCursosMinOrderByAggregateInput
    _sum?: objetivosCursosSumOrderByAggregateInput
  }

  export type objetivosCursosScalarWhereWithAggregatesInput = {
    AND?: objetivosCursosScalarWhereWithAggregatesInput | objetivosCursosScalarWhereWithAggregatesInput[]
    OR?: objetivosCursosScalarWhereWithAggregatesInput[]
    NOT?: objetivosCursosScalarWhereWithAggregatesInput | objetivosCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"objetivosCursos"> | string
    cursoId?: StringWithAggregatesFilter<"objetivosCursos"> | string
    descripcion?: StringWithAggregatesFilter<"objetivosCursos"> | string
    orden?: IntWithAggregatesFilter<"objetivosCursos"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"objetivosCursos"> | Date | string
  }

  export type requisitosCursosWhereInput = {
    AND?: requisitosCursosWhereInput | requisitosCursosWhereInput[]
    OR?: requisitosCursosWhereInput[]
    NOT?: requisitosCursosWhereInput | requisitosCursosWhereInput[]
    id?: StringFilter<"requisitosCursos"> | string
    cursoId?: StringFilter<"requisitosCursos"> | string
    descripcion?: StringFilter<"requisitosCursos"> | string
    orden?: IntFilter<"requisitosCursos"> | number
    creadoEn?: DateTimeFilter<"requisitosCursos"> | Date | string
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }

  export type requisitosCursosOrderByWithRelationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    curso?: cursosOrderByWithRelationInput
  }

  export type requisitosCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: requisitosCursosWhereInput | requisitosCursosWhereInput[]
    OR?: requisitosCursosWhereInput[]
    NOT?: requisitosCursosWhereInput | requisitosCursosWhereInput[]
    cursoId?: StringFilter<"requisitosCursos"> | string
    descripcion?: StringFilter<"requisitosCursos"> | string
    orden?: IntFilter<"requisitosCursos"> | number
    creadoEn?: DateTimeFilter<"requisitosCursos"> | Date | string
    curso?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }, "id">

  export type requisitosCursosOrderByWithAggregationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    _count?: requisitosCursosCountOrderByAggregateInput
    _avg?: requisitosCursosAvgOrderByAggregateInput
    _max?: requisitosCursosMaxOrderByAggregateInput
    _min?: requisitosCursosMinOrderByAggregateInput
    _sum?: requisitosCursosSumOrderByAggregateInput
  }

  export type requisitosCursosScalarWhereWithAggregatesInput = {
    AND?: requisitosCursosScalarWhereWithAggregatesInput | requisitosCursosScalarWhereWithAggregatesInput[]
    OR?: requisitosCursosScalarWhereWithAggregatesInput[]
    NOT?: requisitosCursosScalarWhereWithAggregatesInput | requisitosCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"requisitosCursos"> | string
    cursoId?: StringWithAggregatesFilter<"requisitosCursos"> | string
    descripcion?: StringWithAggregatesFilter<"requisitosCursos"> | string
    orden?: IntWithAggregatesFilter<"requisitosCursos"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"requisitosCursos"> | Date | string
  }

  export type clasesWhereInput = {
    AND?: clasesWhereInput | clasesWhereInput[]
    OR?: clasesWhereInput[]
    NOT?: clasesWhereInput | clasesWhereInput[]
    id?: StringFilter<"clases"> | string
    edicionId?: StringFilter<"clases"> | string
    descripcion?: StringFilter<"clases"> | string
    duracion?: IntNullableFilter<"clases"> | number | null
    fecha?: DateTimeFilter<"clases"> | Date | string
    orden?: IntFilter<"clases"> | number
    titulo?: StringFilter<"clases"> | string
    urlYoutube?: StringNullableFilter<"clases"> | string | null
    creadoEn?: DateTimeFilter<"clases"> | Date | string
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    materiales?: MaterialesListRelationFilter
    grabaciones?: GrabacionesListRelationFilter
  }

  export type clasesOrderByWithRelationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrderInput | SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    edicion?: edicionesCursosOrderByWithRelationInput
    materiales?: materialesOrderByRelationAggregateInput
    grabaciones?: grabacionesOrderByRelationAggregateInput
  }

  export type clasesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: clasesWhereInput | clasesWhereInput[]
    OR?: clasesWhereInput[]
    NOT?: clasesWhereInput | clasesWhereInput[]
    edicionId?: StringFilter<"clases"> | string
    descripcion?: StringFilter<"clases"> | string
    duracion?: IntNullableFilter<"clases"> | number | null
    fecha?: DateTimeFilter<"clases"> | Date | string
    orden?: IntFilter<"clases"> | number
    titulo?: StringFilter<"clases"> | string
    urlYoutube?: StringNullableFilter<"clases"> | string | null
    creadoEn?: DateTimeFilter<"clases"> | Date | string
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    materiales?: MaterialesListRelationFilter
    grabaciones?: GrabacionesListRelationFilter
  }, "id">

  export type clasesOrderByWithAggregationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrderInput | SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    _count?: clasesCountOrderByAggregateInput
    _avg?: clasesAvgOrderByAggregateInput
    _max?: clasesMaxOrderByAggregateInput
    _min?: clasesMinOrderByAggregateInput
    _sum?: clasesSumOrderByAggregateInput
  }

  export type clasesScalarWhereWithAggregatesInput = {
    AND?: clasesScalarWhereWithAggregatesInput | clasesScalarWhereWithAggregatesInput[]
    OR?: clasesScalarWhereWithAggregatesInput[]
    NOT?: clasesScalarWhereWithAggregatesInput | clasesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"clases"> | string
    edicionId?: StringWithAggregatesFilter<"clases"> | string
    descripcion?: StringWithAggregatesFilter<"clases"> | string
    duracion?: IntNullableWithAggregatesFilter<"clases"> | number | null
    fecha?: DateTimeWithAggregatesFilter<"clases"> | Date | string
    orden?: IntWithAggregatesFilter<"clases"> | number
    titulo?: StringWithAggregatesFilter<"clases"> | string
    urlYoutube?: StringNullableWithAggregatesFilter<"clases"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"clases"> | Date | string
  }

  export type materialesWhereInput = {
    AND?: materialesWhereInput | materialesWhereInput[]
    OR?: materialesWhereInput[]
    NOT?: materialesWhereInput | materialesWhereInput[]
    id?: StringFilter<"materiales"> | string
    claseId?: StringFilter<"materiales"> | string
    tipo?: StringFilter<"materiales"> | string
    titulo?: StringFilter<"materiales"> | string
    url?: StringFilter<"materiales"> | string
    creadoEn?: DateTimeFilter<"materiales"> | Date | string
    clase?: XOR<ClasesScalarRelationFilter, clasesWhereInput>
  }

  export type materialesOrderByWithRelationInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
    clase?: clasesOrderByWithRelationInput
  }

  export type materialesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: materialesWhereInput | materialesWhereInput[]
    OR?: materialesWhereInput[]
    NOT?: materialesWhereInput | materialesWhereInput[]
    claseId?: StringFilter<"materiales"> | string
    tipo?: StringFilter<"materiales"> | string
    titulo?: StringFilter<"materiales"> | string
    url?: StringFilter<"materiales"> | string
    creadoEn?: DateTimeFilter<"materiales"> | Date | string
    clase?: XOR<ClasesScalarRelationFilter, clasesWhereInput>
  }, "id">

  export type materialesOrderByWithAggregationInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
    _count?: materialesCountOrderByAggregateInput
    _max?: materialesMaxOrderByAggregateInput
    _min?: materialesMinOrderByAggregateInput
  }

  export type materialesScalarWhereWithAggregatesInput = {
    AND?: materialesScalarWhereWithAggregatesInput | materialesScalarWhereWithAggregatesInput[]
    OR?: materialesScalarWhereWithAggregatesInput[]
    NOT?: materialesScalarWhereWithAggregatesInput | materialesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"materiales"> | string
    claseId?: StringWithAggregatesFilter<"materiales"> | string
    tipo?: StringWithAggregatesFilter<"materiales"> | string
    titulo?: StringWithAggregatesFilter<"materiales"> | string
    url?: StringWithAggregatesFilter<"materiales"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"materiales"> | Date | string
  }

  export type examenesWhereInput = {
    AND?: examenesWhereInput | examenesWhereInput[]
    OR?: examenesWhereInput[]
    NOT?: examenesWhereInput | examenesWhereInput[]
    id?: StringFilter<"examenes"> | string
    edicionId?: StringFilter<"examenes"> | string
    descripcion?: StringNullableFilter<"examenes"> | string | null
    fechaDisponible?: DateTimeFilter<"examenes"> | Date | string
    fechaLimite?: DateTimeFilter<"examenes"> | Date | string
    notaMaxima?: FloatFilter<"examenes"> | number
    notaMinima?: FloatFilter<"examenes"> | number
    titulo?: StringFilter<"examenes"> | string
    creadoEn?: DateTimeFilter<"examenes"> | Date | string
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    calificaciones?: CalificacionesListRelationFilter
  }

  export type examenesOrderByWithRelationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
    edicion?: edicionesCursosOrderByWithRelationInput
    calificaciones?: calificacionesOrderByRelationAggregateInput
  }

  export type examenesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: examenesWhereInput | examenesWhereInput[]
    OR?: examenesWhereInput[]
    NOT?: examenesWhereInput | examenesWhereInput[]
    edicionId?: StringFilter<"examenes"> | string
    descripcion?: StringNullableFilter<"examenes"> | string | null
    fechaDisponible?: DateTimeFilter<"examenes"> | Date | string
    fechaLimite?: DateTimeFilter<"examenes"> | Date | string
    notaMaxima?: FloatFilter<"examenes"> | number
    notaMinima?: FloatFilter<"examenes"> | number
    titulo?: StringFilter<"examenes"> | string
    creadoEn?: DateTimeFilter<"examenes"> | Date | string
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    calificaciones?: CalificacionesListRelationFilter
  }, "id">

  export type examenesOrderByWithAggregationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
    _count?: examenesCountOrderByAggregateInput
    _avg?: examenesAvgOrderByAggregateInput
    _max?: examenesMaxOrderByAggregateInput
    _min?: examenesMinOrderByAggregateInput
    _sum?: examenesSumOrderByAggregateInput
  }

  export type examenesScalarWhereWithAggregatesInput = {
    AND?: examenesScalarWhereWithAggregatesInput | examenesScalarWhereWithAggregatesInput[]
    OR?: examenesScalarWhereWithAggregatesInput[]
    NOT?: examenesScalarWhereWithAggregatesInput | examenesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"examenes"> | string
    edicionId?: StringWithAggregatesFilter<"examenes"> | string
    descripcion?: StringNullableWithAggregatesFilter<"examenes"> | string | null
    fechaDisponible?: DateTimeWithAggregatesFilter<"examenes"> | Date | string
    fechaLimite?: DateTimeWithAggregatesFilter<"examenes"> | Date | string
    notaMaxima?: FloatWithAggregatesFilter<"examenes"> | number
    notaMinima?: FloatWithAggregatesFilter<"examenes"> | number
    titulo?: StringWithAggregatesFilter<"examenes"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"examenes"> | Date | string
  }

  export type calificacionesWhereInput = {
    AND?: calificacionesWhereInput | calificacionesWhereInput[]
    OR?: calificacionesWhereInput[]
    NOT?: calificacionesWhereInput | calificacionesWhereInput[]
    id?: StringFilter<"calificaciones"> | string
    aprobado?: BoolFilter<"calificaciones"> | boolean
    comentarios?: StringNullableFilter<"calificaciones"> | string | null
    estudianteId?: StringFilter<"calificaciones"> | string
    examenId?: StringFilter<"calificaciones"> | string
    nota?: FloatFilter<"calificaciones"> | number
    creadoEn?: DateTimeFilter<"calificaciones"> | Date | string
    estudiante?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
    examen?: XOR<ExamenesScalarRelationFilter, examenesWhereInput>
  }

  export type calificacionesOrderByWithRelationInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrderInput | SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
    estudiante?: estudiantesOrderByWithRelationInput
    examen?: examenesOrderByWithRelationInput
  }

  export type calificacionesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    estudianteId_examenId?: calificacionesEstudianteIdExamenIdCompoundUniqueInput
    AND?: calificacionesWhereInput | calificacionesWhereInput[]
    OR?: calificacionesWhereInput[]
    NOT?: calificacionesWhereInput | calificacionesWhereInput[]
    aprobado?: BoolFilter<"calificaciones"> | boolean
    comentarios?: StringNullableFilter<"calificaciones"> | string | null
    estudianteId?: StringFilter<"calificaciones"> | string
    examenId?: StringFilter<"calificaciones"> | string
    nota?: FloatFilter<"calificaciones"> | number
    creadoEn?: DateTimeFilter<"calificaciones"> | Date | string
    estudiante?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
    examen?: XOR<ExamenesScalarRelationFilter, examenesWhereInput>
  }, "id" | "estudianteId_examenId">

  export type calificacionesOrderByWithAggregationInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrderInput | SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
    _count?: calificacionesCountOrderByAggregateInput
    _avg?: calificacionesAvgOrderByAggregateInput
    _max?: calificacionesMaxOrderByAggregateInput
    _min?: calificacionesMinOrderByAggregateInput
    _sum?: calificacionesSumOrderByAggregateInput
  }

  export type calificacionesScalarWhereWithAggregatesInput = {
    AND?: calificacionesScalarWhereWithAggregatesInput | calificacionesScalarWhereWithAggregatesInput[]
    OR?: calificacionesScalarWhereWithAggregatesInput[]
    NOT?: calificacionesScalarWhereWithAggregatesInput | calificacionesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"calificaciones"> | string
    aprobado?: BoolWithAggregatesFilter<"calificaciones"> | boolean
    comentarios?: StringNullableWithAggregatesFilter<"calificaciones"> | string | null
    estudianteId?: StringWithAggregatesFilter<"calificaciones"> | string
    examenId?: StringWithAggregatesFilter<"calificaciones"> | string
    nota?: FloatWithAggregatesFilter<"calificaciones"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"calificaciones"> | Date | string
  }

  export type inscripcionesWhereInput = {
    AND?: inscripcionesWhereInput | inscripcionesWhereInput[]
    OR?: inscripcionesWhereInput[]
    NOT?: inscripcionesWhereInput | inscripcionesWhereInput[]
    id?: StringFilter<"inscripciones"> | string
    edicionId?: StringFilter<"inscripciones"> | string
    estado?: BoolFilter<"inscripciones"> | boolean
    estudianteId?: StringFilter<"inscripciones"> | string
    inscritoEn?: DateTimeFilter<"inscripciones"> | Date | string
    actualizadoEn?: DateTimeFilter<"inscripciones"> | Date | string
    compraId?: StringNullableFilter<"inscripciones"> | string | null
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    estudiante?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
    compra?: XOR<ComprasNullableScalarRelationFilter, comprasWhereInput> | null
  }

  export type inscripcionesOrderByWithRelationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    actualizadoEn?: SortOrder
    compraId?: SortOrderInput | SortOrder
    edicion?: edicionesCursosOrderByWithRelationInput
    estudiante?: estudiantesOrderByWithRelationInput
    compra?: comprasOrderByWithRelationInput
  }

  export type inscripcionesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    compraId?: string
    estudianteId_edicionId?: inscripcionesEstudianteIdEdicionIdCompoundUniqueInput
    AND?: inscripcionesWhereInput | inscripcionesWhereInput[]
    OR?: inscripcionesWhereInput[]
    NOT?: inscripcionesWhereInput | inscripcionesWhereInput[]
    edicionId?: StringFilter<"inscripciones"> | string
    estado?: BoolFilter<"inscripciones"> | boolean
    estudianteId?: StringFilter<"inscripciones"> | string
    inscritoEn?: DateTimeFilter<"inscripciones"> | Date | string
    actualizadoEn?: DateTimeFilter<"inscripciones"> | Date | string
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    estudiante?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
    compra?: XOR<ComprasNullableScalarRelationFilter, comprasWhereInput> | null
  }, "id" | "compraId" | "estudianteId_edicionId">

  export type inscripcionesOrderByWithAggregationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    actualizadoEn?: SortOrder
    compraId?: SortOrderInput | SortOrder
    _count?: inscripcionesCountOrderByAggregateInput
    _max?: inscripcionesMaxOrderByAggregateInput
    _min?: inscripcionesMinOrderByAggregateInput
  }

  export type inscripcionesScalarWhereWithAggregatesInput = {
    AND?: inscripcionesScalarWhereWithAggregatesInput | inscripcionesScalarWhereWithAggregatesInput[]
    OR?: inscripcionesScalarWhereWithAggregatesInput[]
    NOT?: inscripcionesScalarWhereWithAggregatesInput | inscripcionesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"inscripciones"> | string
    edicionId?: StringWithAggregatesFilter<"inscripciones"> | string
    estado?: BoolWithAggregatesFilter<"inscripciones"> | boolean
    estudianteId?: StringWithAggregatesFilter<"inscripciones"> | string
    inscritoEn?: DateTimeWithAggregatesFilter<"inscripciones"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"inscripciones"> | Date | string
    compraId?: StringNullableWithAggregatesFilter<"inscripciones"> | string | null
  }

  export type certificadosWhereInput = {
    AND?: certificadosWhereInput | certificadosWhereInput[]
    OR?: certificadosWhereInput[]
    NOT?: certificadosWhereInput | certificadosWhereInput[]
    id?: StringFilter<"certificados"> | string
    codigoUnico?: StringFilter<"certificados"> | string
    edicionId?: StringFilter<"certificados"> | string
    estudianteId?: StringFilter<"certificados"> | string
    fechaEmision?: DateTimeFilter<"certificados"> | Date | string
    notaFinal?: FloatNullableFilter<"certificados"> | number | null
    urlCertificado?: StringNullableFilter<"certificados"> | string | null
    creadoEn?: DateTimeFilter<"certificados"> | Date | string
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    estudiante?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
  }

  export type certificadosOrderByWithRelationInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    notaFinal?: SortOrderInput | SortOrder
    urlCertificado?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    edicion?: edicionesCursosOrderByWithRelationInput
    estudiante?: estudiantesOrderByWithRelationInput
  }

  export type certificadosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codigoUnico?: string
    estudianteId_edicionId?: certificadosEstudianteIdEdicionIdCompoundUniqueInput
    AND?: certificadosWhereInput | certificadosWhereInput[]
    OR?: certificadosWhereInput[]
    NOT?: certificadosWhereInput | certificadosWhereInput[]
    edicionId?: StringFilter<"certificados"> | string
    estudianteId?: StringFilter<"certificados"> | string
    fechaEmision?: DateTimeFilter<"certificados"> | Date | string
    notaFinal?: FloatNullableFilter<"certificados"> | number | null
    urlCertificado?: StringNullableFilter<"certificados"> | string | null
    creadoEn?: DateTimeFilter<"certificados"> | Date | string
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    estudiante?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
  }, "id" | "codigoUnico" | "estudianteId_edicionId">

  export type certificadosOrderByWithAggregationInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    notaFinal?: SortOrderInput | SortOrder
    urlCertificado?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    _count?: certificadosCountOrderByAggregateInput
    _avg?: certificadosAvgOrderByAggregateInput
    _max?: certificadosMaxOrderByAggregateInput
    _min?: certificadosMinOrderByAggregateInput
    _sum?: certificadosSumOrderByAggregateInput
  }

  export type certificadosScalarWhereWithAggregatesInput = {
    AND?: certificadosScalarWhereWithAggregatesInput | certificadosScalarWhereWithAggregatesInput[]
    OR?: certificadosScalarWhereWithAggregatesInput[]
    NOT?: certificadosScalarWhereWithAggregatesInput | certificadosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"certificados"> | string
    codigoUnico?: StringWithAggregatesFilter<"certificados"> | string
    edicionId?: StringWithAggregatesFilter<"certificados"> | string
    estudianteId?: StringWithAggregatesFilter<"certificados"> | string
    fechaEmision?: DateTimeWithAggregatesFilter<"certificados"> | Date | string
    notaFinal?: FloatNullableWithAggregatesFilter<"certificados"> | number | null
    urlCertificado?: StringNullableWithAggregatesFilter<"certificados"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"certificados"> | Date | string
  }

  export type preciosCursosWhereInput = {
    AND?: preciosCursosWhereInput | preciosCursosWhereInput[]
    OR?: preciosCursosWhereInput[]
    NOT?: preciosCursosWhereInput | preciosCursosWhereInput[]
    id?: StringFilter<"preciosCursos"> | string
    edicionId?: StringFilter<"preciosCursos"> | string
    esDescuento?: BoolFilter<"preciosCursos"> | boolean
    esPrecioDefault?: BoolFilter<"preciosCursos"> | boolean
    fechaFin?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    fechaInicio?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    moneda?: StringFilter<"preciosCursos"> | string
    nombre?: StringFilter<"preciosCursos"> | string
    porcentajeDescuento?: FloatNullableFilter<"preciosCursos"> | number | null
    precio?: FloatFilter<"preciosCursos"> | number
    precioOriginal?: FloatNullableFilter<"preciosCursos"> | number | null
    creadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
  }

  export type preciosCursosOrderByWithRelationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrderInput | SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    edicion?: edicionesCursosOrderByWithRelationInput
  }

  export type preciosCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: preciosCursosWhereInput | preciosCursosWhereInput[]
    OR?: preciosCursosWhereInput[]
    NOT?: preciosCursosWhereInput | preciosCursosWhereInput[]
    edicionId?: StringFilter<"preciosCursos"> | string
    esDescuento?: BoolFilter<"preciosCursos"> | boolean
    esPrecioDefault?: BoolFilter<"preciosCursos"> | boolean
    fechaFin?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    fechaInicio?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    moneda?: StringFilter<"preciosCursos"> | string
    nombre?: StringFilter<"preciosCursos"> | string
    porcentajeDescuento?: FloatNullableFilter<"preciosCursos"> | number | null
    precio?: FloatFilter<"preciosCursos"> | number
    precioOriginal?: FloatNullableFilter<"preciosCursos"> | number | null
    creadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
  }, "id">

  export type preciosCursosOrderByWithAggregationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrderInput | SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: preciosCursosCountOrderByAggregateInput
    _avg?: preciosCursosAvgOrderByAggregateInput
    _max?: preciosCursosMaxOrderByAggregateInput
    _min?: preciosCursosMinOrderByAggregateInput
    _sum?: preciosCursosSumOrderByAggregateInput
  }

  export type preciosCursosScalarWhereWithAggregatesInput = {
    AND?: preciosCursosScalarWhereWithAggregatesInput | preciosCursosScalarWhereWithAggregatesInput[]
    OR?: preciosCursosScalarWhereWithAggregatesInput[]
    NOT?: preciosCursosScalarWhereWithAggregatesInput | preciosCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"preciosCursos"> | string
    edicionId?: StringWithAggregatesFilter<"preciosCursos"> | string
    esDescuento?: BoolWithAggregatesFilter<"preciosCursos"> | boolean
    esPrecioDefault?: BoolWithAggregatesFilter<"preciosCursos"> | boolean
    fechaFin?: DateTimeNullableWithAggregatesFilter<"preciosCursos"> | Date | string | null
    fechaInicio?: DateTimeNullableWithAggregatesFilter<"preciosCursos"> | Date | string | null
    moneda?: StringWithAggregatesFilter<"preciosCursos"> | string
    nombre?: StringWithAggregatesFilter<"preciosCursos"> | string
    porcentajeDescuento?: FloatNullableWithAggregatesFilter<"preciosCursos"> | number | null
    precio?: FloatWithAggregatesFilter<"preciosCursos"> | number
    precioOriginal?: FloatNullableWithAggregatesFilter<"preciosCursos"> | number | null
    creadoEn?: DateTimeWithAggregatesFilter<"preciosCursos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"preciosCursos"> | Date | string
  }

  export type comprasWhereInput = {
    AND?: comprasWhereInput | comprasWhereInput[]
    OR?: comprasWhereInput[]
    NOT?: comprasWhereInput | comprasWhereInput[]
    id?: StringFilter<"compras"> | string
    nombre?: StringFilter<"compras"> | string
    apellido?: StringFilter<"compras"> | string
    edicionId?: StringFilter<"compras"> | string
    monto?: FloatFilter<"compras"> | number
    moneda?: StringFilter<"compras"> | string
    providerId?: StringFilter<"compras"> | string
    comprobado?: BoolFilter<"compras"> | boolean
    fechaCompra?: DateTimeFilter<"compras"> | Date | string
    metodo?: StringNullableFilter<"compras"> | string | null
    usuariosEstudiantesId?: StringNullableFilter<"compras"> | string | null
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    inscripcion?: XOR<InscripcionesNullableScalarRelationFilter, inscripcionesWhereInput> | null
    usuario?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
  }

  export type comprasOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    providerId?: SortOrder
    comprobado?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrderInput | SortOrder
    usuariosEstudiantesId?: SortOrderInput | SortOrder
    edicion?: edicionesCursosOrderByWithRelationInput
    inscripcion?: inscripcionesOrderByWithRelationInput
    usuario?: usuariosEstudiantesOrderByWithRelationInput
  }

  export type comprasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: comprasWhereInput | comprasWhereInput[]
    OR?: comprasWhereInput[]
    NOT?: comprasWhereInput | comprasWhereInput[]
    nombre?: StringFilter<"compras"> | string
    apellido?: StringFilter<"compras"> | string
    edicionId?: StringFilter<"compras"> | string
    monto?: FloatFilter<"compras"> | number
    moneda?: StringFilter<"compras"> | string
    providerId?: StringFilter<"compras"> | string
    comprobado?: BoolFilter<"compras"> | boolean
    fechaCompra?: DateTimeFilter<"compras"> | Date | string
    metodo?: StringNullableFilter<"compras"> | string | null
    usuariosEstudiantesId?: StringNullableFilter<"compras"> | string | null
    edicion?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    inscripcion?: XOR<InscripcionesNullableScalarRelationFilter, inscripcionesWhereInput> | null
    usuario?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
  }, "id">

  export type comprasOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    providerId?: SortOrder
    comprobado?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrderInput | SortOrder
    usuariosEstudiantesId?: SortOrderInput | SortOrder
    _count?: comprasCountOrderByAggregateInput
    _avg?: comprasAvgOrderByAggregateInput
    _max?: comprasMaxOrderByAggregateInput
    _min?: comprasMinOrderByAggregateInput
    _sum?: comprasSumOrderByAggregateInput
  }

  export type comprasScalarWhereWithAggregatesInput = {
    AND?: comprasScalarWhereWithAggregatesInput | comprasScalarWhereWithAggregatesInput[]
    OR?: comprasScalarWhereWithAggregatesInput[]
    NOT?: comprasScalarWhereWithAggregatesInput | comprasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"compras"> | string
    nombre?: StringWithAggregatesFilter<"compras"> | string
    apellido?: StringWithAggregatesFilter<"compras"> | string
    edicionId?: StringWithAggregatesFilter<"compras"> | string
    monto?: FloatWithAggregatesFilter<"compras"> | number
    moneda?: StringWithAggregatesFilter<"compras"> | string
    providerId?: StringWithAggregatesFilter<"compras"> | string
    comprobado?: BoolWithAggregatesFilter<"compras"> | boolean
    fechaCompra?: DateTimeWithAggregatesFilter<"compras"> | Date | string
    metodo?: StringNullableWithAggregatesFilter<"compras"> | string | null
    usuariosEstudiantesId?: StringNullableWithAggregatesFilter<"compras"> | string | null
  }

  export type grabacionesWhereInput = {
    AND?: grabacionesWhereInput | grabacionesWhereInput[]
    OR?: grabacionesWhereInput[]
    NOT?: grabacionesWhereInput | grabacionesWhereInput[]
    id?: StringFilter<"grabaciones"> | string
    claseId?: StringFilter<"grabaciones"> | string
    usuarioId?: StringFilter<"grabaciones"> | string
    fechaInicio?: DateTimeFilter<"grabaciones"> | Date | string
    fechaFin?: DateTimeNullableFilter<"grabaciones"> | Date | string | null
    duracionSegundos?: IntNullableFilter<"grabaciones"> | number | null
    completada?: BoolFilter<"grabaciones"> | boolean
    clase?: XOR<ClasesScalarRelationFilter, clasesWhereInput>
    usuario?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
  }

  export type grabacionesOrderByWithRelationInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    duracionSegundos?: SortOrderInput | SortOrder
    completada?: SortOrder
    clase?: clasesOrderByWithRelationInput
    usuario?: usuariosAdministradoresOrderByWithRelationInput
  }

  export type grabacionesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: grabacionesWhereInput | grabacionesWhereInput[]
    OR?: grabacionesWhereInput[]
    NOT?: grabacionesWhereInput | grabacionesWhereInput[]
    claseId?: StringFilter<"grabaciones"> | string
    usuarioId?: StringFilter<"grabaciones"> | string
    fechaInicio?: DateTimeFilter<"grabaciones"> | Date | string
    fechaFin?: DateTimeNullableFilter<"grabaciones"> | Date | string | null
    duracionSegundos?: IntNullableFilter<"grabaciones"> | number | null
    completada?: BoolFilter<"grabaciones"> | boolean
    clase?: XOR<ClasesScalarRelationFilter, clasesWhereInput>
    usuario?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
  }, "id">

  export type grabacionesOrderByWithAggregationInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    duracionSegundos?: SortOrderInput | SortOrder
    completada?: SortOrder
    _count?: grabacionesCountOrderByAggregateInput
    _avg?: grabacionesAvgOrderByAggregateInput
    _max?: grabacionesMaxOrderByAggregateInput
    _min?: grabacionesMinOrderByAggregateInput
    _sum?: grabacionesSumOrderByAggregateInput
  }

  export type grabacionesScalarWhereWithAggregatesInput = {
    AND?: grabacionesScalarWhereWithAggregatesInput | grabacionesScalarWhereWithAggregatesInput[]
    OR?: grabacionesScalarWhereWithAggregatesInput[]
    NOT?: grabacionesScalarWhereWithAggregatesInput | grabacionesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"grabaciones"> | string
    claseId?: StringWithAggregatesFilter<"grabaciones"> | string
    usuarioId?: StringWithAggregatesFilter<"grabaciones"> | string
    fechaInicio?: DateTimeWithAggregatesFilter<"grabaciones"> | Date | string
    fechaFin?: DateTimeNullableWithAggregatesFilter<"grabaciones"> | Date | string | null
    duracionSegundos?: IntNullableWithAggregatesFilter<"grabaciones"> | number | null
    completada?: BoolWithAggregatesFilter<"grabaciones"> | boolean
  }

  export type auditoriaCreateInput = {
    id?: string
    tabla: string
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
    usuario?: usuariosAdministradoresCreateNestedOneWithoutAuditoriasInput
  }

  export type auditoriaUncheckedCreateInput = {
    id?: string
    tabla: string
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    usuarioId?: string | null
    creadoEn?: Date | string
  }

  export type auditoriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosAdministradoresUpdateOneWithoutAuditoriasNestedInput
  }

  export type auditoriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaCreateManyInput = {
    id?: string
    tabla: string
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    usuarioId?: string | null
    creadoEn?: Date | string
  }

  export type auditoriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    categoriasCursos?: categoriasCursosCreateNestedManyWithoutCategoriaInput
  }

  export type categoriasUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    categoriasCursos?: categoriasCursosUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type categoriasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    categoriasCursos?: categoriasCursosUpdateManyWithoutCategoriaNestedInput
  }

  export type categoriasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    categoriasCursos?: categoriasCursosUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type categoriasCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type categoriasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usuariosEstudiantesCreateInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    avatar?: string | null
    registrado?: boolean
    estudiante?: estudiantesCreateNestedOneWithoutUsuarioInput
    reviews?: reviewsCursosCreateNestedManyWithoutUsuarioInput
    compras?: comprasCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosEstudiantesUncheckedCreateInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    reviews?: reviewsCursosUncheckedCreateNestedManyWithoutUsuarioInput
    compras?: comprasUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosEstudiantesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    estudiante?: estudiantesUpdateOneWithoutUsuarioNestedInput
    reviews?: reviewsCursosUpdateManyWithoutUsuarioNestedInput
    compras?: comprasUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    reviews?: reviewsCursosUncheckedUpdateManyWithoutUsuarioNestedInput
    compras?: comprasUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosEstudiantesCreateManyInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
  }

  export type usuariosEstudiantesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usuariosEstudiantesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type estudiantesCreateInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario?: usuariosEstudiantesCreateNestedOneWithoutEstudianteInput
    calificaciones?: calificacionesCreateNestedManyWithoutEstudianteInput
    certificados?: certificadosCreateNestedManyWithoutEstudianteInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesUncheckedCreateInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario?: usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudianteInput
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutEstudianteInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEstudianteInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosEstudiantesUpdateOneWithoutEstudianteNestedInput
    calificaciones?: calificacionesUpdateManyWithoutEstudianteNestedInput
    certificados?: certificadosUpdateManyWithoutEstudianteNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEstudianteNestedInput
  }

  export type estudiantesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosEstudiantesUncheckedUpdateOneWithoutEstudianteNestedInput
    calificaciones?: calificacionesUncheckedUpdateManyWithoutEstudianteNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEstudianteNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type estudiantesCreateManyInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type estudiantesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type estudiantesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usuariosAdministradoresCreateInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    tipo: $Enums.TipoCuenta
    docente?: docenteCreateNestedOneWithoutUsuarioInput
    auditorias?: auditoriaCreateNestedManyWithoutUsuarioInput
    grabaciones?: grabacionesCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosAdministradoresUncheckedCreateInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    tipo: $Enums.TipoCuenta
    docente?: docenteUncheckedCreateNestedOneWithoutUsuarioInput
    auditorias?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosAdministradoresUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    docente?: docenteUpdateOneWithoutUsuarioNestedInput
    auditorias?: auditoriaUpdateManyWithoutUsuarioNestedInput
    grabaciones?: grabacionesUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosAdministradoresUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    docente?: docenteUncheckedUpdateOneWithoutUsuarioNestedInput
    auditorias?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    grabaciones?: grabacionesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosAdministradoresCreateManyInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    tipo: $Enums.TipoCuenta
  }

  export type usuariosAdministradoresUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
  }

  export type usuariosAdministradoresUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
  }

  export type docenteCreateInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario: usuariosAdministradoresCreateNestedOneWithoutDocenteInput
    ediciones?: edicionesCursosCreateNestedManyWithoutDocenteInput
  }

  export type docenteUncheckedCreateInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuarioId: string
    ediciones?: edicionesCursosUncheckedCreateNestedManyWithoutDocenteInput
  }

  export type docenteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosAdministradoresUpdateOneRequiredWithoutDocenteNestedInput
    ediciones?: edicionesCursosUpdateManyWithoutDocenteNestedInput
  }

  export type docenteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    ediciones?: edicionesCursosUncheckedUpdateManyWithoutDocenteNestedInput
  }

  export type docenteCreateManyInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuarioId: string
  }

  export type docenteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type docenteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
  }

  export type cursosCreateInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosCreateNestedManyWithoutCursoInput
  }

  export type cursosUncheckedCreateInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosUncheckedCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosUncheckedCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosUncheckedCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosUncheckedCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosUncheckedCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosUncheckedCreateNestedManyWithoutCursoInput
  }

  export type cursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUpdateManyWithoutCursoNestedInput
  }

  export type cursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUncheckedUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUncheckedUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUncheckedUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUncheckedUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUncheckedUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type cursosCreateManyInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
  }

  export type cursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriasCursosCreateInput = {
    id?: string
    categoria: categoriasCreateNestedOneWithoutCategoriasCursosInput
    curso: cursosCreateNestedOneWithoutCategoriasInput
  }

  export type categoriasCursosUncheckedCreateInput = {
    id?: string
    categoriaId: string
    cursoId: string
  }

  export type categoriasCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoria?: categoriasUpdateOneRequiredWithoutCategoriasCursosNestedInput
    curso?: cursosUpdateOneRequiredWithoutCategoriasNestedInput
  }

  export type categoriasCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoriaId?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
  }

  export type categoriasCursosCreateManyInput = {
    id?: string
    categoriaId: string
    cursoId: string
  }

  export type categoriasCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type categoriasCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoriaId?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsCursosCreateInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    curso: cursosCreateNestedOneWithoutReviewsInput
    usuario: usuariosEstudiantesCreateNestedOneWithoutReviewsInput
  }

  export type reviewsCursosUncheckedCreateInput = {
    id?: string
    cursoId: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuariosEstudiantesId: string
  }

  export type reviewsCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: cursosUpdateOneRequiredWithoutReviewsNestedInput
    usuario?: usuariosEstudiantesUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantesId?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsCursosCreateManyInput = {
    id?: string
    cursoId: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuariosEstudiantesId: string
  }

  export type reviewsCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantesId?: StringFieldUpdateOperationsInput | string
  }

  export type edicionesCursosCreateInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docente: docenteCreateNestedOneWithoutEdicionesInput
    curso: cursosCreateNestedOneWithoutEdicionesInput
    compras?: comprasCreateNestedManyWithoutEdicionInput
    certificados?: certificadosCreateNestedManyWithoutEdicionInput
    clases?: clasesCreateNestedManyWithoutEdicionInput
    examenes?: examenesCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUncheckedCreateInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosUncheckedCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutEdicionesNestedInput
    curso?: cursosUpdateOneRequiredWithoutEdicionesNestedInput
    compras?: comprasUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUpdateManyWithoutEdicionNestedInput
    clases?: clasesUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
    compras?: comprasUncheckedUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUncheckedUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosCreateManyInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
  }

  export type edicionesCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type edicionesCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
  }

  export type beneficiosCursosCreateInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
    curso: cursosCreateNestedOneWithoutBeneficiosInput
  }

  export type beneficiosCursosUncheckedCreateInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type beneficiosCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: cursosUpdateOneRequiredWithoutBeneficiosNestedInput
  }

  export type beneficiosCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosCreateManyInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type beneficiosCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosCreateInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
    curso: cursosCreateNestedOneWithoutObjetivosInput
  }

  export type objetivosCursosUncheckedCreateInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type objetivosCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: cursosUpdateOneRequiredWithoutObjetivosNestedInput
  }

  export type objetivosCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosCreateManyInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type objetivosCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosCreateInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
    curso: cursosCreateNestedOneWithoutRequisitosInput
  }

  export type requisitosCursosUncheckedCreateInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: cursosUpdateOneRequiredWithoutRequisitosNestedInput
  }

  export type requisitosCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosCreateManyInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clasesCreateInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutClasesInput
    materiales?: materialesCreateNestedManyWithoutClaseInput
    grabaciones?: grabacionesCreateNestedManyWithoutClaseInput
  }

  export type clasesUncheckedCreateInput = {
    id?: string
    edicionId: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    materiales?: materialesUncheckedCreateNestedManyWithoutClaseInput
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutClaseInput
  }

  export type clasesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutClasesNestedInput
    materiales?: materialesUpdateManyWithoutClaseNestedInput
    grabaciones?: grabacionesUpdateManyWithoutClaseNestedInput
  }

  export type clasesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    materiales?: materialesUncheckedUpdateManyWithoutClaseNestedInput
    grabaciones?: grabacionesUncheckedUpdateManyWithoutClaseNestedInput
  }

  export type clasesCreateManyInput = {
    id?: string
    edicionId: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
  }

  export type clasesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clasesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesCreateInput = {
    id?: string
    tipo: string
    titulo: string
    url: string
    creadoEn?: Date | string
    clase: clasesCreateNestedOneWithoutMaterialesInput
  }

  export type materialesUncheckedCreateInput = {
    id?: string
    claseId: string
    tipo: string
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type materialesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    clase?: clasesUpdateOneRequiredWithoutMaterialesNestedInput
  }

  export type materialesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesCreateManyInput = {
    id?: string
    claseId: string
    tipo: string
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type materialesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examenesCreateInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutExamenesInput
    calificaciones?: calificacionesCreateNestedManyWithoutExamenInput
  }

  export type examenesUncheckedCreateInput = {
    id?: string
    edicionId: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutExamenInput
  }

  export type examenesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutExamenesNestedInput
    calificaciones?: calificacionesUpdateManyWithoutExamenNestedInput
  }

  export type examenesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: calificacionesUncheckedUpdateManyWithoutExamenNestedInput
  }

  export type examenesCreateManyInput = {
    id?: string
    edicionId: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
  }

  export type examenesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examenesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesCreateInput = {
    id?: string
    aprobado: boolean
    comentarios?: string | null
    nota: number
    creadoEn?: Date | string
    estudiante: estudiantesCreateNestedOneWithoutCalificacionesInput
    examen: examenesCreateNestedOneWithoutCalificacionesInput
  }

  export type calificacionesUncheckedCreateInput = {
    id?: string
    aprobado: boolean
    comentarios?: string | null
    estudianteId: string
    examenId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: estudiantesUpdateOneRequiredWithoutCalificacionesNestedInput
    examen?: examenesUpdateOneRequiredWithoutCalificacionesNestedInput
  }

  export type calificacionesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    examenId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesCreateManyInput = {
    id?: string
    aprobado: boolean
    comentarios?: string | null
    estudianteId: string
    examenId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    examenId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesCreateInput = {
    id?: string
    estado?: boolean
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutInscripcionesInput
    estudiante: estudiantesCreateNestedOneWithoutInscripcionesInput
    compra?: comprasCreateNestedOneWithoutInscripcionInput
  }

  export type inscripcionesUncheckedCreateInput = {
    id?: string
    edicionId: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    compraId?: string | null
  }

  export type inscripcionesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutInscripcionesNestedInput
    estudiante?: estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput
    compra?: comprasUpdateOneWithoutInscripcionNestedInput
  }

  export type inscripcionesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inscripcionesCreateManyInput = {
    id?: string
    edicionId: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    compraId?: string | null
  }

  export type inscripcionesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certificadosCreateInput = {
    id?: string
    codigoUnico: string
    fechaEmision: Date | string
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutCertificadosInput
    estudiante: estudiantesCreateNestedOneWithoutCertificadosInput
  }

  export type certificadosUncheckedCreateInput = {
    id?: string
    codigoUnico: string
    edicionId: string
    estudianteId: string
    fechaEmision: Date | string
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type certificadosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutCertificadosNestedInput
    estudiante?: estudiantesUpdateOneRequiredWithoutCertificadosNestedInput
  }

  export type certificadosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosCreateManyInput = {
    id?: string
    codigoUnico: string
    edicionId: string
    estudianteId: string
    fechaEmision: Date | string
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type certificadosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosCreateInput = {
    id?: string
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: Date | string | null
    fechaInicio?: Date | string | null
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutPreciosInput
  }

  export type preciosCursosUncheckedCreateInput = {
    id?: string
    edicionId: string
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: Date | string | null
    fechaInicio?: Date | string | null
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type preciosCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutPreciosNestedInput
  }

  export type preciosCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosCreateManyInput = {
    id?: string
    edicionId: string
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: Date | string | null
    fechaInicio?: Date | string | null
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type preciosCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comprasCreateInput = {
    id?: string
    nombre: string
    apellido: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    edicion: edicionesCursosCreateNestedOneWithoutComprasInput
    inscripcion?: inscripcionesCreateNestedOneWithoutCompraInput
    usuario?: usuariosEstudiantesCreateNestedOneWithoutComprasInput
  }

  export type comprasUncheckedCreateInput = {
    id?: string
    nombre: string
    apellido: string
    edicionId: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    usuariosEstudiantesId?: string | null
    inscripcion?: inscripcionesUncheckedCreateNestedOneWithoutCompraInput
  }

  export type comprasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    edicion?: edicionesCursosUpdateOneRequiredWithoutComprasNestedInput
    inscripcion?: inscripcionesUpdateOneWithoutCompraNestedInput
    usuario?: usuariosEstudiantesUpdateOneWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
    inscripcion?: inscripcionesUncheckedUpdateOneWithoutCompraNestedInput
  }

  export type comprasCreateManyInput = {
    id?: string
    nombre: string
    apellido: string
    edicionId: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    usuariosEstudiantesId?: string | null
  }

  export type comprasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type comprasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type grabacionesCreateInput = {
    id?: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
    clase: clasesCreateNestedOneWithoutGrabacionesInput
    usuario: usuariosAdministradoresCreateNestedOneWithoutGrabacionesInput
  }

  export type grabacionesUncheckedCreateInput = {
    id?: string
    claseId: string
    usuarioId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type grabacionesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
    clase?: clasesUpdateOneRequiredWithoutGrabacionesNestedInput
    usuario?: usuariosAdministradoresUpdateOneRequiredWithoutGrabacionesNestedInput
  }

  export type grabacionesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type grabacionesCreateManyInput = {
    id?: string
    claseId: string
    usuarioId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type grabacionesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type grabacionesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAccionAuditoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaFilter<$PrismaModel> | $Enums.AccionAuditoria
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsuariosAdministradoresNullableScalarRelationFilter = {
    is?: usuariosAdministradoresWhereInput | null
    isNot?: usuariosAdministradoresWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type auditoriaCountOrderByAggregateInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    accion?: SortOrder
    detalles?: SortOrder
    usuarioId?: SortOrder
    creadoEn?: SortOrder
  }

  export type auditoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    accion?: SortOrder
    usuarioId?: SortOrder
    creadoEn?: SortOrder
  }

  export type auditoriaMinOrderByAggregateInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    accion?: SortOrder
    usuarioId?: SortOrder
    creadoEn?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAccionAuditoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaWithAggregatesFilter<$PrismaModel> | $Enums.AccionAuditoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
    _max?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CategoriasCursosListRelationFilter = {
    every?: categoriasCursosWhereInput
    some?: categoriasCursosWhereInput
    none?: categoriasCursosWhereInput
  }

  export type categoriasCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriasCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type categoriasMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type categoriasMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EstudiantesNullableScalarRelationFilter = {
    is?: estudiantesWhereInput | null
    isNot?: estudiantesWhereInput | null
  }

  export type ReviewsCursosListRelationFilter = {
    every?: reviewsCursosWhereInput
    some?: reviewsCursosWhereInput
    none?: reviewsCursosWhereInput
  }

  export type ComprasListRelationFilter = {
    every?: comprasWhereInput
    some?: comprasWhereInput
    none?: comprasWhereInput
  }

  export type reviewsCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comprasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuariosEstudiantesCountOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrder
    estudianteId?: SortOrder
    registrado?: SortOrder
  }

  export type usuariosEstudiantesMaxOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrder
    estudianteId?: SortOrder
    registrado?: SortOrder
  }

  export type usuariosEstudiantesMinOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrder
    estudianteId?: SortOrder
    registrado?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumTipoGeneroNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGenero | EnumTipoGeneroFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoGeneroNullableFilter<$PrismaModel> | $Enums.TipoGenero | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UsuariosEstudiantesNullableScalarRelationFilter = {
    is?: usuariosEstudiantesWhereInput | null
    isNot?: usuariosEstudiantesWhereInput | null
  }

  export type CalificacionesListRelationFilter = {
    every?: calificacionesWhereInput
    some?: calificacionesWhereInput
    none?: calificacionesWhereInput
  }

  export type CertificadosListRelationFilter = {
    every?: certificadosWhereInput
    some?: certificadosWhereInput
    none?: certificadosWhereInput
  }

  export type InscripcionesListRelationFilter = {
    every?: inscripcionesWhereInput
    some?: inscripcionesWhereInput
    none?: inscripcionesWhereInput
  }

  export type calificacionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type certificadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type inscripcionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estudiantesCountOrderByAggregateInput = {
    id?: SortOrder
    apellido?: SortOrder
    celular?: SortOrder
    pais?: SortOrder
    genero?: SortOrder
    fechaNacimiento?: SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type estudiantesMaxOrderByAggregateInput = {
    id?: SortOrder
    apellido?: SortOrder
    celular?: SortOrder
    pais?: SortOrder
    genero?: SortOrder
    fechaNacimiento?: SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type estudiantesMinOrderByAggregateInput = {
    id?: SortOrder
    apellido?: SortOrder
    celular?: SortOrder
    pais?: SortOrder
    genero?: SortOrder
    fechaNacimiento?: SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type EnumTipoGeneroNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGenero | EnumTipoGeneroFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoGeneroNullableWithAggregatesFilter<$PrismaModel> | $Enums.TipoGenero | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTipoGeneroNullableFilter<$PrismaModel>
    _max?: NestedEnumTipoGeneroNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTipoCuentaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCuenta | EnumTipoCuentaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCuentaFilter<$PrismaModel> | $Enums.TipoCuenta
  }

  export type DocenteNullableScalarRelationFilter = {
    is?: docenteWhereInput | null
    isNot?: docenteWhereInput | null
  }

  export type AuditoriaListRelationFilter = {
    every?: auditoriaWhereInput
    some?: auditoriaWhereInput
    none?: auditoriaWhereInput
  }

  export type GrabacionesListRelationFilter = {
    every?: grabacionesWhereInput
    some?: grabacionesWhereInput
    none?: grabacionesWhereInput
  }

  export type auditoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type grabacionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuariosAdministradoresCountOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
  }

  export type usuariosAdministradoresMaxOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
  }

  export type usuariosAdministradoresMinOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
  }

  export type EnumTipoCuentaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCuenta | EnumTipoCuentaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCuentaWithAggregatesFilter<$PrismaModel> | $Enums.TipoCuenta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoCuentaFilter<$PrismaModel>
    _max?: NestedEnumTipoCuentaFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UsuariosAdministradoresScalarRelationFilter = {
    is?: usuariosAdministradoresWhereInput
    isNot?: usuariosAdministradoresWhereInput
  }

  export type EdicionesCursosListRelationFilter = {
    every?: edicionesCursosWhereInput
    some?: edicionesCursosWhereInput
    none?: edicionesCursosWhereInput
  }

  export type edicionesCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type docenteCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
  }

  export type docenteAvgOrderByAggregateInput = {
    experiencia?: SortOrder
  }

  export type docenteMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
  }

  export type docenteMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
  }

  export type docenteSumOrderByAggregateInput = {
    experiencia?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BeneficiosCursosListRelationFilter = {
    every?: beneficiosCursosWhereInput
    some?: beneficiosCursosWhereInput
    none?: beneficiosCursosWhereInput
  }

  export type ObjetivosCursosListRelationFilter = {
    every?: objetivosCursosWhereInput
    some?: objetivosCursosWhereInput
    none?: objetivosCursosWhereInput
  }

  export type RequisitosCursosListRelationFilter = {
    every?: requisitosCursosWhereInput
    some?: requisitosCursosWhereInput
    none?: requisitosCursosWhereInput
  }

  export type beneficiosCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type objetivosCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type requisitosCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cursosCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrder
  }

  export type cursosMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrder
  }

  export type cursosMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrder
  }

  export type CategoriasScalarRelationFilter = {
    is?: categoriasWhereInput
    isNot?: categoriasWhereInput
  }

  export type CursosScalarRelationFilter = {
    is?: cursosWhereInput
    isNot?: cursosWhereInput
  }

  export type categoriasCursosCursoIdCategoriaIdCompoundUniqueInput = {
    cursoId: string
    categoriaId: string
  }

  export type categoriasCursosCountOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
  }

  export type categoriasCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
  }

  export type categoriasCursosMinOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
  }

  export type UsuariosEstudiantesScalarRelationFilter = {
    is?: usuariosEstudiantesWhereInput
    isNot?: usuariosEstudiantesWhereInput
  }

  export type reviewsCursosCountOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrder
  }

  export type reviewsCursosAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type reviewsCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrder
  }

  export type reviewsCursosMinOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrder
  }

  export type reviewsCursosSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumEdicionEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.EdicionEstado | EnumEdicionEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEdicionEstadoFilter<$PrismaModel> | $Enums.EdicionEstado
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DocenteScalarRelationFilter = {
    is?: docenteWhereInput
    isNot?: docenteWhereInput
  }

  export type ClasesListRelationFilter = {
    every?: clasesWhereInput
    some?: clasesWhereInput
    none?: clasesWhereInput
  }

  export type ExamenesListRelationFilter = {
    every?: examenesWhereInput
    some?: examenesWhereInput
    none?: examenesWhereInput
  }

  export type PreciosCursosListRelationFilter = {
    every?: preciosCursosWhereInput
    some?: preciosCursosWhereInput
    none?: preciosCursosWhereInput
  }

  export type clasesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type examenesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type preciosCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type edicionesCursosCursoIdCodigoDocenteIdCompoundUniqueInput = {
    cursoId: string
    codigo: string
    docenteId: string
  }

  export type edicionesCursosCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrder
  }

  export type edicionesCursosAvgOrderByAggregateInput = {
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
  }

  export type edicionesCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrder
  }

  export type edicionesCursosMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrder
  }

  export type edicionesCursosSumOrderByAggregateInput = {
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
  }

  export type EnumEdicionEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EdicionEstado | EnumEdicionEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEdicionEstadoWithAggregatesFilter<$PrismaModel> | $Enums.EdicionEstado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEdicionEstadoFilter<$PrismaModel>
    _max?: NestedEnumEdicionEstadoFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type beneficiosCursosCountOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type beneficiosCursosAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type beneficiosCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type beneficiosCursosMinOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type beneficiosCursosSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type objetivosCursosCountOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type objetivosCursosAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type objetivosCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type objetivosCursosMinOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type objetivosCursosSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type requisitosCursosCountOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type requisitosCursosAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type requisitosCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type requisitosCursosMinOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type requisitosCursosSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EdicionesCursosScalarRelationFilter = {
    is?: edicionesCursosWhereInput
    isNot?: edicionesCursosWhereInput
  }

  export type MaterialesListRelationFilter = {
    every?: materialesWhereInput
    some?: materialesWhereInput
    none?: materialesWhereInput
  }

  export type materialesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clasesCountOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrder
    creadoEn?: SortOrder
  }

  export type clasesAvgOrderByAggregateInput = {
    duracion?: SortOrder
    orden?: SortOrder
  }

  export type clasesMaxOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrder
    creadoEn?: SortOrder
  }

  export type clasesMinOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrder
    creadoEn?: SortOrder
  }

  export type clasesSumOrderByAggregateInput = {
    duracion?: SortOrder
    orden?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ClasesScalarRelationFilter = {
    is?: clasesWhereInput
    isNot?: clasesWhereInput
  }

  export type materialesCountOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
  }

  export type materialesMaxOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
  }

  export type materialesMinOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
  }

  export type examenesCountOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
  }

  export type examenesAvgOrderByAggregateInput = {
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
  }

  export type examenesMaxOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
  }

  export type examenesMinOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
  }

  export type examenesSumOrderByAggregateInput = {
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
  }

  export type EstudiantesScalarRelationFilter = {
    is?: estudiantesWhereInput
    isNot?: estudiantesWhereInput
  }

  export type ExamenesScalarRelationFilter = {
    is?: examenesWhereInput
    isNot?: examenesWhereInput
  }

  export type calificacionesEstudianteIdExamenIdCompoundUniqueInput = {
    estudianteId: string
    examenId: string
  }

  export type calificacionesCountOrderByAggregateInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
  }

  export type calificacionesAvgOrderByAggregateInput = {
    nota?: SortOrder
  }

  export type calificacionesMaxOrderByAggregateInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
  }

  export type calificacionesMinOrderByAggregateInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
  }

  export type calificacionesSumOrderByAggregateInput = {
    nota?: SortOrder
  }

  export type ComprasNullableScalarRelationFilter = {
    is?: comprasWhereInput | null
    isNot?: comprasWhereInput | null
  }

  export type inscripcionesEstudianteIdEdicionIdCompoundUniqueInput = {
    estudianteId: string
    edicionId: string
  }

  export type inscripcionesCountOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    actualizadoEn?: SortOrder
    compraId?: SortOrder
  }

  export type inscripcionesMaxOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    actualizadoEn?: SortOrder
    compraId?: SortOrder
  }

  export type inscripcionesMinOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    actualizadoEn?: SortOrder
    compraId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type certificadosEstudianteIdEdicionIdCompoundUniqueInput = {
    estudianteId: string
    edicionId: string
  }

  export type certificadosCountOrderByAggregateInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    notaFinal?: SortOrder
    urlCertificado?: SortOrder
    creadoEn?: SortOrder
  }

  export type certificadosAvgOrderByAggregateInput = {
    notaFinal?: SortOrder
  }

  export type certificadosMaxOrderByAggregateInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    notaFinal?: SortOrder
    urlCertificado?: SortOrder
    creadoEn?: SortOrder
  }

  export type certificadosMinOrderByAggregateInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    notaFinal?: SortOrder
    urlCertificado?: SortOrder
    creadoEn?: SortOrder
  }

  export type certificadosSumOrderByAggregateInput = {
    notaFinal?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type preciosCursosCountOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type preciosCursosAvgOrderByAggregateInput = {
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
  }

  export type preciosCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type preciosCursosMinOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type preciosCursosSumOrderByAggregateInput = {
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
  }

  export type InscripcionesNullableScalarRelationFilter = {
    is?: inscripcionesWhereInput | null
    isNot?: inscripcionesWhereInput | null
  }

  export type comprasCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    providerId?: SortOrder
    comprobado?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrder
    usuariosEstudiantesId?: SortOrder
  }

  export type comprasAvgOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type comprasMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    providerId?: SortOrder
    comprobado?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrder
    usuariosEstudiantesId?: SortOrder
  }

  export type comprasMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    providerId?: SortOrder
    comprobado?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrder
    usuariosEstudiantesId?: SortOrder
  }

  export type comprasSumOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type grabacionesCountOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    duracionSegundos?: SortOrder
    completada?: SortOrder
  }

  export type grabacionesAvgOrderByAggregateInput = {
    duracionSegundos?: SortOrder
  }

  export type grabacionesMaxOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    duracionSegundos?: SortOrder
    completada?: SortOrder
  }

  export type grabacionesMinOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    duracionSegundos?: SortOrder
    completada?: SortOrder
  }

  export type grabacionesSumOrderByAggregateInput = {
    duracionSegundos?: SortOrder
  }

  export type usuariosAdministradoresCreateNestedOneWithoutAuditoriasInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutAuditoriasInput, usuariosAdministradoresUncheckedCreateWithoutAuditoriasInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutAuditoriasInput
    connect?: usuariosAdministradoresWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAccionAuditoriaFieldUpdateOperationsInput = {
    set?: $Enums.AccionAuditoria
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usuariosAdministradoresUpdateOneWithoutAuditoriasNestedInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutAuditoriasInput, usuariosAdministradoresUncheckedCreateWithoutAuditoriasInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutAuditoriasInput
    upsert?: usuariosAdministradoresUpsertWithoutAuditoriasInput
    disconnect?: usuariosAdministradoresWhereInput | boolean
    delete?: usuariosAdministradoresWhereInput | boolean
    connect?: usuariosAdministradoresWhereUniqueInput
    update?: XOR<XOR<usuariosAdministradoresUpdateToOneWithWhereWithoutAuditoriasInput, usuariosAdministradoresUpdateWithoutAuditoriasInput>, usuariosAdministradoresUncheckedUpdateWithoutAuditoriasInput>
  }

  export type categoriasCursosCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<categoriasCursosCreateWithoutCategoriaInput, categoriasCursosUncheckedCreateWithoutCategoriaInput> | categoriasCursosCreateWithoutCategoriaInput[] | categoriasCursosUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCategoriaInput | categoriasCursosCreateOrConnectWithoutCategoriaInput[]
    createMany?: categoriasCursosCreateManyCategoriaInputEnvelope
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
  }

  export type categoriasCursosUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<categoriasCursosCreateWithoutCategoriaInput, categoriasCursosUncheckedCreateWithoutCategoriaInput> | categoriasCursosCreateWithoutCategoriaInput[] | categoriasCursosUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCategoriaInput | categoriasCursosCreateOrConnectWithoutCategoriaInput[]
    createMany?: categoriasCursosCreateManyCategoriaInputEnvelope
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
  }

  export type categoriasCursosUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<categoriasCursosCreateWithoutCategoriaInput, categoriasCursosUncheckedCreateWithoutCategoriaInput> | categoriasCursosCreateWithoutCategoriaInput[] | categoriasCursosUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCategoriaInput | categoriasCursosCreateOrConnectWithoutCategoriaInput[]
    upsert?: categoriasCursosUpsertWithWhereUniqueWithoutCategoriaInput | categoriasCursosUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: categoriasCursosCreateManyCategoriaInputEnvelope
    set?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    disconnect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    delete?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    update?: categoriasCursosUpdateWithWhereUniqueWithoutCategoriaInput | categoriasCursosUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: categoriasCursosUpdateManyWithWhereWithoutCategoriaInput | categoriasCursosUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
  }

  export type categoriasCursosUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<categoriasCursosCreateWithoutCategoriaInput, categoriasCursosUncheckedCreateWithoutCategoriaInput> | categoriasCursosCreateWithoutCategoriaInput[] | categoriasCursosUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCategoriaInput | categoriasCursosCreateOrConnectWithoutCategoriaInput[]
    upsert?: categoriasCursosUpsertWithWhereUniqueWithoutCategoriaInput | categoriasCursosUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: categoriasCursosCreateManyCategoriaInputEnvelope
    set?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    disconnect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    delete?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    update?: categoriasCursosUpdateWithWhereUniqueWithoutCategoriaInput | categoriasCursosUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: categoriasCursosUpdateManyWithWhereWithoutCategoriaInput | categoriasCursosUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
  }

  export type estudiantesCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<estudiantesCreateWithoutUsuarioInput, estudiantesUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutUsuarioInput
    connect?: estudiantesWhereUniqueInput
  }

  export type reviewsCursosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<reviewsCursosCreateWithoutUsuarioInput, reviewsCursosUncheckedCreateWithoutUsuarioInput> | reviewsCursosCreateWithoutUsuarioInput[] | reviewsCursosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutUsuarioInput | reviewsCursosCreateOrConnectWithoutUsuarioInput[]
    createMany?: reviewsCursosCreateManyUsuarioInputEnvelope
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
  }

  export type comprasCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<comprasCreateWithoutUsuarioInput, comprasUncheckedCreateWithoutUsuarioInput> | comprasCreateWithoutUsuarioInput[] | comprasUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutUsuarioInput | comprasCreateOrConnectWithoutUsuarioInput[]
    createMany?: comprasCreateManyUsuarioInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type reviewsCursosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<reviewsCursosCreateWithoutUsuarioInput, reviewsCursosUncheckedCreateWithoutUsuarioInput> | reviewsCursosCreateWithoutUsuarioInput[] | reviewsCursosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutUsuarioInput | reviewsCursosCreateOrConnectWithoutUsuarioInput[]
    createMany?: reviewsCursosCreateManyUsuarioInputEnvelope
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
  }

  export type comprasUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<comprasCreateWithoutUsuarioInput, comprasUncheckedCreateWithoutUsuarioInput> | comprasCreateWithoutUsuarioInput[] | comprasUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutUsuarioInput | comprasCreateOrConnectWithoutUsuarioInput[]
    createMany?: comprasCreateManyUsuarioInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type estudiantesUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<estudiantesCreateWithoutUsuarioInput, estudiantesUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutUsuarioInput
    upsert?: estudiantesUpsertWithoutUsuarioInput
    disconnect?: estudiantesWhereInput | boolean
    delete?: estudiantesWhereInput | boolean
    connect?: estudiantesWhereUniqueInput
    update?: XOR<XOR<estudiantesUpdateToOneWithWhereWithoutUsuarioInput, estudiantesUpdateWithoutUsuarioInput>, estudiantesUncheckedUpdateWithoutUsuarioInput>
  }

  export type reviewsCursosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<reviewsCursosCreateWithoutUsuarioInput, reviewsCursosUncheckedCreateWithoutUsuarioInput> | reviewsCursosCreateWithoutUsuarioInput[] | reviewsCursosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutUsuarioInput | reviewsCursosCreateOrConnectWithoutUsuarioInput[]
    upsert?: reviewsCursosUpsertWithWhereUniqueWithoutUsuarioInput | reviewsCursosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: reviewsCursosCreateManyUsuarioInputEnvelope
    set?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    disconnect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    delete?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    update?: reviewsCursosUpdateWithWhereUniqueWithoutUsuarioInput | reviewsCursosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: reviewsCursosUpdateManyWithWhereWithoutUsuarioInput | reviewsCursosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
  }

  export type comprasUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<comprasCreateWithoutUsuarioInput, comprasUncheckedCreateWithoutUsuarioInput> | comprasCreateWithoutUsuarioInput[] | comprasUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutUsuarioInput | comprasCreateOrConnectWithoutUsuarioInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutUsuarioInput | comprasUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: comprasCreateManyUsuarioInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutUsuarioInput | comprasUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutUsuarioInput | comprasUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type reviewsCursosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<reviewsCursosCreateWithoutUsuarioInput, reviewsCursosUncheckedCreateWithoutUsuarioInput> | reviewsCursosCreateWithoutUsuarioInput[] | reviewsCursosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutUsuarioInput | reviewsCursosCreateOrConnectWithoutUsuarioInput[]
    upsert?: reviewsCursosUpsertWithWhereUniqueWithoutUsuarioInput | reviewsCursosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: reviewsCursosCreateManyUsuarioInputEnvelope
    set?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    disconnect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    delete?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    update?: reviewsCursosUpdateWithWhereUniqueWithoutUsuarioInput | reviewsCursosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: reviewsCursosUpdateManyWithWhereWithoutUsuarioInput | reviewsCursosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
  }

  export type comprasUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<comprasCreateWithoutUsuarioInput, comprasUncheckedCreateWithoutUsuarioInput> | comprasCreateWithoutUsuarioInput[] | comprasUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutUsuarioInput | comprasCreateOrConnectWithoutUsuarioInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutUsuarioInput | comprasUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: comprasCreateManyUsuarioInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutUsuarioInput | comprasUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutUsuarioInput | comprasUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type usuariosEstudiantesCreateNestedOneWithoutEstudianteInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutEstudianteInput, usuariosEstudiantesUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutEstudianteInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type calificacionesCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<calificacionesCreateWithoutEstudianteInput, calificacionesUncheckedCreateWithoutEstudianteInput> | calificacionesCreateWithoutEstudianteInput[] | calificacionesUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutEstudianteInput | calificacionesCreateOrConnectWithoutEstudianteInput[]
    createMany?: calificacionesCreateManyEstudianteInputEnvelope
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
  }

  export type certificadosCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<certificadosCreateWithoutEstudianteInput, certificadosUncheckedCreateWithoutEstudianteInput> | certificadosCreateWithoutEstudianteInput[] | certificadosUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEstudianteInput | certificadosCreateOrConnectWithoutEstudianteInput[]
    createMany?: certificadosCreateManyEstudianteInputEnvelope
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
  }

  export type inscripcionesCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<inscripcionesCreateWithoutEstudianteInput, inscripcionesUncheckedCreateWithoutEstudianteInput> | inscripcionesCreateWithoutEstudianteInput[] | inscripcionesUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEstudianteInput | inscripcionesCreateOrConnectWithoutEstudianteInput[]
    createMany?: inscripcionesCreateManyEstudianteInputEnvelope
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
  }

  export type usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudianteInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutEstudianteInput, usuariosEstudiantesUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutEstudianteInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type calificacionesUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<calificacionesCreateWithoutEstudianteInput, calificacionesUncheckedCreateWithoutEstudianteInput> | calificacionesCreateWithoutEstudianteInput[] | calificacionesUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutEstudianteInput | calificacionesCreateOrConnectWithoutEstudianteInput[]
    createMany?: calificacionesCreateManyEstudianteInputEnvelope
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
  }

  export type certificadosUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<certificadosCreateWithoutEstudianteInput, certificadosUncheckedCreateWithoutEstudianteInput> | certificadosCreateWithoutEstudianteInput[] | certificadosUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEstudianteInput | certificadosCreateOrConnectWithoutEstudianteInput[]
    createMany?: certificadosCreateManyEstudianteInputEnvelope
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
  }

  export type inscripcionesUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<inscripcionesCreateWithoutEstudianteInput, inscripcionesUncheckedCreateWithoutEstudianteInput> | inscripcionesCreateWithoutEstudianteInput[] | inscripcionesUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEstudianteInput | inscripcionesCreateOrConnectWithoutEstudianteInput[]
    createMany?: inscripcionesCreateManyEstudianteInputEnvelope
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
  }

  export type NullableEnumTipoGeneroFieldUpdateOperationsInput = {
    set?: $Enums.TipoGenero | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type usuariosEstudiantesUpdateOneWithoutEstudianteNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutEstudianteInput, usuariosEstudiantesUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutEstudianteInput
    upsert?: usuariosEstudiantesUpsertWithoutEstudianteInput
    disconnect?: usuariosEstudiantesWhereInput | boolean
    delete?: usuariosEstudiantesWhereInput | boolean
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutEstudianteInput, usuariosEstudiantesUpdateWithoutEstudianteInput>, usuariosEstudiantesUncheckedUpdateWithoutEstudianteInput>
  }

  export type calificacionesUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<calificacionesCreateWithoutEstudianteInput, calificacionesUncheckedCreateWithoutEstudianteInput> | calificacionesCreateWithoutEstudianteInput[] | calificacionesUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutEstudianteInput | calificacionesCreateOrConnectWithoutEstudianteInput[]
    upsert?: calificacionesUpsertWithWhereUniqueWithoutEstudianteInput | calificacionesUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: calificacionesCreateManyEstudianteInputEnvelope
    set?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    disconnect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    delete?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    update?: calificacionesUpdateWithWhereUniqueWithoutEstudianteInput | calificacionesUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: calificacionesUpdateManyWithWhereWithoutEstudianteInput | calificacionesUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
  }

  export type certificadosUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<certificadosCreateWithoutEstudianteInput, certificadosUncheckedCreateWithoutEstudianteInput> | certificadosCreateWithoutEstudianteInput[] | certificadosUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEstudianteInput | certificadosCreateOrConnectWithoutEstudianteInput[]
    upsert?: certificadosUpsertWithWhereUniqueWithoutEstudianteInput | certificadosUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: certificadosCreateManyEstudianteInputEnvelope
    set?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    disconnect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    delete?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    update?: certificadosUpdateWithWhereUniqueWithoutEstudianteInput | certificadosUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: certificadosUpdateManyWithWhereWithoutEstudianteInput | certificadosUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
  }

  export type inscripcionesUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<inscripcionesCreateWithoutEstudianteInput, inscripcionesUncheckedCreateWithoutEstudianteInput> | inscripcionesCreateWithoutEstudianteInput[] | inscripcionesUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEstudianteInput | inscripcionesCreateOrConnectWithoutEstudianteInput[]
    upsert?: inscripcionesUpsertWithWhereUniqueWithoutEstudianteInput | inscripcionesUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: inscripcionesCreateManyEstudianteInputEnvelope
    set?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    disconnect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    delete?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    update?: inscripcionesUpdateWithWhereUniqueWithoutEstudianteInput | inscripcionesUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: inscripcionesUpdateManyWithWhereWithoutEstudianteInput | inscripcionesUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
  }

  export type usuariosEstudiantesUncheckedUpdateOneWithoutEstudianteNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutEstudianteInput, usuariosEstudiantesUncheckedCreateWithoutEstudianteInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutEstudianteInput
    upsert?: usuariosEstudiantesUpsertWithoutEstudianteInput
    disconnect?: usuariosEstudiantesWhereInput | boolean
    delete?: usuariosEstudiantesWhereInput | boolean
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutEstudianteInput, usuariosEstudiantesUpdateWithoutEstudianteInput>, usuariosEstudiantesUncheckedUpdateWithoutEstudianteInput>
  }

  export type calificacionesUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<calificacionesCreateWithoutEstudianteInput, calificacionesUncheckedCreateWithoutEstudianteInput> | calificacionesCreateWithoutEstudianteInput[] | calificacionesUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutEstudianteInput | calificacionesCreateOrConnectWithoutEstudianteInput[]
    upsert?: calificacionesUpsertWithWhereUniqueWithoutEstudianteInput | calificacionesUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: calificacionesCreateManyEstudianteInputEnvelope
    set?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    disconnect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    delete?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    update?: calificacionesUpdateWithWhereUniqueWithoutEstudianteInput | calificacionesUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: calificacionesUpdateManyWithWhereWithoutEstudianteInput | calificacionesUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
  }

  export type certificadosUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<certificadosCreateWithoutEstudianteInput, certificadosUncheckedCreateWithoutEstudianteInput> | certificadosCreateWithoutEstudianteInput[] | certificadosUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEstudianteInput | certificadosCreateOrConnectWithoutEstudianteInput[]
    upsert?: certificadosUpsertWithWhereUniqueWithoutEstudianteInput | certificadosUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: certificadosCreateManyEstudianteInputEnvelope
    set?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    disconnect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    delete?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    update?: certificadosUpdateWithWhereUniqueWithoutEstudianteInput | certificadosUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: certificadosUpdateManyWithWhereWithoutEstudianteInput | certificadosUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
  }

  export type inscripcionesUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<inscripcionesCreateWithoutEstudianteInput, inscripcionesUncheckedCreateWithoutEstudianteInput> | inscripcionesCreateWithoutEstudianteInput[] | inscripcionesUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEstudianteInput | inscripcionesCreateOrConnectWithoutEstudianteInput[]
    upsert?: inscripcionesUpsertWithWhereUniqueWithoutEstudianteInput | inscripcionesUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: inscripcionesCreateManyEstudianteInputEnvelope
    set?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    disconnect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    delete?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    update?: inscripcionesUpdateWithWhereUniqueWithoutEstudianteInput | inscripcionesUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: inscripcionesUpdateManyWithWhereWithoutEstudianteInput | inscripcionesUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
  }

  export type docenteCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<docenteCreateWithoutUsuarioInput, docenteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: docenteCreateOrConnectWithoutUsuarioInput
    connect?: docenteWhereUniqueInput
  }

  export type auditoriaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput> | auditoriaCreateWithoutUsuarioInput[] | auditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuarioInput | auditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: auditoriaCreateManyUsuarioInputEnvelope
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
  }

  export type grabacionesCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<grabacionesCreateWithoutUsuarioInput, grabacionesUncheckedCreateWithoutUsuarioInput> | grabacionesCreateWithoutUsuarioInput[] | grabacionesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutUsuarioInput | grabacionesCreateOrConnectWithoutUsuarioInput[]
    createMany?: grabacionesCreateManyUsuarioInputEnvelope
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
  }

  export type docenteUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<docenteCreateWithoutUsuarioInput, docenteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: docenteCreateOrConnectWithoutUsuarioInput
    connect?: docenteWhereUniqueInput
  }

  export type auditoriaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput> | auditoriaCreateWithoutUsuarioInput[] | auditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuarioInput | auditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: auditoriaCreateManyUsuarioInputEnvelope
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
  }

  export type grabacionesUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<grabacionesCreateWithoutUsuarioInput, grabacionesUncheckedCreateWithoutUsuarioInput> | grabacionesCreateWithoutUsuarioInput[] | grabacionesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutUsuarioInput | grabacionesCreateOrConnectWithoutUsuarioInput[]
    createMany?: grabacionesCreateManyUsuarioInputEnvelope
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
  }

  export type EnumTipoCuentaFieldUpdateOperationsInput = {
    set?: $Enums.TipoCuenta
  }

  export type docenteUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<docenteCreateWithoutUsuarioInput, docenteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: docenteCreateOrConnectWithoutUsuarioInput
    upsert?: docenteUpsertWithoutUsuarioInput
    disconnect?: docenteWhereInput | boolean
    delete?: docenteWhereInput | boolean
    connect?: docenteWhereUniqueInput
    update?: XOR<XOR<docenteUpdateToOneWithWhereWithoutUsuarioInput, docenteUpdateWithoutUsuarioInput>, docenteUncheckedUpdateWithoutUsuarioInput>
  }

  export type auditoriaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput> | auditoriaCreateWithoutUsuarioInput[] | auditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuarioInput | auditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: auditoriaUpsertWithWhereUniqueWithoutUsuarioInput | auditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: auditoriaCreateManyUsuarioInputEnvelope
    set?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    disconnect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    delete?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    update?: auditoriaUpdateWithWhereUniqueWithoutUsuarioInput | auditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: auditoriaUpdateManyWithWhereWithoutUsuarioInput | auditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
  }

  export type grabacionesUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<grabacionesCreateWithoutUsuarioInput, grabacionesUncheckedCreateWithoutUsuarioInput> | grabacionesCreateWithoutUsuarioInput[] | grabacionesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutUsuarioInput | grabacionesCreateOrConnectWithoutUsuarioInput[]
    upsert?: grabacionesUpsertWithWhereUniqueWithoutUsuarioInput | grabacionesUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: grabacionesCreateManyUsuarioInputEnvelope
    set?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    disconnect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    delete?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    update?: grabacionesUpdateWithWhereUniqueWithoutUsuarioInput | grabacionesUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: grabacionesUpdateManyWithWhereWithoutUsuarioInput | grabacionesUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
  }

  export type docenteUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<docenteCreateWithoutUsuarioInput, docenteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: docenteCreateOrConnectWithoutUsuarioInput
    upsert?: docenteUpsertWithoutUsuarioInput
    disconnect?: docenteWhereInput | boolean
    delete?: docenteWhereInput | boolean
    connect?: docenteWhereUniqueInput
    update?: XOR<XOR<docenteUpdateToOneWithWhereWithoutUsuarioInput, docenteUpdateWithoutUsuarioInput>, docenteUncheckedUpdateWithoutUsuarioInput>
  }

  export type auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput> | auditoriaCreateWithoutUsuarioInput[] | auditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuarioInput | auditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: auditoriaUpsertWithWhereUniqueWithoutUsuarioInput | auditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: auditoriaCreateManyUsuarioInputEnvelope
    set?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    disconnect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    delete?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    update?: auditoriaUpdateWithWhereUniqueWithoutUsuarioInput | auditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: auditoriaUpdateManyWithWhereWithoutUsuarioInput | auditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
  }

  export type grabacionesUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<grabacionesCreateWithoutUsuarioInput, grabacionesUncheckedCreateWithoutUsuarioInput> | grabacionesCreateWithoutUsuarioInput[] | grabacionesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutUsuarioInput | grabacionesCreateOrConnectWithoutUsuarioInput[]
    upsert?: grabacionesUpsertWithWhereUniqueWithoutUsuarioInput | grabacionesUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: grabacionesCreateManyUsuarioInputEnvelope
    set?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    disconnect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    delete?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    update?: grabacionesUpdateWithWhereUniqueWithoutUsuarioInput | grabacionesUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: grabacionesUpdateManyWithWhereWithoutUsuarioInput | grabacionesUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
  }

  export type usuariosAdministradoresCreateNestedOneWithoutDocenteInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutDocenteInput, usuariosAdministradoresUncheckedCreateWithoutDocenteInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutDocenteInput
    connect?: usuariosAdministradoresWhereUniqueInput
  }

  export type edicionesCursosCreateNestedManyWithoutDocenteInput = {
    create?: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput> | edicionesCursosCreateWithoutDocenteInput[] | edicionesCursosUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutDocenteInput | edicionesCursosCreateOrConnectWithoutDocenteInput[]
    createMany?: edicionesCursosCreateManyDocenteInputEnvelope
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
  }

  export type edicionesCursosUncheckedCreateNestedManyWithoutDocenteInput = {
    create?: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput> | edicionesCursosCreateWithoutDocenteInput[] | edicionesCursosUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutDocenteInput | edicionesCursosCreateOrConnectWithoutDocenteInput[]
    createMany?: edicionesCursosCreateManyDocenteInputEnvelope
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usuariosAdministradoresUpdateOneRequiredWithoutDocenteNestedInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutDocenteInput, usuariosAdministradoresUncheckedCreateWithoutDocenteInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutDocenteInput
    upsert?: usuariosAdministradoresUpsertWithoutDocenteInput
    connect?: usuariosAdministradoresWhereUniqueInput
    update?: XOR<XOR<usuariosAdministradoresUpdateToOneWithWhereWithoutDocenteInput, usuariosAdministradoresUpdateWithoutDocenteInput>, usuariosAdministradoresUncheckedUpdateWithoutDocenteInput>
  }

  export type edicionesCursosUpdateManyWithoutDocenteNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput> | edicionesCursosCreateWithoutDocenteInput[] | edicionesCursosUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutDocenteInput | edicionesCursosCreateOrConnectWithoutDocenteInput[]
    upsert?: edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput | edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput[]
    createMany?: edicionesCursosCreateManyDocenteInputEnvelope
    set?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    disconnect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    delete?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    update?: edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput | edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput[]
    updateMany?: edicionesCursosUpdateManyWithWhereWithoutDocenteInput | edicionesCursosUpdateManyWithWhereWithoutDocenteInput[]
    deleteMany?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
  }

  export type edicionesCursosUncheckedUpdateManyWithoutDocenteNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput> | edicionesCursosCreateWithoutDocenteInput[] | edicionesCursosUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutDocenteInput | edicionesCursosCreateOrConnectWithoutDocenteInput[]
    upsert?: edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput | edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput[]
    createMany?: edicionesCursosCreateManyDocenteInputEnvelope
    set?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    disconnect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    delete?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    update?: edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput | edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput[]
    updateMany?: edicionesCursosUpdateManyWithWhereWithoutDocenteInput | edicionesCursosUpdateManyWithWhereWithoutDocenteInput[]
    deleteMany?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
  }

  export type edicionesCursosCreateNestedManyWithoutCursoInput = {
    create?: XOR<edicionesCursosCreateWithoutCursoInput, edicionesCursosUncheckedCreateWithoutCursoInput> | edicionesCursosCreateWithoutCursoInput[] | edicionesCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCursoInput | edicionesCursosCreateOrConnectWithoutCursoInput[]
    createMany?: edicionesCursosCreateManyCursoInputEnvelope
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
  }

  export type beneficiosCursosCreateNestedManyWithoutCursoInput = {
    create?: XOR<beneficiosCursosCreateWithoutCursoInput, beneficiosCursosUncheckedCreateWithoutCursoInput> | beneficiosCursosCreateWithoutCursoInput[] | beneficiosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: beneficiosCursosCreateOrConnectWithoutCursoInput | beneficiosCursosCreateOrConnectWithoutCursoInput[]
    createMany?: beneficiosCursosCreateManyCursoInputEnvelope
    connect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
  }

  export type objetivosCursosCreateNestedManyWithoutCursoInput = {
    create?: XOR<objetivosCursosCreateWithoutCursoInput, objetivosCursosUncheckedCreateWithoutCursoInput> | objetivosCursosCreateWithoutCursoInput[] | objetivosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: objetivosCursosCreateOrConnectWithoutCursoInput | objetivosCursosCreateOrConnectWithoutCursoInput[]
    createMany?: objetivosCursosCreateManyCursoInputEnvelope
    connect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
  }

  export type requisitosCursosCreateNestedManyWithoutCursoInput = {
    create?: XOR<requisitosCursosCreateWithoutCursoInput, requisitosCursosUncheckedCreateWithoutCursoInput> | requisitosCursosCreateWithoutCursoInput[] | requisitosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: requisitosCursosCreateOrConnectWithoutCursoInput | requisitosCursosCreateOrConnectWithoutCursoInput[]
    createMany?: requisitosCursosCreateManyCursoInputEnvelope
    connect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
  }

  export type categoriasCursosCreateNestedManyWithoutCursoInput = {
    create?: XOR<categoriasCursosCreateWithoutCursoInput, categoriasCursosUncheckedCreateWithoutCursoInput> | categoriasCursosCreateWithoutCursoInput[] | categoriasCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCursoInput | categoriasCursosCreateOrConnectWithoutCursoInput[]
    createMany?: categoriasCursosCreateManyCursoInputEnvelope
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
  }

  export type reviewsCursosCreateNestedManyWithoutCursoInput = {
    create?: XOR<reviewsCursosCreateWithoutCursoInput, reviewsCursosUncheckedCreateWithoutCursoInput> | reviewsCursosCreateWithoutCursoInput[] | reviewsCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutCursoInput | reviewsCursosCreateOrConnectWithoutCursoInput[]
    createMany?: reviewsCursosCreateManyCursoInputEnvelope
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
  }

  export type edicionesCursosUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<edicionesCursosCreateWithoutCursoInput, edicionesCursosUncheckedCreateWithoutCursoInput> | edicionesCursosCreateWithoutCursoInput[] | edicionesCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCursoInput | edicionesCursosCreateOrConnectWithoutCursoInput[]
    createMany?: edicionesCursosCreateManyCursoInputEnvelope
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
  }

  export type beneficiosCursosUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<beneficiosCursosCreateWithoutCursoInput, beneficiosCursosUncheckedCreateWithoutCursoInput> | beneficiosCursosCreateWithoutCursoInput[] | beneficiosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: beneficiosCursosCreateOrConnectWithoutCursoInput | beneficiosCursosCreateOrConnectWithoutCursoInput[]
    createMany?: beneficiosCursosCreateManyCursoInputEnvelope
    connect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
  }

  export type objetivosCursosUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<objetivosCursosCreateWithoutCursoInput, objetivosCursosUncheckedCreateWithoutCursoInput> | objetivosCursosCreateWithoutCursoInput[] | objetivosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: objetivosCursosCreateOrConnectWithoutCursoInput | objetivosCursosCreateOrConnectWithoutCursoInput[]
    createMany?: objetivosCursosCreateManyCursoInputEnvelope
    connect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
  }

  export type requisitosCursosUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<requisitosCursosCreateWithoutCursoInput, requisitosCursosUncheckedCreateWithoutCursoInput> | requisitosCursosCreateWithoutCursoInput[] | requisitosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: requisitosCursosCreateOrConnectWithoutCursoInput | requisitosCursosCreateOrConnectWithoutCursoInput[]
    createMany?: requisitosCursosCreateManyCursoInputEnvelope
    connect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
  }

  export type categoriasCursosUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<categoriasCursosCreateWithoutCursoInput, categoriasCursosUncheckedCreateWithoutCursoInput> | categoriasCursosCreateWithoutCursoInput[] | categoriasCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCursoInput | categoriasCursosCreateOrConnectWithoutCursoInput[]
    createMany?: categoriasCursosCreateManyCursoInputEnvelope
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
  }

  export type reviewsCursosUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<reviewsCursosCreateWithoutCursoInput, reviewsCursosUncheckedCreateWithoutCursoInput> | reviewsCursosCreateWithoutCursoInput[] | reviewsCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutCursoInput | reviewsCursosCreateOrConnectWithoutCursoInput[]
    createMany?: reviewsCursosCreateManyCursoInputEnvelope
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
  }

  export type edicionesCursosUpdateManyWithoutCursoNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutCursoInput, edicionesCursosUncheckedCreateWithoutCursoInput> | edicionesCursosCreateWithoutCursoInput[] | edicionesCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCursoInput | edicionesCursosCreateOrConnectWithoutCursoInput[]
    upsert?: edicionesCursosUpsertWithWhereUniqueWithoutCursoInput | edicionesCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: edicionesCursosCreateManyCursoInputEnvelope
    set?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    disconnect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    delete?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    update?: edicionesCursosUpdateWithWhereUniqueWithoutCursoInput | edicionesCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: edicionesCursosUpdateManyWithWhereWithoutCursoInput | edicionesCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
  }

  export type beneficiosCursosUpdateManyWithoutCursoNestedInput = {
    create?: XOR<beneficiosCursosCreateWithoutCursoInput, beneficiosCursosUncheckedCreateWithoutCursoInput> | beneficiosCursosCreateWithoutCursoInput[] | beneficiosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: beneficiosCursosCreateOrConnectWithoutCursoInput | beneficiosCursosCreateOrConnectWithoutCursoInput[]
    upsert?: beneficiosCursosUpsertWithWhereUniqueWithoutCursoInput | beneficiosCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: beneficiosCursosCreateManyCursoInputEnvelope
    set?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    disconnect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    delete?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    connect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    update?: beneficiosCursosUpdateWithWhereUniqueWithoutCursoInput | beneficiosCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: beneficiosCursosUpdateManyWithWhereWithoutCursoInput | beneficiosCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: beneficiosCursosScalarWhereInput | beneficiosCursosScalarWhereInput[]
  }

  export type objetivosCursosUpdateManyWithoutCursoNestedInput = {
    create?: XOR<objetivosCursosCreateWithoutCursoInput, objetivosCursosUncheckedCreateWithoutCursoInput> | objetivosCursosCreateWithoutCursoInput[] | objetivosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: objetivosCursosCreateOrConnectWithoutCursoInput | objetivosCursosCreateOrConnectWithoutCursoInput[]
    upsert?: objetivosCursosUpsertWithWhereUniqueWithoutCursoInput | objetivosCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: objetivosCursosCreateManyCursoInputEnvelope
    set?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    disconnect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    delete?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    connect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    update?: objetivosCursosUpdateWithWhereUniqueWithoutCursoInput | objetivosCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: objetivosCursosUpdateManyWithWhereWithoutCursoInput | objetivosCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: objetivosCursosScalarWhereInput | objetivosCursosScalarWhereInput[]
  }

  export type requisitosCursosUpdateManyWithoutCursoNestedInput = {
    create?: XOR<requisitosCursosCreateWithoutCursoInput, requisitosCursosUncheckedCreateWithoutCursoInput> | requisitosCursosCreateWithoutCursoInput[] | requisitosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: requisitosCursosCreateOrConnectWithoutCursoInput | requisitosCursosCreateOrConnectWithoutCursoInput[]
    upsert?: requisitosCursosUpsertWithWhereUniqueWithoutCursoInput | requisitosCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: requisitosCursosCreateManyCursoInputEnvelope
    set?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    disconnect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    delete?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    connect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    update?: requisitosCursosUpdateWithWhereUniqueWithoutCursoInput | requisitosCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: requisitosCursosUpdateManyWithWhereWithoutCursoInput | requisitosCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: requisitosCursosScalarWhereInput | requisitosCursosScalarWhereInput[]
  }

  export type categoriasCursosUpdateManyWithoutCursoNestedInput = {
    create?: XOR<categoriasCursosCreateWithoutCursoInput, categoriasCursosUncheckedCreateWithoutCursoInput> | categoriasCursosCreateWithoutCursoInput[] | categoriasCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCursoInput | categoriasCursosCreateOrConnectWithoutCursoInput[]
    upsert?: categoriasCursosUpsertWithWhereUniqueWithoutCursoInput | categoriasCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: categoriasCursosCreateManyCursoInputEnvelope
    set?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    disconnect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    delete?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    update?: categoriasCursosUpdateWithWhereUniqueWithoutCursoInput | categoriasCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: categoriasCursosUpdateManyWithWhereWithoutCursoInput | categoriasCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
  }

  export type reviewsCursosUpdateManyWithoutCursoNestedInput = {
    create?: XOR<reviewsCursosCreateWithoutCursoInput, reviewsCursosUncheckedCreateWithoutCursoInput> | reviewsCursosCreateWithoutCursoInput[] | reviewsCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutCursoInput | reviewsCursosCreateOrConnectWithoutCursoInput[]
    upsert?: reviewsCursosUpsertWithWhereUniqueWithoutCursoInput | reviewsCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: reviewsCursosCreateManyCursoInputEnvelope
    set?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    disconnect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    delete?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    update?: reviewsCursosUpdateWithWhereUniqueWithoutCursoInput | reviewsCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: reviewsCursosUpdateManyWithWhereWithoutCursoInput | reviewsCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
  }

  export type edicionesCursosUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutCursoInput, edicionesCursosUncheckedCreateWithoutCursoInput> | edicionesCursosCreateWithoutCursoInput[] | edicionesCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCursoInput | edicionesCursosCreateOrConnectWithoutCursoInput[]
    upsert?: edicionesCursosUpsertWithWhereUniqueWithoutCursoInput | edicionesCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: edicionesCursosCreateManyCursoInputEnvelope
    set?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    disconnect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    delete?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    update?: edicionesCursosUpdateWithWhereUniqueWithoutCursoInput | edicionesCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: edicionesCursosUpdateManyWithWhereWithoutCursoInput | edicionesCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
  }

  export type beneficiosCursosUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<beneficiosCursosCreateWithoutCursoInput, beneficiosCursosUncheckedCreateWithoutCursoInput> | beneficiosCursosCreateWithoutCursoInput[] | beneficiosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: beneficiosCursosCreateOrConnectWithoutCursoInput | beneficiosCursosCreateOrConnectWithoutCursoInput[]
    upsert?: beneficiosCursosUpsertWithWhereUniqueWithoutCursoInput | beneficiosCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: beneficiosCursosCreateManyCursoInputEnvelope
    set?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    disconnect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    delete?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    connect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    update?: beneficiosCursosUpdateWithWhereUniqueWithoutCursoInput | beneficiosCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: beneficiosCursosUpdateManyWithWhereWithoutCursoInput | beneficiosCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: beneficiosCursosScalarWhereInput | beneficiosCursosScalarWhereInput[]
  }

  export type objetivosCursosUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<objetivosCursosCreateWithoutCursoInput, objetivosCursosUncheckedCreateWithoutCursoInput> | objetivosCursosCreateWithoutCursoInput[] | objetivosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: objetivosCursosCreateOrConnectWithoutCursoInput | objetivosCursosCreateOrConnectWithoutCursoInput[]
    upsert?: objetivosCursosUpsertWithWhereUniqueWithoutCursoInput | objetivosCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: objetivosCursosCreateManyCursoInputEnvelope
    set?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    disconnect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    delete?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    connect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    update?: objetivosCursosUpdateWithWhereUniqueWithoutCursoInput | objetivosCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: objetivosCursosUpdateManyWithWhereWithoutCursoInput | objetivosCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: objetivosCursosScalarWhereInput | objetivosCursosScalarWhereInput[]
  }

  export type requisitosCursosUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<requisitosCursosCreateWithoutCursoInput, requisitosCursosUncheckedCreateWithoutCursoInput> | requisitosCursosCreateWithoutCursoInput[] | requisitosCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: requisitosCursosCreateOrConnectWithoutCursoInput | requisitosCursosCreateOrConnectWithoutCursoInput[]
    upsert?: requisitosCursosUpsertWithWhereUniqueWithoutCursoInput | requisitosCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: requisitosCursosCreateManyCursoInputEnvelope
    set?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    disconnect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    delete?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    connect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    update?: requisitosCursosUpdateWithWhereUniqueWithoutCursoInput | requisitosCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: requisitosCursosUpdateManyWithWhereWithoutCursoInput | requisitosCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: requisitosCursosScalarWhereInput | requisitosCursosScalarWhereInput[]
  }

  export type categoriasCursosUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<categoriasCursosCreateWithoutCursoInput, categoriasCursosUncheckedCreateWithoutCursoInput> | categoriasCursosCreateWithoutCursoInput[] | categoriasCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCursoInput | categoriasCursosCreateOrConnectWithoutCursoInput[]
    upsert?: categoriasCursosUpsertWithWhereUniqueWithoutCursoInput | categoriasCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: categoriasCursosCreateManyCursoInputEnvelope
    set?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    disconnect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    delete?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    update?: categoriasCursosUpdateWithWhereUniqueWithoutCursoInput | categoriasCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: categoriasCursosUpdateManyWithWhereWithoutCursoInput | categoriasCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
  }

  export type reviewsCursosUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<reviewsCursosCreateWithoutCursoInput, reviewsCursosUncheckedCreateWithoutCursoInput> | reviewsCursosCreateWithoutCursoInput[] | reviewsCursosUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutCursoInput | reviewsCursosCreateOrConnectWithoutCursoInput[]
    upsert?: reviewsCursosUpsertWithWhereUniqueWithoutCursoInput | reviewsCursosUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: reviewsCursosCreateManyCursoInputEnvelope
    set?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    disconnect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    delete?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    update?: reviewsCursosUpdateWithWhereUniqueWithoutCursoInput | reviewsCursosUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: reviewsCursosUpdateManyWithWhereWithoutCursoInput | reviewsCursosUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
  }

  export type categoriasCreateNestedOneWithoutCategoriasCursosInput = {
    create?: XOR<categoriasCreateWithoutCategoriasCursosInput, categoriasUncheckedCreateWithoutCategoriasCursosInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutCategoriasCursosInput
    connect?: categoriasWhereUniqueInput
  }

  export type cursosCreateNestedOneWithoutCategoriasInput = {
    create?: XOR<cursosCreateWithoutCategoriasInput, cursosUncheckedCreateWithoutCategoriasInput>
    connectOrCreate?: cursosCreateOrConnectWithoutCategoriasInput
    connect?: cursosWhereUniqueInput
  }

  export type categoriasUpdateOneRequiredWithoutCategoriasCursosNestedInput = {
    create?: XOR<categoriasCreateWithoutCategoriasCursosInput, categoriasUncheckedCreateWithoutCategoriasCursosInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutCategoriasCursosInput
    upsert?: categoriasUpsertWithoutCategoriasCursosInput
    connect?: categoriasWhereUniqueInput
    update?: XOR<XOR<categoriasUpdateToOneWithWhereWithoutCategoriasCursosInput, categoriasUpdateWithoutCategoriasCursosInput>, categoriasUncheckedUpdateWithoutCategoriasCursosInput>
  }

  export type cursosUpdateOneRequiredWithoutCategoriasNestedInput = {
    create?: XOR<cursosCreateWithoutCategoriasInput, cursosUncheckedCreateWithoutCategoriasInput>
    connectOrCreate?: cursosCreateOrConnectWithoutCategoriasInput
    upsert?: cursosUpsertWithoutCategoriasInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutCategoriasInput, cursosUpdateWithoutCategoriasInput>, cursosUncheckedUpdateWithoutCategoriasInput>
  }

  export type cursosCreateNestedOneWithoutReviewsInput = {
    create?: XOR<cursosCreateWithoutReviewsInput, cursosUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: cursosCreateOrConnectWithoutReviewsInput
    connect?: cursosWhereUniqueInput
  }

  export type usuariosEstudiantesCreateNestedOneWithoutReviewsInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutReviewsInput, usuariosEstudiantesUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutReviewsInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type cursosUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<cursosCreateWithoutReviewsInput, cursosUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: cursosCreateOrConnectWithoutReviewsInput
    upsert?: cursosUpsertWithoutReviewsInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutReviewsInput, cursosUpdateWithoutReviewsInput>, cursosUncheckedUpdateWithoutReviewsInput>
  }

  export type usuariosEstudiantesUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutReviewsInput, usuariosEstudiantesUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutReviewsInput
    upsert?: usuariosEstudiantesUpsertWithoutReviewsInput
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutReviewsInput, usuariosEstudiantesUpdateWithoutReviewsInput>, usuariosEstudiantesUncheckedUpdateWithoutReviewsInput>
  }

  export type docenteCreateNestedOneWithoutEdicionesInput = {
    create?: XOR<docenteCreateWithoutEdicionesInput, docenteUncheckedCreateWithoutEdicionesInput>
    connectOrCreate?: docenteCreateOrConnectWithoutEdicionesInput
    connect?: docenteWhereUniqueInput
  }

  export type cursosCreateNestedOneWithoutEdicionesInput = {
    create?: XOR<cursosCreateWithoutEdicionesInput, cursosUncheckedCreateWithoutEdicionesInput>
    connectOrCreate?: cursosCreateOrConnectWithoutEdicionesInput
    connect?: cursosWhereUniqueInput
  }

  export type comprasCreateNestedManyWithoutEdicionInput = {
    create?: XOR<comprasCreateWithoutEdicionInput, comprasUncheckedCreateWithoutEdicionInput> | comprasCreateWithoutEdicionInput[] | comprasUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutEdicionInput | comprasCreateOrConnectWithoutEdicionInput[]
    createMany?: comprasCreateManyEdicionInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type certificadosCreateNestedManyWithoutEdicionInput = {
    create?: XOR<certificadosCreateWithoutEdicionInput, certificadosUncheckedCreateWithoutEdicionInput> | certificadosCreateWithoutEdicionInput[] | certificadosUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEdicionInput | certificadosCreateOrConnectWithoutEdicionInput[]
    createMany?: certificadosCreateManyEdicionInputEnvelope
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
  }

  export type clasesCreateNestedManyWithoutEdicionInput = {
    create?: XOR<clasesCreateWithoutEdicionInput, clasesUncheckedCreateWithoutEdicionInput> | clasesCreateWithoutEdicionInput[] | clasesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: clasesCreateOrConnectWithoutEdicionInput | clasesCreateOrConnectWithoutEdicionInput[]
    createMany?: clasesCreateManyEdicionInputEnvelope
    connect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
  }

  export type examenesCreateNestedManyWithoutEdicionInput = {
    create?: XOR<examenesCreateWithoutEdicionInput, examenesUncheckedCreateWithoutEdicionInput> | examenesCreateWithoutEdicionInput[] | examenesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: examenesCreateOrConnectWithoutEdicionInput | examenesCreateOrConnectWithoutEdicionInput[]
    createMany?: examenesCreateManyEdicionInputEnvelope
    connect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
  }

  export type inscripcionesCreateNestedManyWithoutEdicionInput = {
    create?: XOR<inscripcionesCreateWithoutEdicionInput, inscripcionesUncheckedCreateWithoutEdicionInput> | inscripcionesCreateWithoutEdicionInput[] | inscripcionesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEdicionInput | inscripcionesCreateOrConnectWithoutEdicionInput[]
    createMany?: inscripcionesCreateManyEdicionInputEnvelope
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
  }

  export type preciosCursosCreateNestedManyWithoutEdicionInput = {
    create?: XOR<preciosCursosCreateWithoutEdicionInput, preciosCursosUncheckedCreateWithoutEdicionInput> | preciosCursosCreateWithoutEdicionInput[] | preciosCursosUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: preciosCursosCreateOrConnectWithoutEdicionInput | preciosCursosCreateOrConnectWithoutEdicionInput[]
    createMany?: preciosCursosCreateManyEdicionInputEnvelope
    connect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
  }

  export type comprasUncheckedCreateNestedManyWithoutEdicionInput = {
    create?: XOR<comprasCreateWithoutEdicionInput, comprasUncheckedCreateWithoutEdicionInput> | comprasCreateWithoutEdicionInput[] | comprasUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutEdicionInput | comprasCreateOrConnectWithoutEdicionInput[]
    createMany?: comprasCreateManyEdicionInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type certificadosUncheckedCreateNestedManyWithoutEdicionInput = {
    create?: XOR<certificadosCreateWithoutEdicionInput, certificadosUncheckedCreateWithoutEdicionInput> | certificadosCreateWithoutEdicionInput[] | certificadosUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEdicionInput | certificadosCreateOrConnectWithoutEdicionInput[]
    createMany?: certificadosCreateManyEdicionInputEnvelope
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
  }

  export type clasesUncheckedCreateNestedManyWithoutEdicionInput = {
    create?: XOR<clasesCreateWithoutEdicionInput, clasesUncheckedCreateWithoutEdicionInput> | clasesCreateWithoutEdicionInput[] | clasesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: clasesCreateOrConnectWithoutEdicionInput | clasesCreateOrConnectWithoutEdicionInput[]
    createMany?: clasesCreateManyEdicionInputEnvelope
    connect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
  }

  export type examenesUncheckedCreateNestedManyWithoutEdicionInput = {
    create?: XOR<examenesCreateWithoutEdicionInput, examenesUncheckedCreateWithoutEdicionInput> | examenesCreateWithoutEdicionInput[] | examenesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: examenesCreateOrConnectWithoutEdicionInput | examenesCreateOrConnectWithoutEdicionInput[]
    createMany?: examenesCreateManyEdicionInputEnvelope
    connect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
  }

  export type inscripcionesUncheckedCreateNestedManyWithoutEdicionInput = {
    create?: XOR<inscripcionesCreateWithoutEdicionInput, inscripcionesUncheckedCreateWithoutEdicionInput> | inscripcionesCreateWithoutEdicionInput[] | inscripcionesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEdicionInput | inscripcionesCreateOrConnectWithoutEdicionInput[]
    createMany?: inscripcionesCreateManyEdicionInputEnvelope
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
  }

  export type preciosCursosUncheckedCreateNestedManyWithoutEdicionInput = {
    create?: XOR<preciosCursosCreateWithoutEdicionInput, preciosCursosUncheckedCreateWithoutEdicionInput> | preciosCursosCreateWithoutEdicionInput[] | preciosCursosUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: preciosCursosCreateOrConnectWithoutEdicionInput | preciosCursosCreateOrConnectWithoutEdicionInput[]
    createMany?: preciosCursosCreateManyEdicionInputEnvelope
    connect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
  }

  export type EnumEdicionEstadoFieldUpdateOperationsInput = {
    set?: $Enums.EdicionEstado
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type docenteUpdateOneRequiredWithoutEdicionesNestedInput = {
    create?: XOR<docenteCreateWithoutEdicionesInput, docenteUncheckedCreateWithoutEdicionesInput>
    connectOrCreate?: docenteCreateOrConnectWithoutEdicionesInput
    upsert?: docenteUpsertWithoutEdicionesInput
    connect?: docenteWhereUniqueInput
    update?: XOR<XOR<docenteUpdateToOneWithWhereWithoutEdicionesInput, docenteUpdateWithoutEdicionesInput>, docenteUncheckedUpdateWithoutEdicionesInput>
  }

  export type cursosUpdateOneRequiredWithoutEdicionesNestedInput = {
    create?: XOR<cursosCreateWithoutEdicionesInput, cursosUncheckedCreateWithoutEdicionesInput>
    connectOrCreate?: cursosCreateOrConnectWithoutEdicionesInput
    upsert?: cursosUpsertWithoutEdicionesInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutEdicionesInput, cursosUpdateWithoutEdicionesInput>, cursosUncheckedUpdateWithoutEdicionesInput>
  }

  export type comprasUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<comprasCreateWithoutEdicionInput, comprasUncheckedCreateWithoutEdicionInput> | comprasCreateWithoutEdicionInput[] | comprasUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutEdicionInput | comprasCreateOrConnectWithoutEdicionInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutEdicionInput | comprasUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: comprasCreateManyEdicionInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutEdicionInput | comprasUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutEdicionInput | comprasUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type certificadosUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<certificadosCreateWithoutEdicionInput, certificadosUncheckedCreateWithoutEdicionInput> | certificadosCreateWithoutEdicionInput[] | certificadosUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEdicionInput | certificadosCreateOrConnectWithoutEdicionInput[]
    upsert?: certificadosUpsertWithWhereUniqueWithoutEdicionInput | certificadosUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: certificadosCreateManyEdicionInputEnvelope
    set?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    disconnect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    delete?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    update?: certificadosUpdateWithWhereUniqueWithoutEdicionInput | certificadosUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: certificadosUpdateManyWithWhereWithoutEdicionInput | certificadosUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
  }

  export type clasesUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<clasesCreateWithoutEdicionInput, clasesUncheckedCreateWithoutEdicionInput> | clasesCreateWithoutEdicionInput[] | clasesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: clasesCreateOrConnectWithoutEdicionInput | clasesCreateOrConnectWithoutEdicionInput[]
    upsert?: clasesUpsertWithWhereUniqueWithoutEdicionInput | clasesUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: clasesCreateManyEdicionInputEnvelope
    set?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    disconnect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    delete?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    connect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    update?: clasesUpdateWithWhereUniqueWithoutEdicionInput | clasesUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: clasesUpdateManyWithWhereWithoutEdicionInput | clasesUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: clasesScalarWhereInput | clasesScalarWhereInput[]
  }

  export type examenesUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<examenesCreateWithoutEdicionInput, examenesUncheckedCreateWithoutEdicionInput> | examenesCreateWithoutEdicionInput[] | examenesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: examenesCreateOrConnectWithoutEdicionInput | examenesCreateOrConnectWithoutEdicionInput[]
    upsert?: examenesUpsertWithWhereUniqueWithoutEdicionInput | examenesUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: examenesCreateManyEdicionInputEnvelope
    set?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    disconnect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    delete?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    connect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    update?: examenesUpdateWithWhereUniqueWithoutEdicionInput | examenesUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: examenesUpdateManyWithWhereWithoutEdicionInput | examenesUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: examenesScalarWhereInput | examenesScalarWhereInput[]
  }

  export type inscripcionesUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<inscripcionesCreateWithoutEdicionInput, inscripcionesUncheckedCreateWithoutEdicionInput> | inscripcionesCreateWithoutEdicionInput[] | inscripcionesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEdicionInput | inscripcionesCreateOrConnectWithoutEdicionInput[]
    upsert?: inscripcionesUpsertWithWhereUniqueWithoutEdicionInput | inscripcionesUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: inscripcionesCreateManyEdicionInputEnvelope
    set?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    disconnect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    delete?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    update?: inscripcionesUpdateWithWhereUniqueWithoutEdicionInput | inscripcionesUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: inscripcionesUpdateManyWithWhereWithoutEdicionInput | inscripcionesUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
  }

  export type preciosCursosUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<preciosCursosCreateWithoutEdicionInput, preciosCursosUncheckedCreateWithoutEdicionInput> | preciosCursosCreateWithoutEdicionInput[] | preciosCursosUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: preciosCursosCreateOrConnectWithoutEdicionInput | preciosCursosCreateOrConnectWithoutEdicionInput[]
    upsert?: preciosCursosUpsertWithWhereUniqueWithoutEdicionInput | preciosCursosUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: preciosCursosCreateManyEdicionInputEnvelope
    set?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    disconnect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    delete?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    connect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    update?: preciosCursosUpdateWithWhereUniqueWithoutEdicionInput | preciosCursosUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: preciosCursosUpdateManyWithWhereWithoutEdicionInput | preciosCursosUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: preciosCursosScalarWhereInput | preciosCursosScalarWhereInput[]
  }

  export type comprasUncheckedUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<comprasCreateWithoutEdicionInput, comprasUncheckedCreateWithoutEdicionInput> | comprasCreateWithoutEdicionInput[] | comprasUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutEdicionInput | comprasCreateOrConnectWithoutEdicionInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutEdicionInput | comprasUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: comprasCreateManyEdicionInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutEdicionInput | comprasUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutEdicionInput | comprasUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type certificadosUncheckedUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<certificadosCreateWithoutEdicionInput, certificadosUncheckedCreateWithoutEdicionInput> | certificadosCreateWithoutEdicionInput[] | certificadosUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEdicionInput | certificadosCreateOrConnectWithoutEdicionInput[]
    upsert?: certificadosUpsertWithWhereUniqueWithoutEdicionInput | certificadosUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: certificadosCreateManyEdicionInputEnvelope
    set?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    disconnect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    delete?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    update?: certificadosUpdateWithWhereUniqueWithoutEdicionInput | certificadosUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: certificadosUpdateManyWithWhereWithoutEdicionInput | certificadosUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
  }

  export type clasesUncheckedUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<clasesCreateWithoutEdicionInput, clasesUncheckedCreateWithoutEdicionInput> | clasesCreateWithoutEdicionInput[] | clasesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: clasesCreateOrConnectWithoutEdicionInput | clasesCreateOrConnectWithoutEdicionInput[]
    upsert?: clasesUpsertWithWhereUniqueWithoutEdicionInput | clasesUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: clasesCreateManyEdicionInputEnvelope
    set?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    disconnect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    delete?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    connect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    update?: clasesUpdateWithWhereUniqueWithoutEdicionInput | clasesUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: clasesUpdateManyWithWhereWithoutEdicionInput | clasesUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: clasesScalarWhereInput | clasesScalarWhereInput[]
  }

  export type examenesUncheckedUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<examenesCreateWithoutEdicionInput, examenesUncheckedCreateWithoutEdicionInput> | examenesCreateWithoutEdicionInput[] | examenesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: examenesCreateOrConnectWithoutEdicionInput | examenesCreateOrConnectWithoutEdicionInput[]
    upsert?: examenesUpsertWithWhereUniqueWithoutEdicionInput | examenesUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: examenesCreateManyEdicionInputEnvelope
    set?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    disconnect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    delete?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    connect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    update?: examenesUpdateWithWhereUniqueWithoutEdicionInput | examenesUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: examenesUpdateManyWithWhereWithoutEdicionInput | examenesUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: examenesScalarWhereInput | examenesScalarWhereInput[]
  }

  export type inscripcionesUncheckedUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<inscripcionesCreateWithoutEdicionInput, inscripcionesUncheckedCreateWithoutEdicionInput> | inscripcionesCreateWithoutEdicionInput[] | inscripcionesUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEdicionInput | inscripcionesCreateOrConnectWithoutEdicionInput[]
    upsert?: inscripcionesUpsertWithWhereUniqueWithoutEdicionInput | inscripcionesUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: inscripcionesCreateManyEdicionInputEnvelope
    set?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    disconnect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    delete?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    update?: inscripcionesUpdateWithWhereUniqueWithoutEdicionInput | inscripcionesUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: inscripcionesUpdateManyWithWhereWithoutEdicionInput | inscripcionesUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
  }

  export type preciosCursosUncheckedUpdateManyWithoutEdicionNestedInput = {
    create?: XOR<preciosCursosCreateWithoutEdicionInput, preciosCursosUncheckedCreateWithoutEdicionInput> | preciosCursosCreateWithoutEdicionInput[] | preciosCursosUncheckedCreateWithoutEdicionInput[]
    connectOrCreate?: preciosCursosCreateOrConnectWithoutEdicionInput | preciosCursosCreateOrConnectWithoutEdicionInput[]
    upsert?: preciosCursosUpsertWithWhereUniqueWithoutEdicionInput | preciosCursosUpsertWithWhereUniqueWithoutEdicionInput[]
    createMany?: preciosCursosCreateManyEdicionInputEnvelope
    set?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    disconnect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    delete?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    connect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    update?: preciosCursosUpdateWithWhereUniqueWithoutEdicionInput | preciosCursosUpdateWithWhereUniqueWithoutEdicionInput[]
    updateMany?: preciosCursosUpdateManyWithWhereWithoutEdicionInput | preciosCursosUpdateManyWithWhereWithoutEdicionInput[]
    deleteMany?: preciosCursosScalarWhereInput | preciosCursosScalarWhereInput[]
  }

  export type cursosCreateNestedOneWithoutBeneficiosInput = {
    create?: XOR<cursosCreateWithoutBeneficiosInput, cursosUncheckedCreateWithoutBeneficiosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutBeneficiosInput
    connect?: cursosWhereUniqueInput
  }

  export type cursosUpdateOneRequiredWithoutBeneficiosNestedInput = {
    create?: XOR<cursosCreateWithoutBeneficiosInput, cursosUncheckedCreateWithoutBeneficiosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutBeneficiosInput
    upsert?: cursosUpsertWithoutBeneficiosInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutBeneficiosInput, cursosUpdateWithoutBeneficiosInput>, cursosUncheckedUpdateWithoutBeneficiosInput>
  }

  export type cursosCreateNestedOneWithoutObjetivosInput = {
    create?: XOR<cursosCreateWithoutObjetivosInput, cursosUncheckedCreateWithoutObjetivosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutObjetivosInput
    connect?: cursosWhereUniqueInput
  }

  export type cursosUpdateOneRequiredWithoutObjetivosNestedInput = {
    create?: XOR<cursosCreateWithoutObjetivosInput, cursosUncheckedCreateWithoutObjetivosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutObjetivosInput
    upsert?: cursosUpsertWithoutObjetivosInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutObjetivosInput, cursosUpdateWithoutObjetivosInput>, cursosUncheckedUpdateWithoutObjetivosInput>
  }

  export type cursosCreateNestedOneWithoutRequisitosInput = {
    create?: XOR<cursosCreateWithoutRequisitosInput, cursosUncheckedCreateWithoutRequisitosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutRequisitosInput
    connect?: cursosWhereUniqueInput
  }

  export type cursosUpdateOneRequiredWithoutRequisitosNestedInput = {
    create?: XOR<cursosCreateWithoutRequisitosInput, cursosUncheckedCreateWithoutRequisitosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutRequisitosInput
    upsert?: cursosUpsertWithoutRequisitosInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutRequisitosInput, cursosUpdateWithoutRequisitosInput>, cursosUncheckedUpdateWithoutRequisitosInput>
  }

  export type edicionesCursosCreateNestedOneWithoutClasesInput = {
    create?: XOR<edicionesCursosCreateWithoutClasesInput, edicionesCursosUncheckedCreateWithoutClasesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutClasesInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type materialesCreateNestedManyWithoutClaseInput = {
    create?: XOR<materialesCreateWithoutClaseInput, materialesUncheckedCreateWithoutClaseInput> | materialesCreateWithoutClaseInput[] | materialesUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutClaseInput | materialesCreateOrConnectWithoutClaseInput[]
    createMany?: materialesCreateManyClaseInputEnvelope
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
  }

  export type grabacionesCreateNestedManyWithoutClaseInput = {
    create?: XOR<grabacionesCreateWithoutClaseInput, grabacionesUncheckedCreateWithoutClaseInput> | grabacionesCreateWithoutClaseInput[] | grabacionesUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutClaseInput | grabacionesCreateOrConnectWithoutClaseInput[]
    createMany?: grabacionesCreateManyClaseInputEnvelope
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
  }

  export type materialesUncheckedCreateNestedManyWithoutClaseInput = {
    create?: XOR<materialesCreateWithoutClaseInput, materialesUncheckedCreateWithoutClaseInput> | materialesCreateWithoutClaseInput[] | materialesUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutClaseInput | materialesCreateOrConnectWithoutClaseInput[]
    createMany?: materialesCreateManyClaseInputEnvelope
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
  }

  export type grabacionesUncheckedCreateNestedManyWithoutClaseInput = {
    create?: XOR<grabacionesCreateWithoutClaseInput, grabacionesUncheckedCreateWithoutClaseInput> | grabacionesCreateWithoutClaseInput[] | grabacionesUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutClaseInput | grabacionesCreateOrConnectWithoutClaseInput[]
    createMany?: grabacionesCreateManyClaseInputEnvelope
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type edicionesCursosUpdateOneRequiredWithoutClasesNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutClasesInput, edicionesCursosUncheckedCreateWithoutClasesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutClasesInput
    upsert?: edicionesCursosUpsertWithoutClasesInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutClasesInput, edicionesCursosUpdateWithoutClasesInput>, edicionesCursosUncheckedUpdateWithoutClasesInput>
  }

  export type materialesUpdateManyWithoutClaseNestedInput = {
    create?: XOR<materialesCreateWithoutClaseInput, materialesUncheckedCreateWithoutClaseInput> | materialesCreateWithoutClaseInput[] | materialesUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutClaseInput | materialesCreateOrConnectWithoutClaseInput[]
    upsert?: materialesUpsertWithWhereUniqueWithoutClaseInput | materialesUpsertWithWhereUniqueWithoutClaseInput[]
    createMany?: materialesCreateManyClaseInputEnvelope
    set?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    disconnect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    delete?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    update?: materialesUpdateWithWhereUniqueWithoutClaseInput | materialesUpdateWithWhereUniqueWithoutClaseInput[]
    updateMany?: materialesUpdateManyWithWhereWithoutClaseInput | materialesUpdateManyWithWhereWithoutClaseInput[]
    deleteMany?: materialesScalarWhereInput | materialesScalarWhereInput[]
  }

  export type grabacionesUpdateManyWithoutClaseNestedInput = {
    create?: XOR<grabacionesCreateWithoutClaseInput, grabacionesUncheckedCreateWithoutClaseInput> | grabacionesCreateWithoutClaseInput[] | grabacionesUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutClaseInput | grabacionesCreateOrConnectWithoutClaseInput[]
    upsert?: grabacionesUpsertWithWhereUniqueWithoutClaseInput | grabacionesUpsertWithWhereUniqueWithoutClaseInput[]
    createMany?: grabacionesCreateManyClaseInputEnvelope
    set?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    disconnect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    delete?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    update?: grabacionesUpdateWithWhereUniqueWithoutClaseInput | grabacionesUpdateWithWhereUniqueWithoutClaseInput[]
    updateMany?: grabacionesUpdateManyWithWhereWithoutClaseInput | grabacionesUpdateManyWithWhereWithoutClaseInput[]
    deleteMany?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
  }

  export type materialesUncheckedUpdateManyWithoutClaseNestedInput = {
    create?: XOR<materialesCreateWithoutClaseInput, materialesUncheckedCreateWithoutClaseInput> | materialesCreateWithoutClaseInput[] | materialesUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutClaseInput | materialesCreateOrConnectWithoutClaseInput[]
    upsert?: materialesUpsertWithWhereUniqueWithoutClaseInput | materialesUpsertWithWhereUniqueWithoutClaseInput[]
    createMany?: materialesCreateManyClaseInputEnvelope
    set?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    disconnect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    delete?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    update?: materialesUpdateWithWhereUniqueWithoutClaseInput | materialesUpdateWithWhereUniqueWithoutClaseInput[]
    updateMany?: materialesUpdateManyWithWhereWithoutClaseInput | materialesUpdateManyWithWhereWithoutClaseInput[]
    deleteMany?: materialesScalarWhereInput | materialesScalarWhereInput[]
  }

  export type grabacionesUncheckedUpdateManyWithoutClaseNestedInput = {
    create?: XOR<grabacionesCreateWithoutClaseInput, grabacionesUncheckedCreateWithoutClaseInput> | grabacionesCreateWithoutClaseInput[] | grabacionesUncheckedCreateWithoutClaseInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutClaseInput | grabacionesCreateOrConnectWithoutClaseInput[]
    upsert?: grabacionesUpsertWithWhereUniqueWithoutClaseInput | grabacionesUpsertWithWhereUniqueWithoutClaseInput[]
    createMany?: grabacionesCreateManyClaseInputEnvelope
    set?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    disconnect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    delete?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    update?: grabacionesUpdateWithWhereUniqueWithoutClaseInput | grabacionesUpdateWithWhereUniqueWithoutClaseInput[]
    updateMany?: grabacionesUpdateManyWithWhereWithoutClaseInput | grabacionesUpdateManyWithWhereWithoutClaseInput[]
    deleteMany?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
  }

  export type clasesCreateNestedOneWithoutMaterialesInput = {
    create?: XOR<clasesCreateWithoutMaterialesInput, clasesUncheckedCreateWithoutMaterialesInput>
    connectOrCreate?: clasesCreateOrConnectWithoutMaterialesInput
    connect?: clasesWhereUniqueInput
  }

  export type clasesUpdateOneRequiredWithoutMaterialesNestedInput = {
    create?: XOR<clasesCreateWithoutMaterialesInput, clasesUncheckedCreateWithoutMaterialesInput>
    connectOrCreate?: clasesCreateOrConnectWithoutMaterialesInput
    upsert?: clasesUpsertWithoutMaterialesInput
    connect?: clasesWhereUniqueInput
    update?: XOR<XOR<clasesUpdateToOneWithWhereWithoutMaterialesInput, clasesUpdateWithoutMaterialesInput>, clasesUncheckedUpdateWithoutMaterialesInput>
  }

  export type edicionesCursosCreateNestedOneWithoutExamenesInput = {
    create?: XOR<edicionesCursosCreateWithoutExamenesInput, edicionesCursosUncheckedCreateWithoutExamenesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutExamenesInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type calificacionesCreateNestedManyWithoutExamenInput = {
    create?: XOR<calificacionesCreateWithoutExamenInput, calificacionesUncheckedCreateWithoutExamenInput> | calificacionesCreateWithoutExamenInput[] | calificacionesUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutExamenInput | calificacionesCreateOrConnectWithoutExamenInput[]
    createMany?: calificacionesCreateManyExamenInputEnvelope
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
  }

  export type calificacionesUncheckedCreateNestedManyWithoutExamenInput = {
    create?: XOR<calificacionesCreateWithoutExamenInput, calificacionesUncheckedCreateWithoutExamenInput> | calificacionesCreateWithoutExamenInput[] | calificacionesUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutExamenInput | calificacionesCreateOrConnectWithoutExamenInput[]
    createMany?: calificacionesCreateManyExamenInputEnvelope
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
  }

  export type edicionesCursosUpdateOneRequiredWithoutExamenesNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutExamenesInput, edicionesCursosUncheckedCreateWithoutExamenesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutExamenesInput
    upsert?: edicionesCursosUpsertWithoutExamenesInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutExamenesInput, edicionesCursosUpdateWithoutExamenesInput>, edicionesCursosUncheckedUpdateWithoutExamenesInput>
  }

  export type calificacionesUpdateManyWithoutExamenNestedInput = {
    create?: XOR<calificacionesCreateWithoutExamenInput, calificacionesUncheckedCreateWithoutExamenInput> | calificacionesCreateWithoutExamenInput[] | calificacionesUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutExamenInput | calificacionesCreateOrConnectWithoutExamenInput[]
    upsert?: calificacionesUpsertWithWhereUniqueWithoutExamenInput | calificacionesUpsertWithWhereUniqueWithoutExamenInput[]
    createMany?: calificacionesCreateManyExamenInputEnvelope
    set?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    disconnect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    delete?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    update?: calificacionesUpdateWithWhereUniqueWithoutExamenInput | calificacionesUpdateWithWhereUniqueWithoutExamenInput[]
    updateMany?: calificacionesUpdateManyWithWhereWithoutExamenInput | calificacionesUpdateManyWithWhereWithoutExamenInput[]
    deleteMany?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
  }

  export type calificacionesUncheckedUpdateManyWithoutExamenNestedInput = {
    create?: XOR<calificacionesCreateWithoutExamenInput, calificacionesUncheckedCreateWithoutExamenInput> | calificacionesCreateWithoutExamenInput[] | calificacionesUncheckedCreateWithoutExamenInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutExamenInput | calificacionesCreateOrConnectWithoutExamenInput[]
    upsert?: calificacionesUpsertWithWhereUniqueWithoutExamenInput | calificacionesUpsertWithWhereUniqueWithoutExamenInput[]
    createMany?: calificacionesCreateManyExamenInputEnvelope
    set?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    disconnect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    delete?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    update?: calificacionesUpdateWithWhereUniqueWithoutExamenInput | calificacionesUpdateWithWhereUniqueWithoutExamenInput[]
    updateMany?: calificacionesUpdateManyWithWhereWithoutExamenInput | calificacionesUpdateManyWithWhereWithoutExamenInput[]
    deleteMany?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
  }

  export type estudiantesCreateNestedOneWithoutCalificacionesInput = {
    create?: XOR<estudiantesCreateWithoutCalificacionesInput, estudiantesUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutCalificacionesInput
    connect?: estudiantesWhereUniqueInput
  }

  export type examenesCreateNestedOneWithoutCalificacionesInput = {
    create?: XOR<examenesCreateWithoutCalificacionesInput, examenesUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: examenesCreateOrConnectWithoutCalificacionesInput
    connect?: examenesWhereUniqueInput
  }

  export type estudiantesUpdateOneRequiredWithoutCalificacionesNestedInput = {
    create?: XOR<estudiantesCreateWithoutCalificacionesInput, estudiantesUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutCalificacionesInput
    upsert?: estudiantesUpsertWithoutCalificacionesInput
    connect?: estudiantesWhereUniqueInput
    update?: XOR<XOR<estudiantesUpdateToOneWithWhereWithoutCalificacionesInput, estudiantesUpdateWithoutCalificacionesInput>, estudiantesUncheckedUpdateWithoutCalificacionesInput>
  }

  export type examenesUpdateOneRequiredWithoutCalificacionesNestedInput = {
    create?: XOR<examenesCreateWithoutCalificacionesInput, examenesUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: examenesCreateOrConnectWithoutCalificacionesInput
    upsert?: examenesUpsertWithoutCalificacionesInput
    connect?: examenesWhereUniqueInput
    update?: XOR<XOR<examenesUpdateToOneWithWhereWithoutCalificacionesInput, examenesUpdateWithoutCalificacionesInput>, examenesUncheckedUpdateWithoutCalificacionesInput>
  }

  export type edicionesCursosCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<edicionesCursosCreateWithoutInscripcionesInput, edicionesCursosUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutInscripcionesInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type estudiantesCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutInscripcionesInput
    connect?: estudiantesWhereUniqueInput
  }

  export type comprasCreateNestedOneWithoutInscripcionInput = {
    create?: XOR<comprasCreateWithoutInscripcionInput, comprasUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: comprasCreateOrConnectWithoutInscripcionInput
    connect?: comprasWhereUniqueInput
  }

  export type edicionesCursosUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutInscripcionesInput, edicionesCursosUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutInscripcionesInput
    upsert?: edicionesCursosUpsertWithoutInscripcionesInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutInscripcionesInput, edicionesCursosUpdateWithoutInscripcionesInput>, edicionesCursosUncheckedUpdateWithoutInscripcionesInput>
  }

  export type estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutInscripcionesInput
    upsert?: estudiantesUpsertWithoutInscripcionesInput
    connect?: estudiantesWhereUniqueInput
    update?: XOR<XOR<estudiantesUpdateToOneWithWhereWithoutInscripcionesInput, estudiantesUpdateWithoutInscripcionesInput>, estudiantesUncheckedUpdateWithoutInscripcionesInput>
  }

  export type comprasUpdateOneWithoutInscripcionNestedInput = {
    create?: XOR<comprasCreateWithoutInscripcionInput, comprasUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: comprasCreateOrConnectWithoutInscripcionInput
    upsert?: comprasUpsertWithoutInscripcionInput
    disconnect?: comprasWhereInput | boolean
    delete?: comprasWhereInput | boolean
    connect?: comprasWhereUniqueInput
    update?: XOR<XOR<comprasUpdateToOneWithWhereWithoutInscripcionInput, comprasUpdateWithoutInscripcionInput>, comprasUncheckedUpdateWithoutInscripcionInput>
  }

  export type edicionesCursosCreateNestedOneWithoutCertificadosInput = {
    create?: XOR<edicionesCursosCreateWithoutCertificadosInput, edicionesCursosUncheckedCreateWithoutCertificadosInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCertificadosInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type estudiantesCreateNestedOneWithoutCertificadosInput = {
    create?: XOR<estudiantesCreateWithoutCertificadosInput, estudiantesUncheckedCreateWithoutCertificadosInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutCertificadosInput
    connect?: estudiantesWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type edicionesCursosUpdateOneRequiredWithoutCertificadosNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutCertificadosInput, edicionesCursosUncheckedCreateWithoutCertificadosInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCertificadosInput
    upsert?: edicionesCursosUpsertWithoutCertificadosInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutCertificadosInput, edicionesCursosUpdateWithoutCertificadosInput>, edicionesCursosUncheckedUpdateWithoutCertificadosInput>
  }

  export type estudiantesUpdateOneRequiredWithoutCertificadosNestedInput = {
    create?: XOR<estudiantesCreateWithoutCertificadosInput, estudiantesUncheckedCreateWithoutCertificadosInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutCertificadosInput
    upsert?: estudiantesUpsertWithoutCertificadosInput
    connect?: estudiantesWhereUniqueInput
    update?: XOR<XOR<estudiantesUpdateToOneWithWhereWithoutCertificadosInput, estudiantesUpdateWithoutCertificadosInput>, estudiantesUncheckedUpdateWithoutCertificadosInput>
  }

  export type edicionesCursosCreateNestedOneWithoutPreciosInput = {
    create?: XOR<edicionesCursosCreateWithoutPreciosInput, edicionesCursosUncheckedCreateWithoutPreciosInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutPreciosInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type edicionesCursosUpdateOneRequiredWithoutPreciosNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutPreciosInput, edicionesCursosUncheckedCreateWithoutPreciosInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutPreciosInput
    upsert?: edicionesCursosUpsertWithoutPreciosInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutPreciosInput, edicionesCursosUpdateWithoutPreciosInput>, edicionesCursosUncheckedUpdateWithoutPreciosInput>
  }

  export type edicionesCursosCreateNestedOneWithoutComprasInput = {
    create?: XOR<edicionesCursosCreateWithoutComprasInput, edicionesCursosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutComprasInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type inscripcionesCreateNestedOneWithoutCompraInput = {
    create?: XOR<inscripcionesCreateWithoutCompraInput, inscripcionesUncheckedCreateWithoutCompraInput>
    connectOrCreate?: inscripcionesCreateOrConnectWithoutCompraInput
    connect?: inscripcionesWhereUniqueInput
  }

  export type usuariosEstudiantesCreateNestedOneWithoutComprasInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutComprasInput, usuariosEstudiantesUncheckedCreateWithoutComprasInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutComprasInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type inscripcionesUncheckedCreateNestedOneWithoutCompraInput = {
    create?: XOR<inscripcionesCreateWithoutCompraInput, inscripcionesUncheckedCreateWithoutCompraInput>
    connectOrCreate?: inscripcionesCreateOrConnectWithoutCompraInput
    connect?: inscripcionesWhereUniqueInput
  }

  export type edicionesCursosUpdateOneRequiredWithoutComprasNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutComprasInput, edicionesCursosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutComprasInput
    upsert?: edicionesCursosUpsertWithoutComprasInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutComprasInput, edicionesCursosUpdateWithoutComprasInput>, edicionesCursosUncheckedUpdateWithoutComprasInput>
  }

  export type inscripcionesUpdateOneWithoutCompraNestedInput = {
    create?: XOR<inscripcionesCreateWithoutCompraInput, inscripcionesUncheckedCreateWithoutCompraInput>
    connectOrCreate?: inscripcionesCreateOrConnectWithoutCompraInput
    upsert?: inscripcionesUpsertWithoutCompraInput
    disconnect?: inscripcionesWhereInput | boolean
    delete?: inscripcionesWhereInput | boolean
    connect?: inscripcionesWhereUniqueInput
    update?: XOR<XOR<inscripcionesUpdateToOneWithWhereWithoutCompraInput, inscripcionesUpdateWithoutCompraInput>, inscripcionesUncheckedUpdateWithoutCompraInput>
  }

  export type usuariosEstudiantesUpdateOneWithoutComprasNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutComprasInput, usuariosEstudiantesUncheckedCreateWithoutComprasInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutComprasInput
    upsert?: usuariosEstudiantesUpsertWithoutComprasInput
    disconnect?: usuariosEstudiantesWhereInput | boolean
    delete?: usuariosEstudiantesWhereInput | boolean
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutComprasInput, usuariosEstudiantesUpdateWithoutComprasInput>, usuariosEstudiantesUncheckedUpdateWithoutComprasInput>
  }

  export type inscripcionesUncheckedUpdateOneWithoutCompraNestedInput = {
    create?: XOR<inscripcionesCreateWithoutCompraInput, inscripcionesUncheckedCreateWithoutCompraInput>
    connectOrCreate?: inscripcionesCreateOrConnectWithoutCompraInput
    upsert?: inscripcionesUpsertWithoutCompraInput
    disconnect?: inscripcionesWhereInput | boolean
    delete?: inscripcionesWhereInput | boolean
    connect?: inscripcionesWhereUniqueInput
    update?: XOR<XOR<inscripcionesUpdateToOneWithWhereWithoutCompraInput, inscripcionesUpdateWithoutCompraInput>, inscripcionesUncheckedUpdateWithoutCompraInput>
  }

  export type clasesCreateNestedOneWithoutGrabacionesInput = {
    create?: XOR<clasesCreateWithoutGrabacionesInput, clasesUncheckedCreateWithoutGrabacionesInput>
    connectOrCreate?: clasesCreateOrConnectWithoutGrabacionesInput
    connect?: clasesWhereUniqueInput
  }

  export type usuariosAdministradoresCreateNestedOneWithoutGrabacionesInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutGrabacionesInput, usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutGrabacionesInput
    connect?: usuariosAdministradoresWhereUniqueInput
  }

  export type clasesUpdateOneRequiredWithoutGrabacionesNestedInput = {
    create?: XOR<clasesCreateWithoutGrabacionesInput, clasesUncheckedCreateWithoutGrabacionesInput>
    connectOrCreate?: clasesCreateOrConnectWithoutGrabacionesInput
    upsert?: clasesUpsertWithoutGrabacionesInput
    connect?: clasesWhereUniqueInput
    update?: XOR<XOR<clasesUpdateToOneWithWhereWithoutGrabacionesInput, clasesUpdateWithoutGrabacionesInput>, clasesUncheckedUpdateWithoutGrabacionesInput>
  }

  export type usuariosAdministradoresUpdateOneRequiredWithoutGrabacionesNestedInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutGrabacionesInput, usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutGrabacionesInput
    upsert?: usuariosAdministradoresUpsertWithoutGrabacionesInput
    connect?: usuariosAdministradoresWhereUniqueInput
    update?: XOR<XOR<usuariosAdministradoresUpdateToOneWithWhereWithoutGrabacionesInput, usuariosAdministradoresUpdateWithoutGrabacionesInput>, usuariosAdministradoresUncheckedUpdateWithoutGrabacionesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAccionAuditoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaFilter<$PrismaModel> | $Enums.AccionAuditoria
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAccionAuditoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaWithAggregatesFilter<$PrismaModel> | $Enums.AccionAuditoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
    _max?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTipoGeneroNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGenero | EnumTipoGeneroFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoGeneroNullableFilter<$PrismaModel> | $Enums.TipoGenero | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumTipoGeneroNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGenero | EnumTipoGeneroFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoGeneroNullableWithAggregatesFilter<$PrismaModel> | $Enums.TipoGenero | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTipoGeneroNullableFilter<$PrismaModel>
    _max?: NestedEnumTipoGeneroNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoCuentaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCuenta | EnumTipoCuentaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCuentaFilter<$PrismaModel> | $Enums.TipoCuenta
  }

  export type NestedEnumTipoCuentaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCuenta | EnumTipoCuentaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCuentaWithAggregatesFilter<$PrismaModel> | $Enums.TipoCuenta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoCuentaFilter<$PrismaModel>
    _max?: NestedEnumTipoCuentaFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumEdicionEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.EdicionEstado | EnumEdicionEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEdicionEstadoFilter<$PrismaModel> | $Enums.EdicionEstado
  }

  export type NestedEnumEdicionEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EdicionEstado | EnumEdicionEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEdicionEstadoWithAggregatesFilter<$PrismaModel> | $Enums.EdicionEstado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEdicionEstadoFilter<$PrismaModel>
    _max?: NestedEnumEdicionEstadoFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type usuariosAdministradoresCreateWithoutAuditoriasInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    tipo: $Enums.TipoCuenta
    docente?: docenteCreateNestedOneWithoutUsuarioInput
    grabaciones?: grabacionesCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosAdministradoresUncheckedCreateWithoutAuditoriasInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    tipo: $Enums.TipoCuenta
    docente?: docenteUncheckedCreateNestedOneWithoutUsuarioInput
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosAdministradoresCreateOrConnectWithoutAuditoriasInput = {
    where: usuariosAdministradoresWhereUniqueInput
    create: XOR<usuariosAdministradoresCreateWithoutAuditoriasInput, usuariosAdministradoresUncheckedCreateWithoutAuditoriasInput>
  }

  export type usuariosAdministradoresUpsertWithoutAuditoriasInput = {
    update: XOR<usuariosAdministradoresUpdateWithoutAuditoriasInput, usuariosAdministradoresUncheckedUpdateWithoutAuditoriasInput>
    create: XOR<usuariosAdministradoresCreateWithoutAuditoriasInput, usuariosAdministradoresUncheckedCreateWithoutAuditoriasInput>
    where?: usuariosAdministradoresWhereInput
  }

  export type usuariosAdministradoresUpdateToOneWithWhereWithoutAuditoriasInput = {
    where?: usuariosAdministradoresWhereInput
    data: XOR<usuariosAdministradoresUpdateWithoutAuditoriasInput, usuariosAdministradoresUncheckedUpdateWithoutAuditoriasInput>
  }

  export type usuariosAdministradoresUpdateWithoutAuditoriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    docente?: docenteUpdateOneWithoutUsuarioNestedInput
    grabaciones?: grabacionesUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosAdministradoresUncheckedUpdateWithoutAuditoriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    docente?: docenteUncheckedUpdateOneWithoutUsuarioNestedInput
    grabaciones?: grabacionesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type categoriasCursosCreateWithoutCategoriaInput = {
    id?: string
    curso: cursosCreateNestedOneWithoutCategoriasInput
  }

  export type categoriasCursosUncheckedCreateWithoutCategoriaInput = {
    id?: string
    cursoId: string
  }

  export type categoriasCursosCreateOrConnectWithoutCategoriaInput = {
    where: categoriasCursosWhereUniqueInput
    create: XOR<categoriasCursosCreateWithoutCategoriaInput, categoriasCursosUncheckedCreateWithoutCategoriaInput>
  }

  export type categoriasCursosCreateManyCategoriaInputEnvelope = {
    data: categoriasCursosCreateManyCategoriaInput | categoriasCursosCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type categoriasCursosUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: categoriasCursosWhereUniqueInput
    update: XOR<categoriasCursosUpdateWithoutCategoriaInput, categoriasCursosUncheckedUpdateWithoutCategoriaInput>
    create: XOR<categoriasCursosCreateWithoutCategoriaInput, categoriasCursosUncheckedCreateWithoutCategoriaInput>
  }

  export type categoriasCursosUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: categoriasCursosWhereUniqueInput
    data: XOR<categoriasCursosUpdateWithoutCategoriaInput, categoriasCursosUncheckedUpdateWithoutCategoriaInput>
  }

  export type categoriasCursosUpdateManyWithWhereWithoutCategoriaInput = {
    where: categoriasCursosScalarWhereInput
    data: XOR<categoriasCursosUpdateManyMutationInput, categoriasCursosUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type categoriasCursosScalarWhereInput = {
    AND?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
    OR?: categoriasCursosScalarWhereInput[]
    NOT?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
    id?: StringFilter<"categoriasCursos"> | string
    categoriaId?: StringFilter<"categoriasCursos"> | string
    cursoId?: StringFilter<"categoriasCursos"> | string
  }

  export type estudiantesCreateWithoutUsuarioInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    calificaciones?: calificacionesCreateNestedManyWithoutEstudianteInput
    certificados?: certificadosCreateNestedManyWithoutEstudianteInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesUncheckedCreateWithoutUsuarioInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutEstudianteInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEstudianteInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesCreateOrConnectWithoutUsuarioInput = {
    where: estudiantesWhereUniqueInput
    create: XOR<estudiantesCreateWithoutUsuarioInput, estudiantesUncheckedCreateWithoutUsuarioInput>
  }

  export type reviewsCursosCreateWithoutUsuarioInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    curso: cursosCreateNestedOneWithoutReviewsInput
  }

  export type reviewsCursosUncheckedCreateWithoutUsuarioInput = {
    id?: string
    cursoId: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type reviewsCursosCreateOrConnectWithoutUsuarioInput = {
    where: reviewsCursosWhereUniqueInput
    create: XOR<reviewsCursosCreateWithoutUsuarioInput, reviewsCursosUncheckedCreateWithoutUsuarioInput>
  }

  export type reviewsCursosCreateManyUsuarioInputEnvelope = {
    data: reviewsCursosCreateManyUsuarioInput | reviewsCursosCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type comprasCreateWithoutUsuarioInput = {
    id?: string
    nombre: string
    apellido: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    edicion: edicionesCursosCreateNestedOneWithoutComprasInput
    inscripcion?: inscripcionesCreateNestedOneWithoutCompraInput
  }

  export type comprasUncheckedCreateWithoutUsuarioInput = {
    id?: string
    nombre: string
    apellido: string
    edicionId: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    inscripcion?: inscripcionesUncheckedCreateNestedOneWithoutCompraInput
  }

  export type comprasCreateOrConnectWithoutUsuarioInput = {
    where: comprasWhereUniqueInput
    create: XOR<comprasCreateWithoutUsuarioInput, comprasUncheckedCreateWithoutUsuarioInput>
  }

  export type comprasCreateManyUsuarioInputEnvelope = {
    data: comprasCreateManyUsuarioInput | comprasCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type estudiantesUpsertWithoutUsuarioInput = {
    update: XOR<estudiantesUpdateWithoutUsuarioInput, estudiantesUncheckedUpdateWithoutUsuarioInput>
    create: XOR<estudiantesCreateWithoutUsuarioInput, estudiantesUncheckedCreateWithoutUsuarioInput>
    where?: estudiantesWhereInput
  }

  export type estudiantesUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: estudiantesWhereInput
    data: XOR<estudiantesUpdateWithoutUsuarioInput, estudiantesUncheckedUpdateWithoutUsuarioInput>
  }

  export type estudiantesUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: calificacionesUpdateManyWithoutEstudianteNestedInput
    certificados?: certificadosUpdateManyWithoutEstudianteNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEstudianteNestedInput
  }

  export type estudiantesUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: calificacionesUncheckedUpdateManyWithoutEstudianteNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEstudianteNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type reviewsCursosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: reviewsCursosWhereUniqueInput
    update: XOR<reviewsCursosUpdateWithoutUsuarioInput, reviewsCursosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<reviewsCursosCreateWithoutUsuarioInput, reviewsCursosUncheckedCreateWithoutUsuarioInput>
  }

  export type reviewsCursosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: reviewsCursosWhereUniqueInput
    data: XOR<reviewsCursosUpdateWithoutUsuarioInput, reviewsCursosUncheckedUpdateWithoutUsuarioInput>
  }

  export type reviewsCursosUpdateManyWithWhereWithoutUsuarioInput = {
    where: reviewsCursosScalarWhereInput
    data: XOR<reviewsCursosUpdateManyMutationInput, reviewsCursosUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type reviewsCursosScalarWhereInput = {
    AND?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
    OR?: reviewsCursosScalarWhereInput[]
    NOT?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
    id?: StringFilter<"reviewsCursos"> | string
    cursoId?: StringFilter<"reviewsCursos"> | string
    rating?: IntFilter<"reviewsCursos"> | number
    comentario?: StringNullableFilter<"reviewsCursos"> | string | null
    creadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    usuariosEstudiantesId?: StringFilter<"reviewsCursos"> | string
  }

  export type comprasUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: comprasWhereUniqueInput
    update: XOR<comprasUpdateWithoutUsuarioInput, comprasUncheckedUpdateWithoutUsuarioInput>
    create: XOR<comprasCreateWithoutUsuarioInput, comprasUncheckedCreateWithoutUsuarioInput>
  }

  export type comprasUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: comprasWhereUniqueInput
    data: XOR<comprasUpdateWithoutUsuarioInput, comprasUncheckedUpdateWithoutUsuarioInput>
  }

  export type comprasUpdateManyWithWhereWithoutUsuarioInput = {
    where: comprasScalarWhereInput
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type comprasScalarWhereInput = {
    AND?: comprasScalarWhereInput | comprasScalarWhereInput[]
    OR?: comprasScalarWhereInput[]
    NOT?: comprasScalarWhereInput | comprasScalarWhereInput[]
    id?: StringFilter<"compras"> | string
    nombre?: StringFilter<"compras"> | string
    apellido?: StringFilter<"compras"> | string
    edicionId?: StringFilter<"compras"> | string
    monto?: FloatFilter<"compras"> | number
    moneda?: StringFilter<"compras"> | string
    providerId?: StringFilter<"compras"> | string
    comprobado?: BoolFilter<"compras"> | boolean
    fechaCompra?: DateTimeFilter<"compras"> | Date | string
    metodo?: StringNullableFilter<"compras"> | string | null
    usuariosEstudiantesId?: StringNullableFilter<"compras"> | string | null
  }

  export type usuariosEstudiantesCreateWithoutEstudianteInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    avatar?: string | null
    registrado?: boolean
    reviews?: reviewsCursosCreateNestedManyWithoutUsuarioInput
    compras?: comprasCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutEstudianteInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    avatar?: string | null
    registrado?: boolean
    reviews?: reviewsCursosUncheckedCreateNestedManyWithoutUsuarioInput
    compras?: comprasUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutEstudianteInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutEstudianteInput, usuariosEstudiantesUncheckedCreateWithoutEstudianteInput>
  }

  export type calificacionesCreateWithoutEstudianteInput = {
    id?: string
    aprobado: boolean
    comentarios?: string | null
    nota: number
    creadoEn?: Date | string
    examen: examenesCreateNestedOneWithoutCalificacionesInput
  }

  export type calificacionesUncheckedCreateWithoutEstudianteInput = {
    id?: string
    aprobado: boolean
    comentarios?: string | null
    examenId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesCreateOrConnectWithoutEstudianteInput = {
    where: calificacionesWhereUniqueInput
    create: XOR<calificacionesCreateWithoutEstudianteInput, calificacionesUncheckedCreateWithoutEstudianteInput>
  }

  export type calificacionesCreateManyEstudianteInputEnvelope = {
    data: calificacionesCreateManyEstudianteInput | calificacionesCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type certificadosCreateWithoutEstudianteInput = {
    id?: string
    codigoUnico: string
    fechaEmision: Date | string
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutCertificadosInput
  }

  export type certificadosUncheckedCreateWithoutEstudianteInput = {
    id?: string
    codigoUnico: string
    edicionId: string
    fechaEmision: Date | string
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type certificadosCreateOrConnectWithoutEstudianteInput = {
    where: certificadosWhereUniqueInput
    create: XOR<certificadosCreateWithoutEstudianteInput, certificadosUncheckedCreateWithoutEstudianteInput>
  }

  export type certificadosCreateManyEstudianteInputEnvelope = {
    data: certificadosCreateManyEstudianteInput | certificadosCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type inscripcionesCreateWithoutEstudianteInput = {
    id?: string
    estado?: boolean
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutInscripcionesInput
    compra?: comprasCreateNestedOneWithoutInscripcionInput
  }

  export type inscripcionesUncheckedCreateWithoutEstudianteInput = {
    id?: string
    edicionId: string
    estado?: boolean
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    compraId?: string | null
  }

  export type inscripcionesCreateOrConnectWithoutEstudianteInput = {
    where: inscripcionesWhereUniqueInput
    create: XOR<inscripcionesCreateWithoutEstudianteInput, inscripcionesUncheckedCreateWithoutEstudianteInput>
  }

  export type inscripcionesCreateManyEstudianteInputEnvelope = {
    data: inscripcionesCreateManyEstudianteInput | inscripcionesCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type usuariosEstudiantesUpsertWithoutEstudianteInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutEstudianteInput, usuariosEstudiantesUncheckedUpdateWithoutEstudianteInput>
    create: XOR<usuariosEstudiantesCreateWithoutEstudianteInput, usuariosEstudiantesUncheckedCreateWithoutEstudianteInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutEstudianteInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutEstudianteInput, usuariosEstudiantesUncheckedUpdateWithoutEstudianteInput>
  }

  export type usuariosEstudiantesUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    reviews?: reviewsCursosUpdateManyWithoutUsuarioNestedInput
    compras?: comprasUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    reviews?: reviewsCursosUncheckedUpdateManyWithoutUsuarioNestedInput
    compras?: comprasUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type calificacionesUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: calificacionesWhereUniqueInput
    update: XOR<calificacionesUpdateWithoutEstudianteInput, calificacionesUncheckedUpdateWithoutEstudianteInput>
    create: XOR<calificacionesCreateWithoutEstudianteInput, calificacionesUncheckedCreateWithoutEstudianteInput>
  }

  export type calificacionesUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: calificacionesWhereUniqueInput
    data: XOR<calificacionesUpdateWithoutEstudianteInput, calificacionesUncheckedUpdateWithoutEstudianteInput>
  }

  export type calificacionesUpdateManyWithWhereWithoutEstudianteInput = {
    where: calificacionesScalarWhereInput
    data: XOR<calificacionesUpdateManyMutationInput, calificacionesUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type calificacionesScalarWhereInput = {
    AND?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
    OR?: calificacionesScalarWhereInput[]
    NOT?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
    id?: StringFilter<"calificaciones"> | string
    aprobado?: BoolFilter<"calificaciones"> | boolean
    comentarios?: StringNullableFilter<"calificaciones"> | string | null
    estudianteId?: StringFilter<"calificaciones"> | string
    examenId?: StringFilter<"calificaciones"> | string
    nota?: FloatFilter<"calificaciones"> | number
    creadoEn?: DateTimeFilter<"calificaciones"> | Date | string
  }

  export type certificadosUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: certificadosWhereUniqueInput
    update: XOR<certificadosUpdateWithoutEstudianteInput, certificadosUncheckedUpdateWithoutEstudianteInput>
    create: XOR<certificadosCreateWithoutEstudianteInput, certificadosUncheckedCreateWithoutEstudianteInput>
  }

  export type certificadosUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: certificadosWhereUniqueInput
    data: XOR<certificadosUpdateWithoutEstudianteInput, certificadosUncheckedUpdateWithoutEstudianteInput>
  }

  export type certificadosUpdateManyWithWhereWithoutEstudianteInput = {
    where: certificadosScalarWhereInput
    data: XOR<certificadosUpdateManyMutationInput, certificadosUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type certificadosScalarWhereInput = {
    AND?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
    OR?: certificadosScalarWhereInput[]
    NOT?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
    id?: StringFilter<"certificados"> | string
    codigoUnico?: StringFilter<"certificados"> | string
    edicionId?: StringFilter<"certificados"> | string
    estudianteId?: StringFilter<"certificados"> | string
    fechaEmision?: DateTimeFilter<"certificados"> | Date | string
    notaFinal?: FloatNullableFilter<"certificados"> | number | null
    urlCertificado?: StringNullableFilter<"certificados"> | string | null
    creadoEn?: DateTimeFilter<"certificados"> | Date | string
  }

  export type inscripcionesUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: inscripcionesWhereUniqueInput
    update: XOR<inscripcionesUpdateWithoutEstudianteInput, inscripcionesUncheckedUpdateWithoutEstudianteInput>
    create: XOR<inscripcionesCreateWithoutEstudianteInput, inscripcionesUncheckedCreateWithoutEstudianteInput>
  }

  export type inscripcionesUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: inscripcionesWhereUniqueInput
    data: XOR<inscripcionesUpdateWithoutEstudianteInput, inscripcionesUncheckedUpdateWithoutEstudianteInput>
  }

  export type inscripcionesUpdateManyWithWhereWithoutEstudianteInput = {
    where: inscripcionesScalarWhereInput
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type inscripcionesScalarWhereInput = {
    AND?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
    OR?: inscripcionesScalarWhereInput[]
    NOT?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
    id?: StringFilter<"inscripciones"> | string
    edicionId?: StringFilter<"inscripciones"> | string
    estado?: BoolFilter<"inscripciones"> | boolean
    estudianteId?: StringFilter<"inscripciones"> | string
    inscritoEn?: DateTimeFilter<"inscripciones"> | Date | string
    actualizadoEn?: DateTimeFilter<"inscripciones"> | Date | string
    compraId?: StringNullableFilter<"inscripciones"> | string | null
  }

  export type docenteCreateWithoutUsuarioInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    ediciones?: edicionesCursosCreateNestedManyWithoutDocenteInput
  }

  export type docenteUncheckedCreateWithoutUsuarioInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    ediciones?: edicionesCursosUncheckedCreateNestedManyWithoutDocenteInput
  }

  export type docenteCreateOrConnectWithoutUsuarioInput = {
    where: docenteWhereUniqueInput
    create: XOR<docenteCreateWithoutUsuarioInput, docenteUncheckedCreateWithoutUsuarioInput>
  }

  export type auditoriaCreateWithoutUsuarioInput = {
    id?: string
    tabla: string
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
  }

  export type auditoriaUncheckedCreateWithoutUsuarioInput = {
    id?: string
    tabla: string
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
  }

  export type auditoriaCreateOrConnectWithoutUsuarioInput = {
    where: auditoriaWhereUniqueInput
    create: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type auditoriaCreateManyUsuarioInputEnvelope = {
    data: auditoriaCreateManyUsuarioInput | auditoriaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type grabacionesCreateWithoutUsuarioInput = {
    id?: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
    clase: clasesCreateNestedOneWithoutGrabacionesInput
  }

  export type grabacionesUncheckedCreateWithoutUsuarioInput = {
    id?: string
    claseId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type grabacionesCreateOrConnectWithoutUsuarioInput = {
    where: grabacionesWhereUniqueInput
    create: XOR<grabacionesCreateWithoutUsuarioInput, grabacionesUncheckedCreateWithoutUsuarioInput>
  }

  export type grabacionesCreateManyUsuarioInputEnvelope = {
    data: grabacionesCreateManyUsuarioInput | grabacionesCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type docenteUpsertWithoutUsuarioInput = {
    update: XOR<docenteUpdateWithoutUsuarioInput, docenteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<docenteCreateWithoutUsuarioInput, docenteUncheckedCreateWithoutUsuarioInput>
    where?: docenteWhereInput
  }

  export type docenteUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: docenteWhereInput
    data: XOR<docenteUpdateWithoutUsuarioInput, docenteUncheckedUpdateWithoutUsuarioInput>
  }

  export type docenteUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    ediciones?: edicionesCursosUpdateManyWithoutDocenteNestedInput
  }

  export type docenteUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    ediciones?: edicionesCursosUncheckedUpdateManyWithoutDocenteNestedInput
  }

  export type auditoriaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: auditoriaWhereUniqueInput
    update: XOR<auditoriaUpdateWithoutUsuarioInput, auditoriaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type auditoriaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: auditoriaWhereUniqueInput
    data: XOR<auditoriaUpdateWithoutUsuarioInput, auditoriaUncheckedUpdateWithoutUsuarioInput>
  }

  export type auditoriaUpdateManyWithWhereWithoutUsuarioInput = {
    where: auditoriaScalarWhereInput
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type auditoriaScalarWhereInput = {
    AND?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
    OR?: auditoriaScalarWhereInput[]
    NOT?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
    id?: StringFilter<"auditoria"> | string
    tabla?: StringFilter<"auditoria"> | string
    registroId?: StringNullableFilter<"auditoria"> | string | null
    accion?: EnumAccionAuditoriaFilter<"auditoria"> | $Enums.AccionAuditoria
    detalles?: JsonNullableFilter<"auditoria">
    usuarioId?: StringNullableFilter<"auditoria"> | string | null
    creadoEn?: DateTimeFilter<"auditoria"> | Date | string
  }

  export type grabacionesUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: grabacionesWhereUniqueInput
    update: XOR<grabacionesUpdateWithoutUsuarioInput, grabacionesUncheckedUpdateWithoutUsuarioInput>
    create: XOR<grabacionesCreateWithoutUsuarioInput, grabacionesUncheckedCreateWithoutUsuarioInput>
  }

  export type grabacionesUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: grabacionesWhereUniqueInput
    data: XOR<grabacionesUpdateWithoutUsuarioInput, grabacionesUncheckedUpdateWithoutUsuarioInput>
  }

  export type grabacionesUpdateManyWithWhereWithoutUsuarioInput = {
    where: grabacionesScalarWhereInput
    data: XOR<grabacionesUpdateManyMutationInput, grabacionesUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type grabacionesScalarWhereInput = {
    AND?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
    OR?: grabacionesScalarWhereInput[]
    NOT?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
    id?: StringFilter<"grabaciones"> | string
    claseId?: StringFilter<"grabaciones"> | string
    usuarioId?: StringFilter<"grabaciones"> | string
    fechaInicio?: DateTimeFilter<"grabaciones"> | Date | string
    fechaFin?: DateTimeNullableFilter<"grabaciones"> | Date | string | null
    duracionSegundos?: IntNullableFilter<"grabaciones"> | number | null
    completada?: BoolFilter<"grabaciones"> | boolean
  }

  export type usuariosAdministradoresCreateWithoutDocenteInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    tipo: $Enums.TipoCuenta
    auditorias?: auditoriaCreateNestedManyWithoutUsuarioInput
    grabaciones?: grabacionesCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosAdministradoresUncheckedCreateWithoutDocenteInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    tipo: $Enums.TipoCuenta
    auditorias?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosAdministradoresCreateOrConnectWithoutDocenteInput = {
    where: usuariosAdministradoresWhereUniqueInput
    create: XOR<usuariosAdministradoresCreateWithoutDocenteInput, usuariosAdministradoresUncheckedCreateWithoutDocenteInput>
  }

  export type edicionesCursosCreateWithoutDocenteInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    curso: cursosCreateNestedOneWithoutEdicionesInput
    compras?: comprasCreateNestedManyWithoutEdicionInput
    certificados?: certificadosCreateNestedManyWithoutEdicionInput
    clases?: clasesCreateNestedManyWithoutEdicionInput
    examenes?: examenesCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUncheckedCreateWithoutDocenteInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosUncheckedCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosCreateOrConnectWithoutDocenteInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput>
  }

  export type edicionesCursosCreateManyDocenteInputEnvelope = {
    data: edicionesCursosCreateManyDocenteInput | edicionesCursosCreateManyDocenteInput[]
    skipDuplicates?: boolean
  }

  export type usuariosAdministradoresUpsertWithoutDocenteInput = {
    update: XOR<usuariosAdministradoresUpdateWithoutDocenteInput, usuariosAdministradoresUncheckedUpdateWithoutDocenteInput>
    create: XOR<usuariosAdministradoresCreateWithoutDocenteInput, usuariosAdministradoresUncheckedCreateWithoutDocenteInput>
    where?: usuariosAdministradoresWhereInput
  }

  export type usuariosAdministradoresUpdateToOneWithWhereWithoutDocenteInput = {
    where?: usuariosAdministradoresWhereInput
    data: XOR<usuariosAdministradoresUpdateWithoutDocenteInput, usuariosAdministradoresUncheckedUpdateWithoutDocenteInput>
  }

  export type usuariosAdministradoresUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    auditorias?: auditoriaUpdateManyWithoutUsuarioNestedInput
    grabaciones?: grabacionesUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosAdministradoresUncheckedUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    auditorias?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    grabaciones?: grabacionesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput = {
    where: edicionesCursosWhereUniqueInput
    update: XOR<edicionesCursosUpdateWithoutDocenteInput, edicionesCursosUncheckedUpdateWithoutDocenteInput>
    create: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput>
  }

  export type edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput = {
    where: edicionesCursosWhereUniqueInput
    data: XOR<edicionesCursosUpdateWithoutDocenteInput, edicionesCursosUncheckedUpdateWithoutDocenteInput>
  }

  export type edicionesCursosUpdateManyWithWhereWithoutDocenteInput = {
    where: edicionesCursosScalarWhereInput
    data: XOR<edicionesCursosUpdateManyMutationInput, edicionesCursosUncheckedUpdateManyWithoutDocenteInput>
  }

  export type edicionesCursosScalarWhereInput = {
    AND?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
    OR?: edicionesCursosScalarWhereInput[]
    NOT?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
    id?: StringFilter<"edicionesCursos"> | string
    codigo?: StringFilter<"edicionesCursos"> | string
    cursoId?: StringFilter<"edicionesCursos"> | string
    descripcion?: StringNullableFilter<"edicionesCursos"> | string | null
    estado?: EnumEdicionEstadoFilter<"edicionesCursos"> | $Enums.EdicionEstado
    fechaFin?: DateTimeFilter<"edicionesCursos"> | Date | string
    fechaInicio?: DateTimeFilter<"edicionesCursos"> | Date | string
    notaMaxima?: FloatFilter<"edicionesCursos"> | number
    notaMinima?: FloatFilter<"edicionesCursos"> | number
    urlWhatsapp?: StringNullableFilter<"edicionesCursos"> | string | null
    vigente?: BoolFilter<"edicionesCursos"> | boolean
    creadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    docenteId?: StringFilter<"edicionesCursos"> | string
  }

  export type edicionesCursosCreateWithoutCursoInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docente: docenteCreateNestedOneWithoutEdicionesInput
    compras?: comprasCreateNestedManyWithoutEdicionInput
    certificados?: certificadosCreateNestedManyWithoutEdicionInput
    clases?: clasesCreateNestedManyWithoutEdicionInput
    examenes?: examenesCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUncheckedCreateWithoutCursoInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosUncheckedCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosCreateOrConnectWithoutCursoInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutCursoInput, edicionesCursosUncheckedCreateWithoutCursoInput>
  }

  export type edicionesCursosCreateManyCursoInputEnvelope = {
    data: edicionesCursosCreateManyCursoInput | edicionesCursosCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type beneficiosCursosCreateWithoutCursoInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type beneficiosCursosUncheckedCreateWithoutCursoInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type beneficiosCursosCreateOrConnectWithoutCursoInput = {
    where: beneficiosCursosWhereUniqueInput
    create: XOR<beneficiosCursosCreateWithoutCursoInput, beneficiosCursosUncheckedCreateWithoutCursoInput>
  }

  export type beneficiosCursosCreateManyCursoInputEnvelope = {
    data: beneficiosCursosCreateManyCursoInput | beneficiosCursosCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type objetivosCursosCreateWithoutCursoInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type objetivosCursosUncheckedCreateWithoutCursoInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type objetivosCursosCreateOrConnectWithoutCursoInput = {
    where: objetivosCursosWhereUniqueInput
    create: XOR<objetivosCursosCreateWithoutCursoInput, objetivosCursosUncheckedCreateWithoutCursoInput>
  }

  export type objetivosCursosCreateManyCursoInputEnvelope = {
    data: objetivosCursosCreateManyCursoInput | objetivosCursosCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type requisitosCursosCreateWithoutCursoInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosUncheckedCreateWithoutCursoInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosCreateOrConnectWithoutCursoInput = {
    where: requisitosCursosWhereUniqueInput
    create: XOR<requisitosCursosCreateWithoutCursoInput, requisitosCursosUncheckedCreateWithoutCursoInput>
  }

  export type requisitosCursosCreateManyCursoInputEnvelope = {
    data: requisitosCursosCreateManyCursoInput | requisitosCursosCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type categoriasCursosCreateWithoutCursoInput = {
    id?: string
    categoria: categoriasCreateNestedOneWithoutCategoriasCursosInput
  }

  export type categoriasCursosUncheckedCreateWithoutCursoInput = {
    id?: string
    categoriaId: string
  }

  export type categoriasCursosCreateOrConnectWithoutCursoInput = {
    where: categoriasCursosWhereUniqueInput
    create: XOR<categoriasCursosCreateWithoutCursoInput, categoriasCursosUncheckedCreateWithoutCursoInput>
  }

  export type categoriasCursosCreateManyCursoInputEnvelope = {
    data: categoriasCursosCreateManyCursoInput | categoriasCursosCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCursosCreateWithoutCursoInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario: usuariosEstudiantesCreateNestedOneWithoutReviewsInput
  }

  export type reviewsCursosUncheckedCreateWithoutCursoInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuariosEstudiantesId: string
  }

  export type reviewsCursosCreateOrConnectWithoutCursoInput = {
    where: reviewsCursosWhereUniqueInput
    create: XOR<reviewsCursosCreateWithoutCursoInput, reviewsCursosUncheckedCreateWithoutCursoInput>
  }

  export type reviewsCursosCreateManyCursoInputEnvelope = {
    data: reviewsCursosCreateManyCursoInput | reviewsCursosCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type edicionesCursosUpsertWithWhereUniqueWithoutCursoInput = {
    where: edicionesCursosWhereUniqueInput
    update: XOR<edicionesCursosUpdateWithoutCursoInput, edicionesCursosUncheckedUpdateWithoutCursoInput>
    create: XOR<edicionesCursosCreateWithoutCursoInput, edicionesCursosUncheckedCreateWithoutCursoInput>
  }

  export type edicionesCursosUpdateWithWhereUniqueWithoutCursoInput = {
    where: edicionesCursosWhereUniqueInput
    data: XOR<edicionesCursosUpdateWithoutCursoInput, edicionesCursosUncheckedUpdateWithoutCursoInput>
  }

  export type edicionesCursosUpdateManyWithWhereWithoutCursoInput = {
    where: edicionesCursosScalarWhereInput
    data: XOR<edicionesCursosUpdateManyMutationInput, edicionesCursosUncheckedUpdateManyWithoutCursoInput>
  }

  export type beneficiosCursosUpsertWithWhereUniqueWithoutCursoInput = {
    where: beneficiosCursosWhereUniqueInput
    update: XOR<beneficiosCursosUpdateWithoutCursoInput, beneficiosCursosUncheckedUpdateWithoutCursoInput>
    create: XOR<beneficiosCursosCreateWithoutCursoInput, beneficiosCursosUncheckedCreateWithoutCursoInput>
  }

  export type beneficiosCursosUpdateWithWhereUniqueWithoutCursoInput = {
    where: beneficiosCursosWhereUniqueInput
    data: XOR<beneficiosCursosUpdateWithoutCursoInput, beneficiosCursosUncheckedUpdateWithoutCursoInput>
  }

  export type beneficiosCursosUpdateManyWithWhereWithoutCursoInput = {
    where: beneficiosCursosScalarWhereInput
    data: XOR<beneficiosCursosUpdateManyMutationInput, beneficiosCursosUncheckedUpdateManyWithoutCursoInput>
  }

  export type beneficiosCursosScalarWhereInput = {
    AND?: beneficiosCursosScalarWhereInput | beneficiosCursosScalarWhereInput[]
    OR?: beneficiosCursosScalarWhereInput[]
    NOT?: beneficiosCursosScalarWhereInput | beneficiosCursosScalarWhereInput[]
    id?: StringFilter<"beneficiosCursos"> | string
    cursoId?: StringFilter<"beneficiosCursos"> | string
    descripcion?: StringFilter<"beneficiosCursos"> | string
    orden?: IntFilter<"beneficiosCursos"> | number
    creadoEn?: DateTimeFilter<"beneficiosCursos"> | Date | string
  }

  export type objetivosCursosUpsertWithWhereUniqueWithoutCursoInput = {
    where: objetivosCursosWhereUniqueInput
    update: XOR<objetivosCursosUpdateWithoutCursoInput, objetivosCursosUncheckedUpdateWithoutCursoInput>
    create: XOR<objetivosCursosCreateWithoutCursoInput, objetivosCursosUncheckedCreateWithoutCursoInput>
  }

  export type objetivosCursosUpdateWithWhereUniqueWithoutCursoInput = {
    where: objetivosCursosWhereUniqueInput
    data: XOR<objetivosCursosUpdateWithoutCursoInput, objetivosCursosUncheckedUpdateWithoutCursoInput>
  }

  export type objetivosCursosUpdateManyWithWhereWithoutCursoInput = {
    where: objetivosCursosScalarWhereInput
    data: XOR<objetivosCursosUpdateManyMutationInput, objetivosCursosUncheckedUpdateManyWithoutCursoInput>
  }

  export type objetivosCursosScalarWhereInput = {
    AND?: objetivosCursosScalarWhereInput | objetivosCursosScalarWhereInput[]
    OR?: objetivosCursosScalarWhereInput[]
    NOT?: objetivosCursosScalarWhereInput | objetivosCursosScalarWhereInput[]
    id?: StringFilter<"objetivosCursos"> | string
    cursoId?: StringFilter<"objetivosCursos"> | string
    descripcion?: StringFilter<"objetivosCursos"> | string
    orden?: IntFilter<"objetivosCursos"> | number
    creadoEn?: DateTimeFilter<"objetivosCursos"> | Date | string
  }

  export type requisitosCursosUpsertWithWhereUniqueWithoutCursoInput = {
    where: requisitosCursosWhereUniqueInput
    update: XOR<requisitosCursosUpdateWithoutCursoInput, requisitosCursosUncheckedUpdateWithoutCursoInput>
    create: XOR<requisitosCursosCreateWithoutCursoInput, requisitosCursosUncheckedCreateWithoutCursoInput>
  }

  export type requisitosCursosUpdateWithWhereUniqueWithoutCursoInput = {
    where: requisitosCursosWhereUniqueInput
    data: XOR<requisitosCursosUpdateWithoutCursoInput, requisitosCursosUncheckedUpdateWithoutCursoInput>
  }

  export type requisitosCursosUpdateManyWithWhereWithoutCursoInput = {
    where: requisitosCursosScalarWhereInput
    data: XOR<requisitosCursosUpdateManyMutationInput, requisitosCursosUncheckedUpdateManyWithoutCursoInput>
  }

  export type requisitosCursosScalarWhereInput = {
    AND?: requisitosCursosScalarWhereInput | requisitosCursosScalarWhereInput[]
    OR?: requisitosCursosScalarWhereInput[]
    NOT?: requisitosCursosScalarWhereInput | requisitosCursosScalarWhereInput[]
    id?: StringFilter<"requisitosCursos"> | string
    cursoId?: StringFilter<"requisitosCursos"> | string
    descripcion?: StringFilter<"requisitosCursos"> | string
    orden?: IntFilter<"requisitosCursos"> | number
    creadoEn?: DateTimeFilter<"requisitosCursos"> | Date | string
  }

  export type categoriasCursosUpsertWithWhereUniqueWithoutCursoInput = {
    where: categoriasCursosWhereUniqueInput
    update: XOR<categoriasCursosUpdateWithoutCursoInput, categoriasCursosUncheckedUpdateWithoutCursoInput>
    create: XOR<categoriasCursosCreateWithoutCursoInput, categoriasCursosUncheckedCreateWithoutCursoInput>
  }

  export type categoriasCursosUpdateWithWhereUniqueWithoutCursoInput = {
    where: categoriasCursosWhereUniqueInput
    data: XOR<categoriasCursosUpdateWithoutCursoInput, categoriasCursosUncheckedUpdateWithoutCursoInput>
  }

  export type categoriasCursosUpdateManyWithWhereWithoutCursoInput = {
    where: categoriasCursosScalarWhereInput
    data: XOR<categoriasCursosUpdateManyMutationInput, categoriasCursosUncheckedUpdateManyWithoutCursoInput>
  }

  export type reviewsCursosUpsertWithWhereUniqueWithoutCursoInput = {
    where: reviewsCursosWhereUniqueInput
    update: XOR<reviewsCursosUpdateWithoutCursoInput, reviewsCursosUncheckedUpdateWithoutCursoInput>
    create: XOR<reviewsCursosCreateWithoutCursoInput, reviewsCursosUncheckedCreateWithoutCursoInput>
  }

  export type reviewsCursosUpdateWithWhereUniqueWithoutCursoInput = {
    where: reviewsCursosWhereUniqueInput
    data: XOR<reviewsCursosUpdateWithoutCursoInput, reviewsCursosUncheckedUpdateWithoutCursoInput>
  }

  export type reviewsCursosUpdateManyWithWhereWithoutCursoInput = {
    where: reviewsCursosScalarWhereInput
    data: XOR<reviewsCursosUpdateManyMutationInput, reviewsCursosUncheckedUpdateManyWithoutCursoInput>
  }

  export type categoriasCreateWithoutCategoriasCursosInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type categoriasUncheckedCreateWithoutCategoriasCursosInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type categoriasCreateOrConnectWithoutCategoriasCursosInput = {
    where: categoriasWhereUniqueInput
    create: XOR<categoriasCreateWithoutCategoriasCursosInput, categoriasUncheckedCreateWithoutCategoriasCursosInput>
  }

  export type cursosCreateWithoutCategoriasInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosCreateNestedManyWithoutCursoInput
  }

  export type cursosUncheckedCreateWithoutCategoriasInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosUncheckedCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosUncheckedCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosUncheckedCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosUncheckedCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosUncheckedCreateNestedManyWithoutCursoInput
  }

  export type cursosCreateOrConnectWithoutCategoriasInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutCategoriasInput, cursosUncheckedCreateWithoutCategoriasInput>
  }

  export type categoriasUpsertWithoutCategoriasCursosInput = {
    update: XOR<categoriasUpdateWithoutCategoriasCursosInput, categoriasUncheckedUpdateWithoutCategoriasCursosInput>
    create: XOR<categoriasCreateWithoutCategoriasCursosInput, categoriasUncheckedCreateWithoutCategoriasCursosInput>
    where?: categoriasWhereInput
  }

  export type categoriasUpdateToOneWithWhereWithoutCategoriasCursosInput = {
    where?: categoriasWhereInput
    data: XOR<categoriasUpdateWithoutCategoriasCursosInput, categoriasUncheckedUpdateWithoutCategoriasCursosInput>
  }

  export type categoriasUpdateWithoutCategoriasCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasUncheckedUpdateWithoutCategoriasCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cursosUpsertWithoutCategoriasInput = {
    update: XOR<cursosUpdateWithoutCategoriasInput, cursosUncheckedUpdateWithoutCategoriasInput>
    create: XOR<cursosCreateWithoutCategoriasInput, cursosUncheckedCreateWithoutCategoriasInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutCategoriasInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutCategoriasInput, cursosUncheckedUpdateWithoutCategoriasInput>
  }

  export type cursosUpdateWithoutCategoriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUpdateManyWithoutCursoNestedInput
  }

  export type cursosUncheckedUpdateWithoutCategoriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUncheckedUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUncheckedUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUncheckedUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUncheckedUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type cursosCreateWithoutReviewsInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosCreateNestedManyWithoutCursoInput
  }

  export type cursosUncheckedCreateWithoutReviewsInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosUncheckedCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosUncheckedCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosUncheckedCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosUncheckedCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosUncheckedCreateNestedManyWithoutCursoInput
  }

  export type cursosCreateOrConnectWithoutReviewsInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutReviewsInput, cursosUncheckedCreateWithoutReviewsInput>
  }

  export type usuariosEstudiantesCreateWithoutReviewsInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    avatar?: string | null
    registrado?: boolean
    estudiante?: estudiantesCreateNestedOneWithoutUsuarioInput
    compras?: comprasCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutReviewsInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    compras?: comprasUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutReviewsInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutReviewsInput, usuariosEstudiantesUncheckedCreateWithoutReviewsInput>
  }

  export type cursosUpsertWithoutReviewsInput = {
    update: XOR<cursosUpdateWithoutReviewsInput, cursosUncheckedUpdateWithoutReviewsInput>
    create: XOR<cursosCreateWithoutReviewsInput, cursosUncheckedCreateWithoutReviewsInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutReviewsInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutReviewsInput, cursosUncheckedUpdateWithoutReviewsInput>
  }

  export type cursosUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUpdateManyWithoutCursoNestedInput
  }

  export type cursosUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUncheckedUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUncheckedUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUncheckedUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUncheckedUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type usuariosEstudiantesUpsertWithoutReviewsInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutReviewsInput, usuariosEstudiantesUncheckedUpdateWithoutReviewsInput>
    create: XOR<usuariosEstudiantesCreateWithoutReviewsInput, usuariosEstudiantesUncheckedCreateWithoutReviewsInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutReviewsInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutReviewsInput, usuariosEstudiantesUncheckedUpdateWithoutReviewsInput>
  }

  export type usuariosEstudiantesUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    estudiante?: estudiantesUpdateOneWithoutUsuarioNestedInput
    compras?: comprasUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type docenteCreateWithoutEdicionesInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario: usuariosAdministradoresCreateNestedOneWithoutDocenteInput
  }

  export type docenteUncheckedCreateWithoutEdicionesInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuarioId: string
  }

  export type docenteCreateOrConnectWithoutEdicionesInput = {
    where: docenteWhereUniqueInput
    create: XOR<docenteCreateWithoutEdicionesInput, docenteUncheckedCreateWithoutEdicionesInput>
  }

  export type cursosCreateWithoutEdicionesInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    beneficios?: beneficiosCursosCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosCreateNestedManyWithoutCursoInput
  }

  export type cursosUncheckedCreateWithoutEdicionesInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    beneficios?: beneficiosCursosUncheckedCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosUncheckedCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosUncheckedCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosUncheckedCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosUncheckedCreateNestedManyWithoutCursoInput
  }

  export type cursosCreateOrConnectWithoutEdicionesInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutEdicionesInput, cursosUncheckedCreateWithoutEdicionesInput>
  }

  export type comprasCreateWithoutEdicionInput = {
    id?: string
    nombre: string
    apellido: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    inscripcion?: inscripcionesCreateNestedOneWithoutCompraInput
    usuario?: usuariosEstudiantesCreateNestedOneWithoutComprasInput
  }

  export type comprasUncheckedCreateWithoutEdicionInput = {
    id?: string
    nombre: string
    apellido: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    usuariosEstudiantesId?: string | null
    inscripcion?: inscripcionesUncheckedCreateNestedOneWithoutCompraInput
  }

  export type comprasCreateOrConnectWithoutEdicionInput = {
    where: comprasWhereUniqueInput
    create: XOR<comprasCreateWithoutEdicionInput, comprasUncheckedCreateWithoutEdicionInput>
  }

  export type comprasCreateManyEdicionInputEnvelope = {
    data: comprasCreateManyEdicionInput | comprasCreateManyEdicionInput[]
    skipDuplicates?: boolean
  }

  export type certificadosCreateWithoutEdicionInput = {
    id?: string
    codigoUnico: string
    fechaEmision: Date | string
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
    estudiante: estudiantesCreateNestedOneWithoutCertificadosInput
  }

  export type certificadosUncheckedCreateWithoutEdicionInput = {
    id?: string
    codigoUnico: string
    estudianteId: string
    fechaEmision: Date | string
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type certificadosCreateOrConnectWithoutEdicionInput = {
    where: certificadosWhereUniqueInput
    create: XOR<certificadosCreateWithoutEdicionInput, certificadosUncheckedCreateWithoutEdicionInput>
  }

  export type certificadosCreateManyEdicionInputEnvelope = {
    data: certificadosCreateManyEdicionInput | certificadosCreateManyEdicionInput[]
    skipDuplicates?: boolean
  }

  export type clasesCreateWithoutEdicionInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    materiales?: materialesCreateNestedManyWithoutClaseInput
    grabaciones?: grabacionesCreateNestedManyWithoutClaseInput
  }

  export type clasesUncheckedCreateWithoutEdicionInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    materiales?: materialesUncheckedCreateNestedManyWithoutClaseInput
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutClaseInput
  }

  export type clasesCreateOrConnectWithoutEdicionInput = {
    where: clasesWhereUniqueInput
    create: XOR<clasesCreateWithoutEdicionInput, clasesUncheckedCreateWithoutEdicionInput>
  }

  export type clasesCreateManyEdicionInputEnvelope = {
    data: clasesCreateManyEdicionInput | clasesCreateManyEdicionInput[]
    skipDuplicates?: boolean
  }

  export type examenesCreateWithoutEdicionInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    calificaciones?: calificacionesCreateNestedManyWithoutExamenInput
  }

  export type examenesUncheckedCreateWithoutEdicionInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutExamenInput
  }

  export type examenesCreateOrConnectWithoutEdicionInput = {
    where: examenesWhereUniqueInput
    create: XOR<examenesCreateWithoutEdicionInput, examenesUncheckedCreateWithoutEdicionInput>
  }

  export type examenesCreateManyEdicionInputEnvelope = {
    data: examenesCreateManyEdicionInput | examenesCreateManyEdicionInput[]
    skipDuplicates?: boolean
  }

  export type inscripcionesCreateWithoutEdicionInput = {
    id?: string
    estado?: boolean
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    estudiante: estudiantesCreateNestedOneWithoutInscripcionesInput
    compra?: comprasCreateNestedOneWithoutInscripcionInput
  }

  export type inscripcionesUncheckedCreateWithoutEdicionInput = {
    id?: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    compraId?: string | null
  }

  export type inscripcionesCreateOrConnectWithoutEdicionInput = {
    where: inscripcionesWhereUniqueInput
    create: XOR<inscripcionesCreateWithoutEdicionInput, inscripcionesUncheckedCreateWithoutEdicionInput>
  }

  export type inscripcionesCreateManyEdicionInputEnvelope = {
    data: inscripcionesCreateManyEdicionInput | inscripcionesCreateManyEdicionInput[]
    skipDuplicates?: boolean
  }

  export type preciosCursosCreateWithoutEdicionInput = {
    id?: string
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: Date | string | null
    fechaInicio?: Date | string | null
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type preciosCursosUncheckedCreateWithoutEdicionInput = {
    id?: string
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: Date | string | null
    fechaInicio?: Date | string | null
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type preciosCursosCreateOrConnectWithoutEdicionInput = {
    where: preciosCursosWhereUniqueInput
    create: XOR<preciosCursosCreateWithoutEdicionInput, preciosCursosUncheckedCreateWithoutEdicionInput>
  }

  export type preciosCursosCreateManyEdicionInputEnvelope = {
    data: preciosCursosCreateManyEdicionInput | preciosCursosCreateManyEdicionInput[]
    skipDuplicates?: boolean
  }

  export type docenteUpsertWithoutEdicionesInput = {
    update: XOR<docenteUpdateWithoutEdicionesInput, docenteUncheckedUpdateWithoutEdicionesInput>
    create: XOR<docenteCreateWithoutEdicionesInput, docenteUncheckedCreateWithoutEdicionesInput>
    where?: docenteWhereInput
  }

  export type docenteUpdateToOneWithWhereWithoutEdicionesInput = {
    where?: docenteWhereInput
    data: XOR<docenteUpdateWithoutEdicionesInput, docenteUncheckedUpdateWithoutEdicionesInput>
  }

  export type docenteUpdateWithoutEdicionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosAdministradoresUpdateOneRequiredWithoutDocenteNestedInput
  }

  export type docenteUncheckedUpdateWithoutEdicionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
  }

  export type cursosUpsertWithoutEdicionesInput = {
    update: XOR<cursosUpdateWithoutEdicionesInput, cursosUncheckedUpdateWithoutEdicionesInput>
    create: XOR<cursosCreateWithoutEdicionesInput, cursosUncheckedCreateWithoutEdicionesInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutEdicionesInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutEdicionesInput, cursosUncheckedUpdateWithoutEdicionesInput>
  }

  export type cursosUpdateWithoutEdicionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    beneficios?: beneficiosCursosUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUpdateManyWithoutCursoNestedInput
  }

  export type cursosUncheckedUpdateWithoutEdicionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    beneficios?: beneficiosCursosUncheckedUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUncheckedUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUncheckedUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUncheckedUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type comprasUpsertWithWhereUniqueWithoutEdicionInput = {
    where: comprasWhereUniqueInput
    update: XOR<comprasUpdateWithoutEdicionInput, comprasUncheckedUpdateWithoutEdicionInput>
    create: XOR<comprasCreateWithoutEdicionInput, comprasUncheckedCreateWithoutEdicionInput>
  }

  export type comprasUpdateWithWhereUniqueWithoutEdicionInput = {
    where: comprasWhereUniqueInput
    data: XOR<comprasUpdateWithoutEdicionInput, comprasUncheckedUpdateWithoutEdicionInput>
  }

  export type comprasUpdateManyWithWhereWithoutEdicionInput = {
    where: comprasScalarWhereInput
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyWithoutEdicionInput>
  }

  export type certificadosUpsertWithWhereUniqueWithoutEdicionInput = {
    where: certificadosWhereUniqueInput
    update: XOR<certificadosUpdateWithoutEdicionInput, certificadosUncheckedUpdateWithoutEdicionInput>
    create: XOR<certificadosCreateWithoutEdicionInput, certificadosUncheckedCreateWithoutEdicionInput>
  }

  export type certificadosUpdateWithWhereUniqueWithoutEdicionInput = {
    where: certificadosWhereUniqueInput
    data: XOR<certificadosUpdateWithoutEdicionInput, certificadosUncheckedUpdateWithoutEdicionInput>
  }

  export type certificadosUpdateManyWithWhereWithoutEdicionInput = {
    where: certificadosScalarWhereInput
    data: XOR<certificadosUpdateManyMutationInput, certificadosUncheckedUpdateManyWithoutEdicionInput>
  }

  export type clasesUpsertWithWhereUniqueWithoutEdicionInput = {
    where: clasesWhereUniqueInput
    update: XOR<clasesUpdateWithoutEdicionInput, clasesUncheckedUpdateWithoutEdicionInput>
    create: XOR<clasesCreateWithoutEdicionInput, clasesUncheckedCreateWithoutEdicionInput>
  }

  export type clasesUpdateWithWhereUniqueWithoutEdicionInput = {
    where: clasesWhereUniqueInput
    data: XOR<clasesUpdateWithoutEdicionInput, clasesUncheckedUpdateWithoutEdicionInput>
  }

  export type clasesUpdateManyWithWhereWithoutEdicionInput = {
    where: clasesScalarWhereInput
    data: XOR<clasesUpdateManyMutationInput, clasesUncheckedUpdateManyWithoutEdicionInput>
  }

  export type clasesScalarWhereInput = {
    AND?: clasesScalarWhereInput | clasesScalarWhereInput[]
    OR?: clasesScalarWhereInput[]
    NOT?: clasesScalarWhereInput | clasesScalarWhereInput[]
    id?: StringFilter<"clases"> | string
    edicionId?: StringFilter<"clases"> | string
    descripcion?: StringFilter<"clases"> | string
    duracion?: IntNullableFilter<"clases"> | number | null
    fecha?: DateTimeFilter<"clases"> | Date | string
    orden?: IntFilter<"clases"> | number
    titulo?: StringFilter<"clases"> | string
    urlYoutube?: StringNullableFilter<"clases"> | string | null
    creadoEn?: DateTimeFilter<"clases"> | Date | string
  }

  export type examenesUpsertWithWhereUniqueWithoutEdicionInput = {
    where: examenesWhereUniqueInput
    update: XOR<examenesUpdateWithoutEdicionInput, examenesUncheckedUpdateWithoutEdicionInput>
    create: XOR<examenesCreateWithoutEdicionInput, examenesUncheckedCreateWithoutEdicionInput>
  }

  export type examenesUpdateWithWhereUniqueWithoutEdicionInput = {
    where: examenesWhereUniqueInput
    data: XOR<examenesUpdateWithoutEdicionInput, examenesUncheckedUpdateWithoutEdicionInput>
  }

  export type examenesUpdateManyWithWhereWithoutEdicionInput = {
    where: examenesScalarWhereInput
    data: XOR<examenesUpdateManyMutationInput, examenesUncheckedUpdateManyWithoutEdicionInput>
  }

  export type examenesScalarWhereInput = {
    AND?: examenesScalarWhereInput | examenesScalarWhereInput[]
    OR?: examenesScalarWhereInput[]
    NOT?: examenesScalarWhereInput | examenesScalarWhereInput[]
    id?: StringFilter<"examenes"> | string
    edicionId?: StringFilter<"examenes"> | string
    descripcion?: StringNullableFilter<"examenes"> | string | null
    fechaDisponible?: DateTimeFilter<"examenes"> | Date | string
    fechaLimite?: DateTimeFilter<"examenes"> | Date | string
    notaMaxima?: FloatFilter<"examenes"> | number
    notaMinima?: FloatFilter<"examenes"> | number
    titulo?: StringFilter<"examenes"> | string
    creadoEn?: DateTimeFilter<"examenes"> | Date | string
  }

  export type inscripcionesUpsertWithWhereUniqueWithoutEdicionInput = {
    where: inscripcionesWhereUniqueInput
    update: XOR<inscripcionesUpdateWithoutEdicionInput, inscripcionesUncheckedUpdateWithoutEdicionInput>
    create: XOR<inscripcionesCreateWithoutEdicionInput, inscripcionesUncheckedCreateWithoutEdicionInput>
  }

  export type inscripcionesUpdateWithWhereUniqueWithoutEdicionInput = {
    where: inscripcionesWhereUniqueInput
    data: XOR<inscripcionesUpdateWithoutEdicionInput, inscripcionesUncheckedUpdateWithoutEdicionInput>
  }

  export type inscripcionesUpdateManyWithWhereWithoutEdicionInput = {
    where: inscripcionesScalarWhereInput
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyWithoutEdicionInput>
  }

  export type preciosCursosUpsertWithWhereUniqueWithoutEdicionInput = {
    where: preciosCursosWhereUniqueInput
    update: XOR<preciosCursosUpdateWithoutEdicionInput, preciosCursosUncheckedUpdateWithoutEdicionInput>
    create: XOR<preciosCursosCreateWithoutEdicionInput, preciosCursosUncheckedCreateWithoutEdicionInput>
  }

  export type preciosCursosUpdateWithWhereUniqueWithoutEdicionInput = {
    where: preciosCursosWhereUniqueInput
    data: XOR<preciosCursosUpdateWithoutEdicionInput, preciosCursosUncheckedUpdateWithoutEdicionInput>
  }

  export type preciosCursosUpdateManyWithWhereWithoutEdicionInput = {
    where: preciosCursosScalarWhereInput
    data: XOR<preciosCursosUpdateManyMutationInput, preciosCursosUncheckedUpdateManyWithoutEdicionInput>
  }

  export type preciosCursosScalarWhereInput = {
    AND?: preciosCursosScalarWhereInput | preciosCursosScalarWhereInput[]
    OR?: preciosCursosScalarWhereInput[]
    NOT?: preciosCursosScalarWhereInput | preciosCursosScalarWhereInput[]
    id?: StringFilter<"preciosCursos"> | string
    edicionId?: StringFilter<"preciosCursos"> | string
    esDescuento?: BoolFilter<"preciosCursos"> | boolean
    esPrecioDefault?: BoolFilter<"preciosCursos"> | boolean
    fechaFin?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    fechaInicio?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    moneda?: StringFilter<"preciosCursos"> | string
    nombre?: StringFilter<"preciosCursos"> | string
    porcentajeDescuento?: FloatNullableFilter<"preciosCursos"> | number | null
    precio?: FloatFilter<"preciosCursos"> | number
    precioOriginal?: FloatNullableFilter<"preciosCursos"> | number | null
    creadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
  }

  export type cursosCreateWithoutBeneficiosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosCreateNestedManyWithoutCursoInput
  }

  export type cursosUncheckedCreateWithoutBeneficiosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosUncheckedCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosUncheckedCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosUncheckedCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosUncheckedCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosUncheckedCreateNestedManyWithoutCursoInput
  }

  export type cursosCreateOrConnectWithoutBeneficiosInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutBeneficiosInput, cursosUncheckedCreateWithoutBeneficiosInput>
  }

  export type cursosUpsertWithoutBeneficiosInput = {
    update: XOR<cursosUpdateWithoutBeneficiosInput, cursosUncheckedUpdateWithoutBeneficiosInput>
    create: XOR<cursosCreateWithoutBeneficiosInput, cursosUncheckedCreateWithoutBeneficiosInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutBeneficiosInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutBeneficiosInput, cursosUncheckedUpdateWithoutBeneficiosInput>
  }

  export type cursosUpdateWithoutBeneficiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUpdateManyWithoutCursoNestedInput
  }

  export type cursosUncheckedUpdateWithoutBeneficiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUncheckedUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUncheckedUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUncheckedUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUncheckedUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type cursosCreateWithoutObjetivosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosCreateNestedManyWithoutCursoInput
  }

  export type cursosUncheckedCreateWithoutObjetivosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosUncheckedCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosUncheckedCreateNestedManyWithoutCursoInput
    requisitos?: requisitosCursosUncheckedCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosUncheckedCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosUncheckedCreateNestedManyWithoutCursoInput
  }

  export type cursosCreateOrConnectWithoutObjetivosInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutObjetivosInput, cursosUncheckedCreateWithoutObjetivosInput>
  }

  export type cursosUpsertWithoutObjetivosInput = {
    update: XOR<cursosUpdateWithoutObjetivosInput, cursosUncheckedUpdateWithoutObjetivosInput>
    create: XOR<cursosCreateWithoutObjetivosInput, cursosUncheckedCreateWithoutObjetivosInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutObjetivosInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutObjetivosInput, cursosUncheckedUpdateWithoutObjetivosInput>
  }

  export type cursosUpdateWithoutObjetivosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUpdateManyWithoutCursoNestedInput
  }

  export type cursosUncheckedUpdateWithoutObjetivosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUncheckedUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUncheckedUpdateManyWithoutCursoNestedInput
    requisitos?: requisitosCursosUncheckedUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUncheckedUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type cursosCreateWithoutRequisitosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosCreateNestedManyWithoutCursoInput
  }

  export type cursosUncheckedCreateWithoutRequisitosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    ediciones?: edicionesCursosUncheckedCreateNestedManyWithoutCursoInput
    beneficios?: beneficiosCursosUncheckedCreateNestedManyWithoutCursoInput
    objetivos?: objetivosCursosUncheckedCreateNestedManyWithoutCursoInput
    categorias?: categoriasCursosUncheckedCreateNestedManyWithoutCursoInput
    reviews?: reviewsCursosUncheckedCreateNestedManyWithoutCursoInput
  }

  export type cursosCreateOrConnectWithoutRequisitosInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutRequisitosInput, cursosUncheckedCreateWithoutRequisitosInput>
  }

  export type cursosUpsertWithoutRequisitosInput = {
    update: XOR<cursosUpdateWithoutRequisitosInput, cursosUncheckedUpdateWithoutRequisitosInput>
    create: XOR<cursosCreateWithoutRequisitosInput, cursosUncheckedCreateWithoutRequisitosInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutRequisitosInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutRequisitosInput, cursosUncheckedUpdateWithoutRequisitosInput>
  }

  export type cursosUpdateWithoutRequisitosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUpdateManyWithoutCursoNestedInput
  }

  export type cursosUncheckedUpdateWithoutRequisitosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    ediciones?: edicionesCursosUncheckedUpdateManyWithoutCursoNestedInput
    beneficios?: beneficiosCursosUncheckedUpdateManyWithoutCursoNestedInput
    objetivos?: objetivosCursosUncheckedUpdateManyWithoutCursoNestedInput
    categorias?: categoriasCursosUncheckedUpdateManyWithoutCursoNestedInput
    reviews?: reviewsCursosUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type edicionesCursosCreateWithoutClasesInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docente: docenteCreateNestedOneWithoutEdicionesInput
    curso: cursosCreateNestedOneWithoutEdicionesInput
    compras?: comprasCreateNestedManyWithoutEdicionInput
    certificados?: certificadosCreateNestedManyWithoutEdicionInput
    examenes?: examenesCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUncheckedCreateWithoutClasesInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosUncheckedCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosCreateOrConnectWithoutClasesInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutClasesInput, edicionesCursosUncheckedCreateWithoutClasesInput>
  }

  export type materialesCreateWithoutClaseInput = {
    id?: string
    tipo: string
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type materialesUncheckedCreateWithoutClaseInput = {
    id?: string
    tipo: string
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type materialesCreateOrConnectWithoutClaseInput = {
    where: materialesWhereUniqueInput
    create: XOR<materialesCreateWithoutClaseInput, materialesUncheckedCreateWithoutClaseInput>
  }

  export type materialesCreateManyClaseInputEnvelope = {
    data: materialesCreateManyClaseInput | materialesCreateManyClaseInput[]
    skipDuplicates?: boolean
  }

  export type grabacionesCreateWithoutClaseInput = {
    id?: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
    usuario: usuariosAdministradoresCreateNestedOneWithoutGrabacionesInput
  }

  export type grabacionesUncheckedCreateWithoutClaseInput = {
    id?: string
    usuarioId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type grabacionesCreateOrConnectWithoutClaseInput = {
    where: grabacionesWhereUniqueInput
    create: XOR<grabacionesCreateWithoutClaseInput, grabacionesUncheckedCreateWithoutClaseInput>
  }

  export type grabacionesCreateManyClaseInputEnvelope = {
    data: grabacionesCreateManyClaseInput | grabacionesCreateManyClaseInput[]
    skipDuplicates?: boolean
  }

  export type edicionesCursosUpsertWithoutClasesInput = {
    update: XOR<edicionesCursosUpdateWithoutClasesInput, edicionesCursosUncheckedUpdateWithoutClasesInput>
    create: XOR<edicionesCursosCreateWithoutClasesInput, edicionesCursosUncheckedCreateWithoutClasesInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutClasesInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutClasesInput, edicionesCursosUncheckedUpdateWithoutClasesInput>
  }

  export type edicionesCursosUpdateWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutEdicionesNestedInput
    curso?: cursosUpdateOneRequiredWithoutEdicionesNestedInput
    compras?: comprasUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
    compras?: comprasUncheckedUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUncheckedUpdateManyWithoutEdicionNestedInput
  }

  export type materialesUpsertWithWhereUniqueWithoutClaseInput = {
    where: materialesWhereUniqueInput
    update: XOR<materialesUpdateWithoutClaseInput, materialesUncheckedUpdateWithoutClaseInput>
    create: XOR<materialesCreateWithoutClaseInput, materialesUncheckedCreateWithoutClaseInput>
  }

  export type materialesUpdateWithWhereUniqueWithoutClaseInput = {
    where: materialesWhereUniqueInput
    data: XOR<materialesUpdateWithoutClaseInput, materialesUncheckedUpdateWithoutClaseInput>
  }

  export type materialesUpdateManyWithWhereWithoutClaseInput = {
    where: materialesScalarWhereInput
    data: XOR<materialesUpdateManyMutationInput, materialesUncheckedUpdateManyWithoutClaseInput>
  }

  export type materialesScalarWhereInput = {
    AND?: materialesScalarWhereInput | materialesScalarWhereInput[]
    OR?: materialesScalarWhereInput[]
    NOT?: materialesScalarWhereInput | materialesScalarWhereInput[]
    id?: StringFilter<"materiales"> | string
    claseId?: StringFilter<"materiales"> | string
    tipo?: StringFilter<"materiales"> | string
    titulo?: StringFilter<"materiales"> | string
    url?: StringFilter<"materiales"> | string
    creadoEn?: DateTimeFilter<"materiales"> | Date | string
  }

  export type grabacionesUpsertWithWhereUniqueWithoutClaseInput = {
    where: grabacionesWhereUniqueInput
    update: XOR<grabacionesUpdateWithoutClaseInput, grabacionesUncheckedUpdateWithoutClaseInput>
    create: XOR<grabacionesCreateWithoutClaseInput, grabacionesUncheckedCreateWithoutClaseInput>
  }

  export type grabacionesUpdateWithWhereUniqueWithoutClaseInput = {
    where: grabacionesWhereUniqueInput
    data: XOR<grabacionesUpdateWithoutClaseInput, grabacionesUncheckedUpdateWithoutClaseInput>
  }

  export type grabacionesUpdateManyWithWhereWithoutClaseInput = {
    where: grabacionesScalarWhereInput
    data: XOR<grabacionesUpdateManyMutationInput, grabacionesUncheckedUpdateManyWithoutClaseInput>
  }

  export type clasesCreateWithoutMaterialesInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutClasesInput
    grabaciones?: grabacionesCreateNestedManyWithoutClaseInput
  }

  export type clasesUncheckedCreateWithoutMaterialesInput = {
    id?: string
    edicionId: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutClaseInput
  }

  export type clasesCreateOrConnectWithoutMaterialesInput = {
    where: clasesWhereUniqueInput
    create: XOR<clasesCreateWithoutMaterialesInput, clasesUncheckedCreateWithoutMaterialesInput>
  }

  export type clasesUpsertWithoutMaterialesInput = {
    update: XOR<clasesUpdateWithoutMaterialesInput, clasesUncheckedUpdateWithoutMaterialesInput>
    create: XOR<clasesCreateWithoutMaterialesInput, clasesUncheckedCreateWithoutMaterialesInput>
    where?: clasesWhereInput
  }

  export type clasesUpdateToOneWithWhereWithoutMaterialesInput = {
    where?: clasesWhereInput
    data: XOR<clasesUpdateWithoutMaterialesInput, clasesUncheckedUpdateWithoutMaterialesInput>
  }

  export type clasesUpdateWithoutMaterialesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutClasesNestedInput
    grabaciones?: grabacionesUpdateManyWithoutClaseNestedInput
  }

  export type clasesUncheckedUpdateWithoutMaterialesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    grabaciones?: grabacionesUncheckedUpdateManyWithoutClaseNestedInput
  }

  export type edicionesCursosCreateWithoutExamenesInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docente: docenteCreateNestedOneWithoutEdicionesInput
    curso: cursosCreateNestedOneWithoutEdicionesInput
    compras?: comprasCreateNestedManyWithoutEdicionInput
    certificados?: certificadosCreateNestedManyWithoutEdicionInput
    clases?: clasesCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUncheckedCreateWithoutExamenesInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosUncheckedCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosCreateOrConnectWithoutExamenesInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutExamenesInput, edicionesCursosUncheckedCreateWithoutExamenesInput>
  }

  export type calificacionesCreateWithoutExamenInput = {
    id?: string
    aprobado: boolean
    comentarios?: string | null
    nota: number
    creadoEn?: Date | string
    estudiante: estudiantesCreateNestedOneWithoutCalificacionesInput
  }

  export type calificacionesUncheckedCreateWithoutExamenInput = {
    id?: string
    aprobado: boolean
    comentarios?: string | null
    estudianteId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesCreateOrConnectWithoutExamenInput = {
    where: calificacionesWhereUniqueInput
    create: XOR<calificacionesCreateWithoutExamenInput, calificacionesUncheckedCreateWithoutExamenInput>
  }

  export type calificacionesCreateManyExamenInputEnvelope = {
    data: calificacionesCreateManyExamenInput | calificacionesCreateManyExamenInput[]
    skipDuplicates?: boolean
  }

  export type edicionesCursosUpsertWithoutExamenesInput = {
    update: XOR<edicionesCursosUpdateWithoutExamenesInput, edicionesCursosUncheckedUpdateWithoutExamenesInput>
    create: XOR<edicionesCursosCreateWithoutExamenesInput, edicionesCursosUncheckedCreateWithoutExamenesInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutExamenesInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutExamenesInput, edicionesCursosUncheckedUpdateWithoutExamenesInput>
  }

  export type edicionesCursosUpdateWithoutExamenesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutEdicionesNestedInput
    curso?: cursosUpdateOneRequiredWithoutEdicionesNestedInput
    compras?: comprasUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUpdateManyWithoutEdicionNestedInput
    clases?: clasesUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutExamenesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
    compras?: comprasUncheckedUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUncheckedUpdateManyWithoutEdicionNestedInput
  }

  export type calificacionesUpsertWithWhereUniqueWithoutExamenInput = {
    where: calificacionesWhereUniqueInput
    update: XOR<calificacionesUpdateWithoutExamenInput, calificacionesUncheckedUpdateWithoutExamenInput>
    create: XOR<calificacionesCreateWithoutExamenInput, calificacionesUncheckedCreateWithoutExamenInput>
  }

  export type calificacionesUpdateWithWhereUniqueWithoutExamenInput = {
    where: calificacionesWhereUniqueInput
    data: XOR<calificacionesUpdateWithoutExamenInput, calificacionesUncheckedUpdateWithoutExamenInput>
  }

  export type calificacionesUpdateManyWithWhereWithoutExamenInput = {
    where: calificacionesScalarWhereInput
    data: XOR<calificacionesUpdateManyMutationInput, calificacionesUncheckedUpdateManyWithoutExamenInput>
  }

  export type estudiantesCreateWithoutCalificacionesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario?: usuariosEstudiantesCreateNestedOneWithoutEstudianteInput
    certificados?: certificadosCreateNestedManyWithoutEstudianteInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesUncheckedCreateWithoutCalificacionesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario?: usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudianteInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEstudianteInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesCreateOrConnectWithoutCalificacionesInput = {
    where: estudiantesWhereUniqueInput
    create: XOR<estudiantesCreateWithoutCalificacionesInput, estudiantesUncheckedCreateWithoutCalificacionesInput>
  }

  export type examenesCreateWithoutCalificacionesInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutExamenesInput
  }

  export type examenesUncheckedCreateWithoutCalificacionesInput = {
    id?: string
    edicionId: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
  }

  export type examenesCreateOrConnectWithoutCalificacionesInput = {
    where: examenesWhereUniqueInput
    create: XOR<examenesCreateWithoutCalificacionesInput, examenesUncheckedCreateWithoutCalificacionesInput>
  }

  export type estudiantesUpsertWithoutCalificacionesInput = {
    update: XOR<estudiantesUpdateWithoutCalificacionesInput, estudiantesUncheckedUpdateWithoutCalificacionesInput>
    create: XOR<estudiantesCreateWithoutCalificacionesInput, estudiantesUncheckedCreateWithoutCalificacionesInput>
    where?: estudiantesWhereInput
  }

  export type estudiantesUpdateToOneWithWhereWithoutCalificacionesInput = {
    where?: estudiantesWhereInput
    data: XOR<estudiantesUpdateWithoutCalificacionesInput, estudiantesUncheckedUpdateWithoutCalificacionesInput>
  }

  export type estudiantesUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosEstudiantesUpdateOneWithoutEstudianteNestedInput
    certificados?: certificadosUpdateManyWithoutEstudianteNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEstudianteNestedInput
  }

  export type estudiantesUncheckedUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosEstudiantesUncheckedUpdateOneWithoutEstudianteNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEstudianteNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type examenesUpsertWithoutCalificacionesInput = {
    update: XOR<examenesUpdateWithoutCalificacionesInput, examenesUncheckedUpdateWithoutCalificacionesInput>
    create: XOR<examenesCreateWithoutCalificacionesInput, examenesUncheckedCreateWithoutCalificacionesInput>
    where?: examenesWhereInput
  }

  export type examenesUpdateToOneWithWhereWithoutCalificacionesInput = {
    where?: examenesWhereInput
    data: XOR<examenesUpdateWithoutCalificacionesInput, examenesUncheckedUpdateWithoutCalificacionesInput>
  }

  export type examenesUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutExamenesNestedInput
  }

  export type examenesUncheckedUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type edicionesCursosCreateWithoutInscripcionesInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docente: docenteCreateNestedOneWithoutEdicionesInput
    curso: cursosCreateNestedOneWithoutEdicionesInput
    compras?: comprasCreateNestedManyWithoutEdicionInput
    certificados?: certificadosCreateNestedManyWithoutEdicionInput
    clases?: clasesCreateNestedManyWithoutEdicionInput
    examenes?: examenesCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUncheckedCreateWithoutInscripcionesInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosUncheckedCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosCreateOrConnectWithoutInscripcionesInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutInscripcionesInput, edicionesCursosUncheckedCreateWithoutInscripcionesInput>
  }

  export type estudiantesCreateWithoutInscripcionesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario?: usuariosEstudiantesCreateNestedOneWithoutEstudianteInput
    calificaciones?: calificacionesCreateNestedManyWithoutEstudianteInput
    certificados?: certificadosCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesUncheckedCreateWithoutInscripcionesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario?: usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudianteInput
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutEstudianteInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesCreateOrConnectWithoutInscripcionesInput = {
    where: estudiantesWhereUniqueInput
    create: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
  }

  export type comprasCreateWithoutInscripcionInput = {
    id?: string
    nombre: string
    apellido: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    edicion: edicionesCursosCreateNestedOneWithoutComprasInput
    usuario?: usuariosEstudiantesCreateNestedOneWithoutComprasInput
  }

  export type comprasUncheckedCreateWithoutInscripcionInput = {
    id?: string
    nombre: string
    apellido: string
    edicionId: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    usuariosEstudiantesId?: string | null
  }

  export type comprasCreateOrConnectWithoutInscripcionInput = {
    where: comprasWhereUniqueInput
    create: XOR<comprasCreateWithoutInscripcionInput, comprasUncheckedCreateWithoutInscripcionInput>
  }

  export type edicionesCursosUpsertWithoutInscripcionesInput = {
    update: XOR<edicionesCursosUpdateWithoutInscripcionesInput, edicionesCursosUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<edicionesCursosCreateWithoutInscripcionesInput, edicionesCursosUncheckedCreateWithoutInscripcionesInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutInscripcionesInput, edicionesCursosUncheckedUpdateWithoutInscripcionesInput>
  }

  export type edicionesCursosUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutEdicionesNestedInput
    curso?: cursosUpdateOneRequiredWithoutEdicionesNestedInput
    compras?: comprasUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUpdateManyWithoutEdicionNestedInput
    clases?: clasesUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
    compras?: comprasUncheckedUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUncheckedUpdateManyWithoutEdicionNestedInput
  }

  export type estudiantesUpsertWithoutInscripcionesInput = {
    update: XOR<estudiantesUpdateWithoutInscripcionesInput, estudiantesUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
    where?: estudiantesWhereInput
  }

  export type estudiantesUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: estudiantesWhereInput
    data: XOR<estudiantesUpdateWithoutInscripcionesInput, estudiantesUncheckedUpdateWithoutInscripcionesInput>
  }

  export type estudiantesUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosEstudiantesUpdateOneWithoutEstudianteNestedInput
    calificaciones?: calificacionesUpdateManyWithoutEstudianteNestedInput
    certificados?: certificadosUpdateManyWithoutEstudianteNestedInput
  }

  export type estudiantesUncheckedUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosEstudiantesUncheckedUpdateOneWithoutEstudianteNestedInput
    calificaciones?: calificacionesUncheckedUpdateManyWithoutEstudianteNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type comprasUpsertWithoutInscripcionInput = {
    update: XOR<comprasUpdateWithoutInscripcionInput, comprasUncheckedUpdateWithoutInscripcionInput>
    create: XOR<comprasCreateWithoutInscripcionInput, comprasUncheckedCreateWithoutInscripcionInput>
    where?: comprasWhereInput
  }

  export type comprasUpdateToOneWithWhereWithoutInscripcionInput = {
    where?: comprasWhereInput
    data: XOR<comprasUpdateWithoutInscripcionInput, comprasUncheckedUpdateWithoutInscripcionInput>
  }

  export type comprasUpdateWithoutInscripcionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    edicion?: edicionesCursosUpdateOneRequiredWithoutComprasNestedInput
    usuario?: usuariosEstudiantesUpdateOneWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateWithoutInscripcionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type edicionesCursosCreateWithoutCertificadosInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docente: docenteCreateNestedOneWithoutEdicionesInput
    curso: cursosCreateNestedOneWithoutEdicionesInput
    compras?: comprasCreateNestedManyWithoutEdicionInput
    clases?: clasesCreateNestedManyWithoutEdicionInput
    examenes?: examenesCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUncheckedCreateWithoutCertificadosInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosUncheckedCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosCreateOrConnectWithoutCertificadosInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutCertificadosInput, edicionesCursosUncheckedCreateWithoutCertificadosInput>
  }

  export type estudiantesCreateWithoutCertificadosInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario?: usuariosEstudiantesCreateNestedOneWithoutEstudianteInput
    calificaciones?: calificacionesCreateNestedManyWithoutEstudianteInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesUncheckedCreateWithoutCertificadosInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string | null
    genero?: $Enums.TipoGenero | null
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuario?: usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudianteInput
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutEstudianteInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type estudiantesCreateOrConnectWithoutCertificadosInput = {
    where: estudiantesWhereUniqueInput
    create: XOR<estudiantesCreateWithoutCertificadosInput, estudiantesUncheckedCreateWithoutCertificadosInput>
  }

  export type edicionesCursosUpsertWithoutCertificadosInput = {
    update: XOR<edicionesCursosUpdateWithoutCertificadosInput, edicionesCursosUncheckedUpdateWithoutCertificadosInput>
    create: XOR<edicionesCursosCreateWithoutCertificadosInput, edicionesCursosUncheckedCreateWithoutCertificadosInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutCertificadosInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutCertificadosInput, edicionesCursosUncheckedUpdateWithoutCertificadosInput>
  }

  export type edicionesCursosUpdateWithoutCertificadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutEdicionesNestedInput
    curso?: cursosUpdateOneRequiredWithoutEdicionesNestedInput
    compras?: comprasUpdateManyWithoutEdicionNestedInput
    clases?: clasesUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutCertificadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
    compras?: comprasUncheckedUpdateManyWithoutEdicionNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUncheckedUpdateManyWithoutEdicionNestedInput
  }

  export type estudiantesUpsertWithoutCertificadosInput = {
    update: XOR<estudiantesUpdateWithoutCertificadosInput, estudiantesUncheckedUpdateWithoutCertificadosInput>
    create: XOR<estudiantesCreateWithoutCertificadosInput, estudiantesUncheckedCreateWithoutCertificadosInput>
    where?: estudiantesWhereInput
  }

  export type estudiantesUpdateToOneWithWhereWithoutCertificadosInput = {
    where?: estudiantesWhereInput
    data: XOR<estudiantesUpdateWithoutCertificadosInput, estudiantesUncheckedUpdateWithoutCertificadosInput>
  }

  export type estudiantesUpdateWithoutCertificadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosEstudiantesUpdateOneWithoutEstudianteNestedInput
    calificaciones?: calificacionesUpdateManyWithoutEstudianteNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEstudianteNestedInput
  }

  export type estudiantesUncheckedUpdateWithoutCertificadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    genero?: NullableEnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosEstudiantesUncheckedUpdateOneWithoutEstudianteNestedInput
    calificaciones?: calificacionesUncheckedUpdateManyWithoutEstudianteNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type edicionesCursosCreateWithoutPreciosInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docente: docenteCreateNestedOneWithoutEdicionesInput
    curso: cursosCreateNestedOneWithoutEdicionesInput
    compras?: comprasCreateNestedManyWithoutEdicionInput
    certificados?: certificadosCreateNestedManyWithoutEdicionInput
    clases?: clasesCreateNestedManyWithoutEdicionInput
    examenes?: examenesCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUncheckedCreateWithoutPreciosInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosCreateOrConnectWithoutPreciosInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutPreciosInput, edicionesCursosUncheckedCreateWithoutPreciosInput>
  }

  export type edicionesCursosUpsertWithoutPreciosInput = {
    update: XOR<edicionesCursosUpdateWithoutPreciosInput, edicionesCursosUncheckedUpdateWithoutPreciosInput>
    create: XOR<edicionesCursosCreateWithoutPreciosInput, edicionesCursosUncheckedCreateWithoutPreciosInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutPreciosInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutPreciosInput, edicionesCursosUncheckedUpdateWithoutPreciosInput>
  }

  export type edicionesCursosUpdateWithoutPreciosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutEdicionesNestedInput
    curso?: cursosUpdateOneRequiredWithoutEdicionesNestedInput
    compras?: comprasUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUpdateManyWithoutEdicionNestedInput
    clases?: clasesUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutPreciosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
    compras?: comprasUncheckedUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosCreateWithoutComprasInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docente: docenteCreateNestedOneWithoutEdicionesInput
    curso: cursosCreateNestedOneWithoutEdicionesInput
    certificados?: certificadosCreateNestedManyWithoutEdicionInput
    clases?: clasesCreateNestedManyWithoutEdicionInput
    examenes?: examenesCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosUncheckedCreateWithoutComprasInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionInput
    precios?: preciosCursosUncheckedCreateNestedManyWithoutEdicionInput
  }

  export type edicionesCursosCreateOrConnectWithoutComprasInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutComprasInput, edicionesCursosUncheckedCreateWithoutComprasInput>
  }

  export type inscripcionesCreateWithoutCompraInput = {
    id?: string
    estado?: boolean
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutInscripcionesInput
    estudiante: estudiantesCreateNestedOneWithoutInscripcionesInput
  }

  export type inscripcionesUncheckedCreateWithoutCompraInput = {
    id?: string
    edicionId: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type inscripcionesCreateOrConnectWithoutCompraInput = {
    where: inscripcionesWhereUniqueInput
    create: XOR<inscripcionesCreateWithoutCompraInput, inscripcionesUncheckedCreateWithoutCompraInput>
  }

  export type usuariosEstudiantesCreateWithoutComprasInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    avatar?: string | null
    registrado?: boolean
    estudiante?: estudiantesCreateNestedOneWithoutUsuarioInput
    reviews?: reviewsCursosCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutComprasInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    reviews?: reviewsCursosUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutComprasInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutComprasInput, usuariosEstudiantesUncheckedCreateWithoutComprasInput>
  }

  export type edicionesCursosUpsertWithoutComprasInput = {
    update: XOR<edicionesCursosUpdateWithoutComprasInput, edicionesCursosUncheckedUpdateWithoutComprasInput>
    create: XOR<edicionesCursosCreateWithoutComprasInput, edicionesCursosUncheckedCreateWithoutComprasInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutComprasInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutComprasInput, edicionesCursosUncheckedUpdateWithoutComprasInput>
  }

  export type edicionesCursosUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutEdicionesNestedInput
    curso?: cursosUpdateOneRequiredWithoutEdicionesNestedInput
    certificados?: certificadosUpdateManyWithoutEdicionNestedInput
    clases?: clasesUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUncheckedUpdateManyWithoutEdicionNestedInput
  }

  export type inscripcionesUpsertWithoutCompraInput = {
    update: XOR<inscripcionesUpdateWithoutCompraInput, inscripcionesUncheckedUpdateWithoutCompraInput>
    create: XOR<inscripcionesCreateWithoutCompraInput, inscripcionesUncheckedCreateWithoutCompraInput>
    where?: inscripcionesWhereInput
  }

  export type inscripcionesUpdateToOneWithWhereWithoutCompraInput = {
    where?: inscripcionesWhereInput
    data: XOR<inscripcionesUpdateWithoutCompraInput, inscripcionesUncheckedUpdateWithoutCompraInput>
  }

  export type inscripcionesUpdateWithoutCompraInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutInscripcionesNestedInput
    estudiante?: estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type inscripcionesUncheckedUpdateWithoutCompraInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usuariosEstudiantesUpsertWithoutComprasInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutComprasInput, usuariosEstudiantesUncheckedUpdateWithoutComprasInput>
    create: XOR<usuariosEstudiantesCreateWithoutComprasInput, usuariosEstudiantesUncheckedCreateWithoutComprasInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutComprasInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutComprasInput, usuariosEstudiantesUncheckedUpdateWithoutComprasInput>
  }

  export type usuariosEstudiantesUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    estudiante?: estudiantesUpdateOneWithoutUsuarioNestedInput
    reviews?: reviewsCursosUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    reviews?: reviewsCursosUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type clasesCreateWithoutGrabacionesInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    edicion: edicionesCursosCreateNestedOneWithoutClasesInput
    materiales?: materialesCreateNestedManyWithoutClaseInput
  }

  export type clasesUncheckedCreateWithoutGrabacionesInput = {
    id?: string
    edicionId: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    materiales?: materialesUncheckedCreateNestedManyWithoutClaseInput
  }

  export type clasesCreateOrConnectWithoutGrabacionesInput = {
    where: clasesWhereUniqueInput
    create: XOR<clasesCreateWithoutGrabacionesInput, clasesUncheckedCreateWithoutGrabacionesInput>
  }

  export type usuariosAdministradoresCreateWithoutGrabacionesInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    tipo: $Enums.TipoCuenta
    docente?: docenteCreateNestedOneWithoutUsuarioInput
    auditorias?: auditoriaCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    tipo: $Enums.TipoCuenta
    docente?: docenteUncheckedCreateNestedOneWithoutUsuarioInput
    auditorias?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuariosAdministradoresCreateOrConnectWithoutGrabacionesInput = {
    where: usuariosAdministradoresWhereUniqueInput
    create: XOR<usuariosAdministradoresCreateWithoutGrabacionesInput, usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput>
  }

  export type clasesUpsertWithoutGrabacionesInput = {
    update: XOR<clasesUpdateWithoutGrabacionesInput, clasesUncheckedUpdateWithoutGrabacionesInput>
    create: XOR<clasesCreateWithoutGrabacionesInput, clasesUncheckedCreateWithoutGrabacionesInput>
    where?: clasesWhereInput
  }

  export type clasesUpdateToOneWithWhereWithoutGrabacionesInput = {
    where?: clasesWhereInput
    data: XOR<clasesUpdateWithoutGrabacionesInput, clasesUncheckedUpdateWithoutGrabacionesInput>
  }

  export type clasesUpdateWithoutGrabacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutClasesNestedInput
    materiales?: materialesUpdateManyWithoutClaseNestedInput
  }

  export type clasesUncheckedUpdateWithoutGrabacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    materiales?: materialesUncheckedUpdateManyWithoutClaseNestedInput
  }

  export type usuariosAdministradoresUpsertWithoutGrabacionesInput = {
    update: XOR<usuariosAdministradoresUpdateWithoutGrabacionesInput, usuariosAdministradoresUncheckedUpdateWithoutGrabacionesInput>
    create: XOR<usuariosAdministradoresCreateWithoutGrabacionesInput, usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput>
    where?: usuariosAdministradoresWhereInput
  }

  export type usuariosAdministradoresUpdateToOneWithWhereWithoutGrabacionesInput = {
    where?: usuariosAdministradoresWhereInput
    data: XOR<usuariosAdministradoresUpdateWithoutGrabacionesInput, usuariosAdministradoresUncheckedUpdateWithoutGrabacionesInput>
  }

  export type usuariosAdministradoresUpdateWithoutGrabacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    docente?: docenteUpdateOneWithoutUsuarioNestedInput
    auditorias?: auditoriaUpdateManyWithoutUsuarioNestedInput
  }

  export type usuariosAdministradoresUncheckedUpdateWithoutGrabacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    docente?: docenteUncheckedUpdateOneWithoutUsuarioNestedInput
    auditorias?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type categoriasCursosCreateManyCategoriaInput = {
    id?: string
    cursoId: string
  }

  export type categoriasCursosUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    curso?: cursosUpdateOneRequiredWithoutCategoriasNestedInput
  }

  export type categoriasCursosUncheckedUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
  }

  export type categoriasCursosUncheckedUpdateManyWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsCursosCreateManyUsuarioInput = {
    id?: string
    cursoId: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type comprasCreateManyUsuarioInput = {
    id?: string
    nombre: string
    apellido: string
    edicionId: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
  }

  export type reviewsCursosUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: cursosUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsCursosUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsCursosUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comprasUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    edicion?: edicionesCursosUpdateOneRequiredWithoutComprasNestedInput
    inscripcion?: inscripcionesUpdateOneWithoutCompraNestedInput
  }

  export type comprasUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    inscripcion?: inscripcionesUncheckedUpdateOneWithoutCompraNestedInput
  }

  export type comprasUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type calificacionesCreateManyEstudianteInput = {
    id?: string
    aprobado: boolean
    comentarios?: string | null
    examenId: string
    nota: number
    creadoEn?: Date | string
  }

  export type certificadosCreateManyEstudianteInput = {
    id?: string
    codigoUnico: string
    edicionId: string
    fechaEmision: Date | string
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type inscripcionesCreateManyEstudianteInput = {
    id?: string
    edicionId: string
    estado?: boolean
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    compraId?: string | null
  }

  export type calificacionesUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    examen?: examenesUpdateOneRequiredWithoutCalificacionesNestedInput
  }

  export type calificacionesUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    examenId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    examenId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutCertificadosNestedInput
  }

  export type certificadosUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicion?: edicionesCursosUpdateOneRequiredWithoutInscripcionesNestedInput
    compra?: comprasUpdateOneWithoutInscripcionNestedInput
  }

  export type inscripcionesUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inscripcionesUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditoriaCreateManyUsuarioInput = {
    id?: string
    tabla: string
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
  }

  export type grabacionesCreateManyUsuarioInput = {
    id?: string
    claseId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type auditoriaUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grabacionesUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
    clase?: clasesUpdateOneRequiredWithoutGrabacionesNestedInput
  }

  export type grabacionesUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type grabacionesUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type edicionesCursosCreateManyDocenteInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type edicionesCursosUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: cursosUpdateOneRequiredWithoutEdicionesNestedInput
    compras?: comprasUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUpdateManyWithoutEdicionNestedInput
    clases?: clasesUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compras?: comprasUncheckedUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUncheckedUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateManyWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type edicionesCursosCreateManyCursoInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    docenteId: string
  }

  export type beneficiosCursosCreateManyCursoInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type objetivosCursosCreateManyCursoInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosCreateManyCursoInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type categoriasCursosCreateManyCursoInput = {
    id?: string
    categoriaId: string
  }

  export type reviewsCursosCreateManyCursoInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuariosEstudiantesId: string
  }

  export type edicionesCursosUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutEdicionesNestedInput
    compras?: comprasUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUpdateManyWithoutEdicionNestedInput
    clases?: clasesUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
    compras?: comprasUncheckedUpdateManyWithoutEdicionNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionNestedInput
    precios?: preciosCursosUncheckedUpdateManyWithoutEdicionNestedInput
  }

  export type edicionesCursosUncheckedUpdateManyWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: StringFieldUpdateOperationsInput | string
  }

  export type beneficiosCursosUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosUncheckedUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosUncheckedUpdateManyWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosUncheckedUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosUncheckedUpdateManyWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosUncheckedUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosUncheckedUpdateManyWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasCursosUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoria?: categoriasUpdateOneRequiredWithoutCategoriasCursosNestedInput
  }

  export type categoriasCursosUncheckedUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoriaId?: StringFieldUpdateOperationsInput | string
  }

  export type categoriasCursosUncheckedUpdateManyWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoriaId?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsCursosUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuariosEstudiantesUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsCursosUncheckedUpdateWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantesId?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsCursosUncheckedUpdateManyWithoutCursoInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantesId?: StringFieldUpdateOperationsInput | string
  }

  export type comprasCreateManyEdicionInput = {
    id?: string
    nombre: string
    apellido: string
    monto: number
    moneda?: string
    providerId: string
    comprobado?: boolean
    fechaCompra?: Date | string
    metodo?: string | null
    usuariosEstudiantesId?: string | null
  }

  export type certificadosCreateManyEdicionInput = {
    id?: string
    codigoUnico: string
    estudianteId: string
    fechaEmision: Date | string
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type clasesCreateManyEdicionInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
  }

  export type examenesCreateManyEdicionInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
  }

  export type inscripcionesCreateManyEdicionInput = {
    id?: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
    actualizadoEn?: Date | string
    compraId?: string | null
  }

  export type preciosCursosCreateManyEdicionInput = {
    id?: string
    esDescuento?: boolean
    esPrecioDefault?: boolean
    fechaFin?: Date | string | null
    fechaInicio?: Date | string | null
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type comprasUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    inscripcion?: inscripcionesUpdateOneWithoutCompraNestedInput
    usuario?: usuariosEstudiantesUpdateOneWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
    inscripcion?: inscripcionesUncheckedUpdateOneWithoutCompraNestedInput
  }

  export type comprasUncheckedUpdateManyWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certificadosUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: estudiantesUpdateOneRequiredWithoutCertificadosNestedInput
  }

  export type certificadosUncheckedUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosUncheckedUpdateManyWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clasesUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    materiales?: materialesUpdateManyWithoutClaseNestedInput
    grabaciones?: grabacionesUpdateManyWithoutClaseNestedInput
  }

  export type clasesUncheckedUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    materiales?: materialesUncheckedUpdateManyWithoutClaseNestedInput
    grabaciones?: grabacionesUncheckedUpdateManyWithoutClaseNestedInput
  }

  export type clasesUncheckedUpdateManyWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examenesUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: calificacionesUpdateManyWithoutExamenNestedInput
  }

  export type examenesUncheckedUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: calificacionesUncheckedUpdateManyWithoutExamenNestedInput
  }

  export type examenesUncheckedUpdateManyWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput
    compra?: comprasUpdateOneWithoutInscripcionNestedInput
  }

  export type inscripcionesUncheckedUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inscripcionesUncheckedUpdateManyWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type preciosCursosUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosUncheckedUpdateWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosUncheckedUpdateManyWithoutEdicionInput = {
    id?: StringFieldUpdateOperationsInput | string
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesCreateManyClaseInput = {
    id?: string
    tipo: string
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type grabacionesCreateManyClaseInput = {
    id?: string
    usuarioId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type materialesUpdateWithoutClaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesUncheckedUpdateWithoutClaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesUncheckedUpdateManyWithoutClaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grabacionesUpdateWithoutClaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
    usuario?: usuariosAdministradoresUpdateOneRequiredWithoutGrabacionesNestedInput
  }

  export type grabacionesUncheckedUpdateWithoutClaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type grabacionesUncheckedUpdateManyWithoutClaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type calificacionesCreateManyExamenInput = {
    id?: string
    aprobado: boolean
    comentarios?: string | null
    estudianteId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesUpdateWithoutExamenInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: estudiantesUpdateOneRequiredWithoutCalificacionesNestedInput
  }

  export type calificacionesUncheckedUpdateWithoutExamenInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesUncheckedUpdateManyWithoutExamenInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}